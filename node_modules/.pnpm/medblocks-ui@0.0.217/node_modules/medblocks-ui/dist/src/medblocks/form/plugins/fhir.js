import { flatten, unflatten } from '../utils';
const serialize = (mbElement) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (mbElement.datatype === 'CodableConcept') {
        const codable = mbElement;
        if ((_a = codable.data) === null || _a === void 0 ? void 0 : _a.code) {
            return {
                text: (_b = codable.data) === null || _b === void 0 ? void 0 : _b.value,
                coding: [
                    {
                        system: (_c = codable.data) === null || _c === void 0 ? void 0 : _c.terminology,
                        code: (_d = codable.data) === null || _d === void 0 ? void 0 : _d.code,
                        display: (_e = codable.data) === null || _e === void 0 ? void 0 : _e.value,
                    },
                ],
            };
        }
    }
    else if (mbElement.datatype === 'code') {
        const code = mbElement;
        if ((_f = code.data) === null || _f === void 0 ? void 0 : _f.code) {
            return (_g = code.data) === null || _g === void 0 ? void 0 : _g.code;
        }
    }
    return mbElement.data;
};
const deserialize = (mbElement, data) => {
    var _a, _b, _c;
    if (mbElement.datatype === 'CodableConcept') {
        const terminology = (_a = data === null || data === void 0 ? void 0 : data.coding) === null || _a === void 0 ? void 0 : _a[0].system;
        const code = (_b = data === null || data === void 0 ? void 0 : data.coding) === null || _b === void 0 ? void 0 : _b[0].code;
        const value = (_c = data === null || data === void 0 ? void 0 : data.coding) === null || _c === void 0 ? void 0 : _c[0].display;
        if (terminology || code || value) {
            return {
                terminology,
                code,
                value,
            };
        }
    }
    else if (mbElement.datatype === 'code') {
        const el = mbElement;
        const code = data;
        const { terminology } = el;
        if (terminology || code) {
            return {
                terminology,
                code,
            };
        }
    }
    return data;
};
const isEmpty = (value) => {
    if (value == null) {
        return true;
    }
    if (value &&
        (value === null || value === void 0 ? void 0 : value.constructor) === Object &&
        Object.keys(value).length === 0) {
        return true;
    }
    return false;
};
function toInsertContext(path, nonNullPaths) {
    if (path === 'resourceType') {
        return true;
    }
    const segments = path.split('.');
    const previousPath = segments.slice(0, -1).join('.');
    if (nonNullPaths.some(p => p.startsWith(previousPath))) {
        return true;
    }
    return false;
}
export const FHIRPlugin = {
    serialize(mbElements) {
        const transformed = {};
        for (const path of Object.keys(mbElements)) {
            const value = mbElements[path];
            if (!isEmpty(value.data)) {
                transformed[path] = serialize(value);
            }
        }
        const filtered = JSON.parse(JSON.stringify(transformed));
        return unflatten(filtered);
    },
    parse(mbElements, data) {
        const flat = flatten(data);
        const newObj = {};
        for (const path of Object.keys(mbElements)) {
            const value = flat[path];
            if (value) {
                newObj[path] = deserialize(mbElements[path], value);
            }
            else {
                const includesPath = Object.keys(flat).filter(p => p.startsWith(path));
                const simplifiedObject = {};
                for (const p of includesPath) {
                    let simplifiedPath = p.replace(path, '');
                    if (simplifiedPath.startsWith('.')) {
                        simplifiedPath = simplifiedPath.replace('.', '');
                    }
                    simplifiedObject[simplifiedPath] = flat[p];
                }
                const simplifiedUnflattened = unflatten(simplifiedObject);
                newObj[path] = deserialize(mbElements[path], simplifiedUnflattened);
            }
        }
        return newObj;
    },
    getContext(path, ctx, nonNullPaths, mbElements) {
        if (!toInsertContext(path, nonNullPaths)) {
            return;
        }
        const context = mbElements[path];
        if (context.bind) {
            return context.bind;
        }
        const parts = path.split('.');
        const partsLength = parts.length;
        const contextId = parts.slice(partsLength - 2, partsLength).join('.');
        if (ctx[contextId] !== null) {
            return ctx[contextId];
        }
    },
};
