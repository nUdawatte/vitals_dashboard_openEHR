var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { customElement, property, queryAssignedNodes, state, } from 'lit-element';
import { html } from 'lit-html';
import { unsafeHTML } from 'lit-html/directives/unsafe-html';
import { event } from '../../internal/decorators';
import Repeatable from './Repeatable';
let MbRepeatable = class MbRepeatable extends Repeatable {
    constructor() {
        super(...arguments);
        this.css = '';
    }
    handleAdd() {
        this.count++;
    }
    _getSlotElements() {
        var _a;
        const slot = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('slot');
        return slot === null || slot === void 0 ? void 0 : slot.assignedElements({ flatten: true });
    }
    reloadSlot() {
        const nodes = this.assignedNodes.filter(node => node.nodeType === node.ELEMENT_NODE);
        if (nodes.length > 1) {
            console.warn(`mb-repeatable [path=${this.path}] only support one nested element. Got ${nodes.length} elements. Only taking the first.`);
        }
        [this.slotNode] = nodes;
    }
    replacePath(htmlPath, i) {
        const replaced = htmlPath.replace(this.regex, `$1:${i}`);
        return replaced;
    }
    connectedCallback() {
        super.connectedCallback();
        this.count = 1;
        this.observer = new MutationObserver((mutationList, _) => {
            mutationList.forEach(record => {
                if (record.removedNodes.length > 0) {
                    record.removedNodes.forEach((node) => {
                        if (node.isMbElement) {
                            this._mbDisconnect.emit({ detail: node.path });
                        }
                        else if (node.nodeType === node.ELEMENT_NODE) {
                            const allNodes = node.querySelectorAll('*');
                            allNodes.forEach((nod) => {
                                if (nod.isMbElement) {
                                    this._mbDisconnect.emit({ detail: nod.path });
                                }
                            });
                        }
                    });
                }
            });
        });
        this.observer.observe(this.renderRoot, {
            childList: true,
            subtree: true,
            attributes: false,
        });
    }
    render() {
        return html `
      <slot @slotchange=${this.reloadSlot}></slot>
      ${[...Array(this.count - 1)].map((_, i) => { var _a; return html `${unsafeHTML(this.replacePath((_a = this.slotNode) === null || _a === void 0 ? void 0 : _a.outerHTML, i + 1))}`; })}

      <slot name="add">
        <sl-button
          @click=${() => {
            this.count++;
        }}
          >Add</sl-button
        >
      </slot>
      <slot name="delete">
        <sl-button
          @click=${() => this.count > 1 && this.count--}
          ?disabled=${this.count <= 1}
          >Delete</sl-button
        >
      </slot>
      <link rel="stylesheet" href=${this.css} />
    `;
    }
};
__decorate([
    queryAssignedNodes(undefined, true)
], MbRepeatable.prototype, "assignedNodes", void 0);
__decorate([
    state()
], MbRepeatable.prototype, "slotNode", void 0);
__decorate([
    state()
], MbRepeatable.prototype, "observer", void 0);
__decorate([
    event('mb-disconnect')
], MbRepeatable.prototype, "_mbDisconnect", void 0);
__decorate([
    property({ type: String, reflect: true })
], MbRepeatable.prototype, "css", void 0);
MbRepeatable = __decorate([
    customElement('mb-repeatable-simple')
], MbRepeatable);
export default MbRepeatable;
