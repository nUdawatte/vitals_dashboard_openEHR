import { unflatten } from '../utils';
function getIndexedPath({ i, prefix, suffix, path, }) {
    if (prefix && suffix) {
        return `${prefix}:${i}/${suffix}`;
    }
    return `${path}:${i}`;
}
function multipleSelectArray(value, path, flat, prefix, suffix) {
    value.forEach((val, i) => {
        if (typeof val === 'object') {
            Object.keys(val).forEach(item => {
                if (prefix && suffix) {
                    flat[`${getIndexedPath({ i, prefix, suffix })}|${item}`] = val[item];
                }
                else {
                    flat[`${getIndexedPath({ i, path })}|${item}`] = val[item];
                }
            });
        }
        else {
            const key = prefix && suffix
                ? getIndexedPath({ i, prefix, suffix })
                : getIndexedPath({ i, path });
            flat[key] = val;
        }
    });
}
export function toFlat(data, mbElements) {
    const flat = {};
    Object.keys(data).forEach(path => {
        if (path !== '') {
            const value = data[path];
            const ehrElement = mbElements[path];
            if (typeof value === 'object') {
                if (Array.isArray(value)) {
                    multipleSelectArray(value, path, flat, ehrElement === null || ehrElement === void 0 ? void 0 : ehrElement.repeatprefix, ehrElement === null || ehrElement === void 0 ? void 0 : ehrElement.repeatsuffix);
                }
                else {
                    Object.keys(value).forEach(frag => {
                        const key = frag !== '_root' ? `${path}|${frag}` : path;
                        flat[key] = value[frag];
                    });
                }
            }
            else if (value !== '') {
                flat[path] = value;
            }
        }
    });
    return flat;
}
export function fromFlat(flat) {
    const data = {};
    Object.keys(flat).forEach(path => {
        const value = flat[path];
        const [subpath, frag] = path.split('|');
        if (frag) {
            if (data[subpath] && typeof data[subpath] !== 'object') {
                data[subpath] = { _root: data[subpath] };
            }
            data[subpath] = Object.assign(Object.assign({}, data[subpath]), { [frag]: value });
        }
        else if (data[subpath]) {
            data[subpath] = Object.assign(Object.assign({}, data[subpath]), { _root: value });
        }
        else {
            data[subpath] = value;
        }
    });
    return data;
}
function formatPath(path) {
    return path
        .replace(/\//g, '.')
        .replace(/\|/g, '.')
        .replace(/:(\d)/g, (_, number) => `[${number}]`);
}
export function formatFlatComposition(flat) {
    const newComposition = {};
    Object.entries(flat).forEach(([path, value]) => {
        const formattedPath = formatPath(path);
        newComposition[formattedPath] = value;
    });
    return newComposition;
}
export function unflattenComposition(flat, path) {
    if (!path) {
        return unflatten(formatFlatComposition(flat));
    }
    const newObject = {};
    const paths = Object.keys(flat).filter(p => p.includes(path));
    paths.forEach(p => {
        const newPath = p.replace(path, '');
        newObject[newPath] = flat[p];
    });
    return unflatten(formatFlatComposition(newObject));
}
export function toInsertContext(path, nonNullPaths, mbElements) {
    const segments = path.split('/');
    if (segments.length <= 2) {
        return true;
    }
    let previousPath;
    previousPath = segments.slice(0, -1).join('/');
    const previousSegment = segments[segments.length - 2];
    if (previousSegment === 'context') {
        return true;
    }
    if (previousSegment === 'ism_transition') {
        previousPath = segments.slice(0, -2).join('/');
    }
    const repeatableElementPaths = Object.keys(mbElements)
        .filter(key => { var _a; return (_a = mbElements[key]) === null || _a === void 0 ? void 0 : _a.multiple; })
        .flatMap(pathKey => {
        const el = mbElements[pathKey];
        const data = el === null || el === void 0 ? void 0 : el.data;
        return data
            ? data.map((_, i) => getIndexedPath({
                prefix: el.repeatprefix,
                suffix: el.repeatsuffix,
                path: el.path,
                i,
            }))
            : [];
    });
    const nonNullIncludingRepeatable = [
        ...nonNullPaths,
        ...repeatableElementPaths,
    ];
    if (nonNullIncludingRepeatable.some(p => p.startsWith(previousPath))) {
        return true;
    }
    return false;
}
export const openEHRFlatPlugin = {
    parse(mbElements, data) {
        const parsedData = fromFlat(data);
        const mbElementsWithMultiple = Object.keys(mbElements).filter(path => {
            const element = mbElements[path];
            return element.multiple;
        });
        let pathWithMultiple = [];
        let dataWithMultiple = {};
        mbElementsWithMultiple.forEach(basePath => {
            const prefix = mbElements[basePath].repeatprefix;
            const suffix = mbElements[basePath].repeatsuffix;
            let elementsWithBasePath;
            if (prefix && suffix) {
                elementsWithBasePath = Object.keys(parsedData).filter(path => path.split(':')[0] === prefix &&
                    path.endsWith(suffix));
            }
            else {
                elementsWithBasePath = Object.keys(parsedData).filter(path => path.startsWith(basePath));
            }
            const arrayOfValues = elementsWithBasePath.map(path => parsedData[path]);
            dataWithMultiple = Object.assign(Object.assign({}, dataWithMultiple), { [basePath]: arrayOfValues });
            pathWithMultiple = [...pathWithMultiple, ...elementsWithBasePath];
        });
        pathWithMultiple.forEach(path => {
            delete parsedData[path];
        });
        return Object.assign(Object.assign({}, parsedData), dataWithMultiple);
    },
    serialize(mbElements) {
        const data = {};
        Object.entries(mbElements).forEach(([path, node]) => {
            if (path) {
                data[path] = node.data;
            }
        });
        return JSON.parse(JSON.stringify(toFlat(data, mbElements)));
    },
    getContext(path, ctx = {}, nonNullPaths, mbElements) {
        if (!toInsertContext(path, nonNullPaths, mbElements)) {
            return;
        }
        const parts = path.split('/');
        const contextId = parts[parts.length - 1];
        const context = mbElements[path];
        if (context.bind) {
            return context.bind;
        }
        if (ctx[contextId] != null) {
            return ctx[contextId];
        }
        switch (contextId) {
            case 'start_time':
            case 'time':
                return ctx.time || new Date().toISOString();
            case 'category':
                return {
                    code: '433',
                    value: 'event',
                    terminology: 'openehr',
                };
            case 'setting':
                return {
                    code: '238',
                    value: 'other care',
                    terminology: 'openehr',
                };
            case 'language':
                return {
                    code: ctx.language || 'en',
                    terminology: 'ISO_639-1',
                };
            case 'territory':
                return {
                    code: ctx.territory || 'IN',
                    terminology: 'ISO_3166-1',
                };
            case 'encoding':
                return {
                    code: 'UTF-8',
                    terminology: 'IANA_character-sets',
                };
            case 'composer':
                if (ctx.composer_name) {
                    return {
                        name: ctx.composer_name,
                    };
                }
                return {
                    name: 'Medblocks UI',
                };
            case '_health_care_facility':
                return {
                    name: ctx._health_care_facility || 'Medblocks Hospital',
                    id: ctx._health_care_facility_id || 'Encounter ID',
                    id_scheme: 'Encounter',
                    id_namespace: 'FHIR',
                };
            default:
        }
    },
};
