var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { css, customElement, html, state, LitElement, property, } from 'lit-element';
import { event, watch } from '../../internal/decorators';
import MbContext from '../context/context';
import { unflattenComposition, openEHRFlatPlugin } from './plugins/openEHRFlat';
import { getRepeatableRegex } from '../repeat/Repeatable';
let MedblockForm = class MedblockForm extends LitElement {
    constructor() {
        super(...arguments);
        this.overwritectx = false;
        this.novalidate = false;
        this.templateId = '';
        this.nosuggest = false;
        this.variant = 'normal';
        this.plugin = openEHRFlatPlugin;
        this.serializeDeferredData = true;
        this.mbElementSet = new Set();
        this.repeatables = {};
        this.updates = [];
        this.deferredData = {};
        this.suggestDomain = '*';
        this.triggerInputRequested = false;
        this.handleParentMessage = (e) => {
            var _a, _b;
            const message = e === null || e === void 0 ? void 0 : e.data;
            if ((message === null || message === void 0 ? void 0 : message.type) === 'mb-suggestion') {
                const suggestion = (_a = message === null || message === void 0 ? void 0 : message.data) === null || _a === void 0 ? void 0 : _a.suggestion;
                const templateId = (_b = message === null || message === void 0 ? void 0 : message.data) === null || _b === void 0 ? void 0 : _b.templateId;
                if (suggestion && this.templateId === templateId) {
                    this.addSuggestion(suggestion);
                }
            }
        };
    }
    handleVariantChange(_, newVariant) {
        this.mbElementSet.forEach(el => {
            if (!el.variant) {
                el.variant = newVariant;
            }
        });
    }
    handleSearchChange(_, newHandleSearch) {
        this.mbElementSet.forEach(el => {
            if (!el.handleSearch) {
                el.handleSearch = newHandleSearch;
            }
        });
    }
    get mbElements() {
        const result = {};
        this.mbElementSet.forEach(el => {
            const { path } = el;
            result[path] = el;
        });
        return result;
    }
    validate() {
        if (this.novalidate) {
            return true;
        }
        const report = Object.values(this.mbElements).map((el) => el.reportValidity());
        return report.every(a => a === true);
    }
    parse(data) {
        return this.plugin.parse(this.mbElements, data);
    }
    serialize(mbElements = this.mbElements) {
        const toSerialize = this.serializeDeferredData
            ? Object.assign(Object.assign({}, mbElements), this.dataToContextElements(this.deferredData)) : mbElements;
        const filteredObject = {};
        Object.keys(toSerialize).forEach((key) => {
            if (this.hasValue(toSerialize[key].data))
                filteredObject[key] = toSerialize[key];
        });
        return this.plugin.serialize(filteredObject);
    }
    dataToContextElements(data) {
        const result = {};
        Object.keys(data).forEach(key => {
            const context = new MbContext();
            context.data = data[key];
            result[key] = context;
        });
        return result;
    }
    import(data) {
        this.data = this.parse(data);
    }
    export(validate = false) {
        if (validate)
            this.validate();
        this.insertContext();
        return this.serialize();
    }
    clear() {
        this.data = this.parse({});
    }
    getStructured(flat, path) {
        return unflattenComposition(flat, path);
    }
    async handleSubmit() {
        if (this.validate()) {
            this.insertContext();
            await 0;
            const data = this.serialize();
            this.submit.emit({ detail: data, cancelable: true });
            this.sendWebMessage(true);
        }
    }
    hasValue(value) {
        if (Array.isArray(value)) {
            return value.length > 0;
        }
        if (value && Object.getPrototypeOf(value) === Object.prototype) {
            return Object.keys(value).length > 0;
        }
        if (value === '') {
            return false;
        }
        return value != null;
    }
    isContextElement(element) {
        return (element === null || element === void 0 ? void 0 : element.autocontext) != null;
    }
    nonEmptyPaths() {
        return Object.keys(this.mbElements).filter(k => this.hasValue(this.mbElements[k].data) &&
            !this.isContextElement(this.mbElements[k]));
    }
    nonContextPaths() {
        return Object.keys(this.mbElements).filter(k => { var _a; return ((_a = this.mbElements[k]) === null || _a === void 0 ? void 0 : _a.autocontext) == null; });
    }
    insertContext() {
        const nonNullPaths = this.nonEmptyPaths();
        Object.values(this.mbElements)
            .filter((element) => !!element.autocontext)
            .forEach((element) => {
            var _a;
            const { path } = element;
            const valueToInsert = this.plugin.getContext(path, this.ctx, nonNullPaths, this.mbElements);
            if (valueToInsert != null) {
                const contextData = this.overwritectx
                    ? this.plugin.getContext(path, this.ctx, nonNullPaths, this.mbElements)
                    : (_a = element.data) !== null && _a !== void 0 ? _a : this.plugin.getContext(path, this.ctx, nonNullPaths, this.mbElements);
                element.data = contextData;
            }
            else {
                element.data = undefined;
            }
        });
    }
    async ensureContextsRegistered() {
        await new Promise(resolve => setTimeout(resolve, 0));
        const contexts = Array.from(this.querySelectorAll('mb-context'));
        contexts.forEach(context => {
            const path = context.getAttribute('path');
            if (path && !this.mbElements[path]) {
                this.mbElementSet.add(context);
            }
        });
    }
    get submitButton() {
        return this.querySelector('mb-submit');
    }
    get data() {
        const newValue = {};
        Object.entries(this.mbElements).forEach(([path, node]) => {
            newValue[path] = node.data;
        });
        return newValue;
    }
    getCount(pathString, data) {
        let regex;
        if (typeof pathString === 'string') {
            regex = getRepeatableRegex(pathString);
        }
        else {
            regex = pathString;
        }
        const keys = Object.keys(data);
        const matches = keys
            .map(path => {
            const match = regex.exec(path);
            regex.lastIndex = 0;
            return match;
        })
            .map(match => match === null || match === void 0 ? void 0 : match[2])
            .filter(match => match)
            .map(str => str && parseInt(str, 10));
        if (matches.length === 0) {
            return 0;
        }
        const count = Math.max(...matches) + 1;
        return count;
    }
    set data(data) {
        this.deferredData = {};
        const { mbElements } = this;
        const mbElementPaths = Object.keys(mbElements);
        Object.values(this.repeatables).forEach(el => {
            const { regex } = el;
            el.count = this.getCount(regex, data);
        });
        mbElementPaths.forEach(path => {
            const element = mbElements[path];
            const value = data[path];
            element.data = value;
        });
        const inDataButNotElements = Object.keys(data).filter(path => !mbElementPaths.includes(path));
        if (inDataButNotElements.length > 0) {
            const object = Object.fromEntries(inDataButNotElements.map(key => [key, data[key]]));
            this.deferredData = Object.assign(Object.assign({}, this.deferredData), object);
        }
        this.sendWebMessage();
    }
    sendWebMessage(postSubmit = false, data = this.data) {
        if (window.top && !this.nosuggest) {
            const message = {
                type: 'mb-input',
                data: {
                    composition: data,
                    templateId: this.templateId,
                    format: 'MB-FLAT',
                    postSubmit,
                },
            };
            window.top.postMessage(message, this.suggestDomain);
        }
    }
    handleInput(e) {
        e.stopPropagation();
        this.triggerInput();
    }
    async triggerInput() {
        if (!this.triggerInputRequested) {
            this.triggerInputRequested = true;
            this.triggerInputRequested = await false;
            this._input.emit();
            this.sendWebMessage();
        }
    }
    handleSlotChange() {
        this.triggerInput();
    }
    getTarget(e) {
        return e.composedPath()[0];
    }
    handleChildConnect(e) {
        const path = e.detail;
        const element = this.getTarget(e);
        element.mbForm = this;
        element.variant = this.variant;
        this.mbElementSet.add(element);
        if (this.deferredData[path] != null) {
            const _a = this.deferredData, _b = path, data = _a[_b], excluded = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            this.mbElements[path].data = data;
            this.deferredData = excluded;
        }
        this.triggerInput();
    }
    handleRepeatableConnect(e) {
        const path = e.detail;
        this.repeatables[path] = this.getTarget(e);
        this.triggerInput();
    }
    handleChildDisconnect(e) {
        this.mbElementSet.delete(e.detail.target);
        this.triggerInput();
    }
    handleChildPathChange(_) {
        this.triggerInput();
    }
    addSuggestion(data) {
        const suggestElements = Object.keys(data)
            .map(key => {
            var _a;
            return ({
                key,
                suggest: (_a = this.mbElements[key]) === null || _a === void 0 ? void 0 : _a.parentElement,
            });
        })
            .filter(({ suggest }) => (suggest === null || suggest === void 0 ? void 0 : suggest.nodeName) === 'MB-SUGGEST');
        suggestElements.forEach(({ key, suggest }) => {
            const suggestions = data[key];
            suggest.suggestions = suggestions;
            suggest.path = key;
        });
        const hideElements = this.querySelectorAll('mb-hide');
        hideElements.forEach((el) => {
            if (data[el.path]) {
                el.show = true;
            }
            else {
                el.show = false;
            }
        });
        const globalSuggests = this.querySelectorAll('mb-suggest[global]');
        globalSuggests.forEach((el) => {
            const suggestion = data[el.path];
            if (suggestion) {
                el.suggestions = suggestion;
            }
        });
    }
    handleSuggestion(e) {
        const { suggestion, path, global } = e.detail;
        if (global) {
            this.import(suggestion.data);
            return;
        }
        const element = this.mbElements[path];
        if (element) {
            const oldData = element.data;
            if (suggestion.op === 'replace') {
                element.data = suggestion.data;
            }
            else if (suggestion.op === 'add') {
                if (Array.isArray(element.data)) {
                    element.data = [...oldData, suggestion.data];
                }
                else if (element.data == null) {
                    element.data = [suggestion.data];
                }
                else {
                    element.data = suggestion.data;
                }
            }
            else {
                element.data = suggestion.data;
            }
        }
        this.triggerInput();
    }
    handleTodos() {
        this.triggerInput();
        this.updates.forEach(todo => todo.bind(this));
        this.updates = [];
    }
    async connectedCallback() {
        super.connectedCallback();
        if (Object.keys(this.deferredData).length > 0) {
            const contextElements = this.dataToContextElements(this.deferredData);
            Object.entries(contextElements).forEach(([path, element]) => {
                console.log('Registering context:', path);
                this.mbElementSet.add(element);
            });
        }
        this.addEventListener('mb-connect', this.handleChildConnect);
        this.addEventListener('mb-connect-repeatable', this.handleRepeatableConnect);
        this.addEventListener('mb-disconnect', this.handleChildDisconnect);
        this.addEventListener('mb-path-change', this.handleChildPathChange);
        this.addEventListener('mb-suggestion', this.handleSuggestion);
        if (window.top && !this.nosuggest) {
            window.addEventListener('message', this.handleParentMessage);
        }
        await this.ensureContextsRegistered();
        this.load.emit();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener('mb-connect', this.handleChildConnect);
        this.removeEventListener('mb-connect-repeatable', this.handleRepeatableConnect);
        this.removeEventListener('mb-disconnect', this.handleChildDisconnect);
        this.removeEventListener('mb-path-change', this.handleChildPathChange);
        this.removeEventListener('mb-suggestion', this.handleSuggestion);
        if (window.top && !this.nosuggest) {
            window.removeEventListener('message', this.handleParentMessage);
        }
        this.sendWebMessage(false, {});
    }
    render() {
        return html `<slot
      @slotchange=${this.handleSlotChange}
      @mb-input=${this.handleInput}
      @mb-trigger-submit=${this.handleSubmit}
    ></slot>`;
    }
};
MedblockForm.styles = css `
    :host {
      display: block;
    }
  `;
__decorate([
    property({ type: Object })
], MedblockForm.prototype, "ctx", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], MedblockForm.prototype, "overwritectx", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], MedblockForm.prototype, "novalidate", void 0);
__decorate([
    property({ type: String, reflect: true })
], MedblockForm.prototype, "templateId", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], MedblockForm.prototype, "nosuggest", void 0);
__decorate([
    property({ type: String, reflect: true })
], MedblockForm.prototype, "variant", void 0);
__decorate([
    property({ type: Function })
], MedblockForm.prototype, "handleSearch", void 0);
__decorate([
    watch('variant')
], MedblockForm.prototype, "handleVariantChange", null);
__decorate([
    watch('handleSearch')
], MedblockForm.prototype, "handleSearchChange", null);
__decorate([
    event('mb-input')
], MedblockForm.prototype, "_input", void 0);
__decorate([
    event('mb-load')
], MedblockForm.prototype, "load", void 0);
__decorate([
    property({ type: Object })
], MedblockForm.prototype, "plugin", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], MedblockForm.prototype, "serializeDeferredData", void 0);
__decorate([
    state()
], MedblockForm.prototype, "mbElementSet", void 0);
__decorate([
    state()
], MedblockForm.prototype, "repeatables", void 0);
__decorate([
    state()
], MedblockForm.prototype, "updates", void 0);
__decorate([
    event('mb-submit')
], MedblockForm.prototype, "submit", void 0);
__decorate([
    state()
], MedblockForm.prototype, "deferredData", void 0);
__decorate([
    property({ type: String, reflect: true })
], MedblockForm.prototype, "suggestDomain", void 0);
__decorate([
    state()
], MedblockForm.prototype, "observer", void 0);
__decorate([
    state()
], MedblockForm.prototype, "intervalId", void 0);
MedblockForm = __decorate([
    customElement('mb-form')
], MedblockForm);
export default MedblockForm;
