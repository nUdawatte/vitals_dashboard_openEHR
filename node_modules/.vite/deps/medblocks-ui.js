import "./chunk-UGBVNEQM.js";

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NFF2HMIT.js
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath() {
  return basePath.replace(/\/$/, "");
}
var scripts = [...document.getElementsByTagName("script")];
var configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
if (configScript) {
  setBasePath(configScript.getAttribute("data-shoelace"));
} else {
  const fallbackScript = scripts.find((s6) => /shoelace(\.min)?\.js($|\?)/.test(s6.src));
  let path = "";
  if (fallbackScript) {
    path = fallbackScript.getAttribute("src");
  }
  setBasePath(path.split("/").slice(0, -1).join("/"));
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.C7PPQWMA.js
var library = {
  name: "default",
  resolver: (name) => `${getBasePath()}/assets/icons/${name}.svg`
};
var library_default_default = library;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IDYSXN6R.js
var icons = {
  "check-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-lg" viewBox="0 0 16 16">
      <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425a.247.247 0 0 1 .02-.022Z"></path>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  x: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
      <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.UCCHCS2E.js
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}
function registerIconLibrary(name, options) {
  unregisterIconLibrary(name);
  registry.push({
    name,
    resolver: options.resolver,
    mutator: options.mutator
  });
  watchedIcons.forEach((icon) => {
    if (icon.library === name) {
      icon.redraw();
    }
  });
}
function unregisterIconLibrary(name) {
  registry = registry.filter((lib) => lib.name !== name);
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ICGTMF5Z.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a4, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a4, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a4, prop, b2[prop]);
    }
  return a4;
};
var __spreadProps = (a4, b2) => __defProps(a4, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i5 = decorators.length - 1, decorator; i5 >= 0; i5--)
    if (decorator = decorators[i5])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/internal/icons.js
function registerIcons() {
  const icons2 = {
    check2: `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M0 0h24v24H0z" fill="none"/>
        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="white"/>
      </svg>
    `,
    "exclamation-triangle": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-exclamation-triangle" viewBox="0 0 16 16">
      <path d="M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z"/>
      <path d="M7.002 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 5.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995z"/>
    </svg>`,
    star: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star" viewBox="0 0 16 16">
    <path d="M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.33-.314.16-.888-.282-.95l-4.898-.696L8.465.792a.513.513 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.565.565 0 0 0-.163-.505L1.71 6.745l4.052-.576a.525.525 0 0 0 .393-.288L8 2.223l1.847 3.658a.525.525 0 0 0 .393.288l4.052.575-2.906 2.77a.565.565 0 0 0-.163.506l.694 3.957-3.686-1.894a.503.503 0 0 0-.461 0z"/>
  </svg>`,
    fonts: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-fonts" viewBox="0 0 16 16">
    <path d="M12.258 3h-8.51l-.083 2.46h.479c.26-1.544.758-1.783 2.693-1.845l.424-.013v7.827c0 .663-.144.82-1.3.923v.52h4.082v-.52c-1.162-.103-1.306-.26-1.306-.923V3.602l.431.013c1.934.062 2.434.301 2.693 1.846h.479L12.258 3z"/>
  </svg>`,
    search: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
    <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
  </svg>
      `,
    "caret-down-full": `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-caret-down-fill" viewBox="0 0 16 16">
      <path d="M7.247 11.14L2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z"/>
    </svg>`,
    "arrow-right-circle": `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-right-circle" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M1 8a7 7 0 1 0 14 0A7 7 0 0 0 1 8zm15 0A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM4.5 7.5a.5.5 0 0 0 0 1h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5H4.5z"/>
  </svg>`,
    percent: `<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="percent" class="svg-inline--fa fa-percent fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M112 224c61.9 0 112-50.1 112-112S173.9 0 112 0 0 50.1 0 112s50.1 112 112 112zm0-160c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zm224 224c-61.9 0-112 50.1-112 112s50.1 112 112 112 112-50.1 112-112-50.1-112-112-112zm0 160c-26.5 0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48zM392.3.2l31.6-.1c19.4-.1 30.9 21.8 19.7 37.8L77.4 501.6a23.95 23.95 0 0 1-19.6 10.2l-33.4.1c-19.5 0-30.9-21.9-19.7-37.8l368-463.7C377.2 4 384.5.2 392.3.2z"></path></svg>`,
    decimal: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="3 3 18 19"><path fill="currentColor" d="M22,17L19,20V18H13V16H19V14L22,17M9,5A3,3 0 0,1 12,8V11A3,3 0 0,1 9,14A3,3 0 0,1 6,11V8A3,3 0 0,1 9,5M9,7A1,1 0 0,0 8,8V11A1,1 0 0,0 9,12A1,1 0 0,0 10,11V8A1,1 0 0,0 9,7M16,5A3,3 0 0,1 19,8V11A3,3 0 0,1 16,14A3,3 0 0,1 13,11V8A3,3 0 0,1 16,5M16,7A1,1 0 0,0 15,8V11A1,1 0 0,0 16,12A1,1 0 0,0 17,11V8A1,1 0 0,0 16,7M4,12A1,1 0 0,1 5,13A1,1 0 0,1 4,14A1,1 0 0,1 3,13A1,1 0 0,1 4,12Z" /></svg>`
  };
  const searchLibrary = {
    name: "medblocks",
    resolver: (name) => {
      if (icons2[name]) {
        return `data:image/svg+xml,${encodeURIComponent(icons2[name])}`;
      }
      return "";
    }
  };
  registerIconLibrary("medblocks", searchLibrary);
}

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/dom.js
var isCEPolyfill = typeof window !== "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0;
var removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n6 = start.nextSibling;
    container.removeChild(start);
    start = n6;
  }
};

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/template.js
var marker = `{{lit-${String(Math.random()).slice(2)}}}`;
var nodeMarker = `<!--${marker}-->`;
var markerRegex = new RegExp(`${marker}|${nodeMarker}`);
var boundAttributeSuffix = "$lit$";
var Template = class {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    const nodesToRemove = [];
    const stack = [];
    const walker = document.createTreeWalker(element.content, 133, null, false);
    let lastPartIndex = 0;
    let index = -1;
    let partIndex = 0;
    const { strings, values: { length } } = result;
    while (partIndex < length) {
      const node = walker.nextNode();
      if (node === null) {
        walker.currentNode = stack.pop();
        continue;
      }
      index++;
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attributes = node.attributes;
          const { length: length2 } = attributes;
          let count2 = 0;
          for (let i5 = 0; i5 < length2; i5++) {
            if (endsWith(attributes[i5].name, boundAttributeSuffix)) {
              count2++;
            }
          }
          while (count2-- > 0) {
            const stringForPart = strings[partIndex];
            const name = lastAttributeNameRegex.exec(stringForPart)[2];
            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
            const attributeValue = node.getAttribute(attributeLookupName);
            node.removeAttribute(attributeLookupName);
            const statics = attributeValue.split(markerRegex);
            this.parts.push({ type: "attribute", index, name, strings: statics });
            partIndex += statics.length - 1;
          }
        }
        if (node.tagName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
      } else if (node.nodeType === 3) {
        const data = node.data;
        if (data.indexOf(marker) >= 0) {
          const parent = node.parentNode;
          const strings2 = data.split(markerRegex);
          const lastIndex = strings2.length - 1;
          for (let i5 = 0; i5 < lastIndex; i5++) {
            let insert;
            let s6 = strings2[i5];
            if (s6 === "") {
              insert = createMarker();
            } else {
              const match = lastAttributeNameRegex.exec(s6);
              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                s6 = s6.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
              }
              insert = document.createTextNode(s6);
            }
            parent.insertBefore(insert, node);
            this.parts.push({ type: "node", index: ++index });
          }
          if (strings2[lastIndex] === "") {
            parent.insertBefore(createMarker(), node);
            nodesToRemove.push(node);
          } else {
            node.data = strings2[lastIndex];
          }
          partIndex += lastIndex;
        }
      } else if (node.nodeType === 8) {
        if (node.data === marker) {
          const parent = node.parentNode;
          if (node.previousSibling === null || index === lastPartIndex) {
            index++;
            parent.insertBefore(createMarker(), node);
          }
          lastPartIndex = index;
          this.parts.push({ type: "node", index });
          if (node.nextSibling === null) {
            node.data = "";
          } else {
            nodesToRemove.push(node);
            index--;
          }
          partIndex++;
        } else {
          let i5 = -1;
          while ((i5 = node.data.indexOf(marker, i5 + 1)) !== -1) {
            this.parts.push({ type: "node", index: -1 });
            partIndex++;
          }
        }
      }
    }
    for (const n6 of nodesToRemove) {
      n6.parentNode.removeChild(n6);
    }
  }
};
var endsWith = (str, suffix) => {
  const index = str.length - suffix.length;
  return index >= 0 && str.slice(index) === suffix;
};
var isTemplatePartActive = (part) => part.index !== -1;
var createMarker = () => document.createComment("");
var lastAttributeNameRegex = (
  // eslint-disable-next-line no-control-regex
  /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/
);

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/modify-template.js
var walkerNodeFilter = 133;
function removeNodesFromTemplate(template, nodesToRemove) {
  const { element: { content }, parts: parts2 } = template;
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let part = parts2[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;
  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode;
    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    }
    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node);
      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    }
    if (currentRemovingNode !== null) {
      removeCount++;
    }
    while (part !== void 0 && part.index === nodeIndex) {
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
      part = parts2[partIndex];
    }
  }
  nodesToRemoveInTemplate.forEach((n6) => n6.parentNode.removeChild(n6));
}
var countNodes = (node) => {
  let count2 = node.nodeType === 11 ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
  while (walker.nextNode()) {
    count2++;
  }
  return count2;
};
var nextActiveIndexInTemplateParts = (parts2, startIndex = -1) => {
  for (let i5 = startIndex + 1; i5 < parts2.length; i5++) {
    const part = parts2[i5];
    if (isTemplatePartActive(part)) {
      return i5;
    }
  }
  return -1;
};
function insertNodeIntoTemplate(template, node, refNode = null) {
  const { element: { content }, parts: parts2 } = template;
  if (refNode === null || refNode === void 0) {
    content.appendChild(node);
    return;
  }
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let insertCount = 0;
  let walkerIndex = -1;
  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;
    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }
    while (partIndex !== -1 && parts2[partIndex].index === walkerIndex) {
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts2[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
        }
        return;
      }
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
    }
  }
}

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/directive.js
var directives = /* @__PURE__ */ new WeakMap();
var directive = (f3) => (...args) => {
  const d2 = f3(...args);
  directives.set(d2, true);
  return d2;
};
var isDirective = (o8) => {
  return typeof o8 === "function" && directives.has(o8);
};

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/part.js
var noChange = {};
var nothing = {};

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/template-instance.js
var TemplateInstance = class {
  constructor(template, processor, options) {
    this.__parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options;
  }
  update(values) {
    let i5 = 0;
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.setValue(values[i5]);
      }
      i5++;
    }
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.commit();
      }
    }
  }
  _clone() {
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts2 = this.template.parts;
    const walker = document.createTreeWalker(fragment, 133, null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode();
    while (partIndex < parts2.length) {
      part = parts2[partIndex];
      if (!isTemplatePartActive(part)) {
        this.__parts.push(void 0);
        partIndex++;
        continue;
      }
      while (nodeIndex < part.index) {
        nodeIndex++;
        if (node.nodeName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
        if ((node = walker.nextNode()) === null) {
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      }
      if (part.type === "node") {
        const part2 = this.processor.handleTextExpression(this.options);
        part2.insertAfterNode(node.previousSibling);
        this.__parts.push(part2);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }
      partIndex++;
    }
    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }
    return fragment;
  }
};

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/template-result.js
var policy = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: (s6) => s6 });
var commentMarker = ` ${marker} `;
var TemplateResult = class {
  constructor(strings, values, type, processor) {
    this.strings = strings;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  /**
   * Returns a string of HTML used to create a `<template>` element.
   */
  getHTML() {
    const l6 = this.strings.length - 1;
    let html2 = "";
    let isCommentBinding = false;
    for (let i5 = 0; i5 < l6; i5++) {
      const s6 = this.strings[i5];
      const commentOpen = s6.lastIndexOf("<!--");
      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s6.indexOf("-->", commentOpen + 1) === -1;
      const attributeMatch = lastAttributeNameRegex.exec(s6);
      if (attributeMatch === null) {
        html2 += s6 + (isCommentBinding ? commentMarker : nodeMarker);
      } else {
        html2 += s6.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
      }
    }
    html2 += this.strings[l6];
    return html2;
  }
  getTemplateElement() {
    const template = document.createElement("template");
    let value = this.getHTML();
    if (policy !== void 0) {
      value = policy.createHTML(value);
    }
    template.innerHTML = value;
    return template;
  }
};

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/parts.js
var isPrimitive = (value) => {
  return value === null || !(typeof value === "object" || typeof value === "function");
};
var isIterable = (value) => {
  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  !!(value && value[Symbol.iterator]);
};
var AttributeCommitter = class {
  constructor(element, name, strings) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings;
    this.parts = [];
    for (let i5 = 0; i5 < strings.length - 1; i5++) {
      this.parts[i5] = this._createPart();
    }
  }
  /**
   * Creates a single part. Override this to create a differnt type of part.
   */
  _createPart() {
    return new AttributePart(this);
  }
  _getValue() {
    const strings = this.strings;
    const l6 = strings.length - 1;
    const parts2 = this.parts;
    if (l6 === 1 && strings[0] === "" && strings[1] === "") {
      const v2 = parts2[0].value;
      if (typeof v2 === "symbol") {
        return String(v2);
      }
      if (typeof v2 === "string" || !isIterable(v2)) {
        return v2;
      }
    }
    let text = "";
    for (let i5 = 0; i5 < l6; i5++) {
      text += strings[i5];
      const part = parts2[i5];
      if (part !== void 0) {
        const v2 = part.value;
        if (isPrimitive(v2) || !isIterable(v2)) {
          text += typeof v2 === "string" ? v2 : String(v2);
        } else {
          for (const t5 of v2) {
            text += typeof t5 === "string" ? t5 : String(t5);
          }
        }
      }
    }
    text += strings[l6];
    return text;
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }
};
var AttributePart = class {
  constructor(committer) {
    this.value = void 0;
    this.committer = committer;
  }
  setValue(value) {
    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
      this.value = value;
      if (!isDirective(value)) {
        this.committer.dirty = true;
      }
    }
  }
  commit() {
    while (isDirective(this.value)) {
      const directive2 = this.value;
      this.value = noChange;
      directive2(this);
    }
    if (this.value === noChange) {
      return;
    }
    this.committer.commit();
  }
};
var NodePart = class _NodePart {
  constructor(options) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.options = options;
  }
  /**
   * Appends this part into a container.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  /**
   * Inserts this part after the `ref` node (between `ref` and `ref`'s next
   * sibling). Both `ref` and its next sibling must be static, unchanging nodes
   * such as those that appear in a literal section of a template.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  /**
   * Appends this part into a parent part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  appendIntoPart(part) {
    part.__insert(this.startNode = createMarker());
    part.__insert(this.endNode = createMarker());
  }
  /**
   * Inserts this part after the `ref` part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  insertAfterPart(ref) {
    ref.__insert(this.startNode = createMarker());
    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    if (this.startNode.parentNode === null) {
      return;
    }
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    const value = this.__pendingValue;
    if (value === noChange) {
      return;
    }
    if (isPrimitive(value)) {
      if (value !== this.value) {
        this.__commitText(value);
      }
    } else if (value instanceof TemplateResult) {
      this.__commitTemplateResult(value);
    } else if (value instanceof Node) {
      this.__commitNode(value);
    } else if (isIterable(value)) {
      this.__commitIterable(value);
    } else if (value === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      this.__commitText(value);
    }
  }
  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }
  __commitNode(value) {
    if (this.value === value) {
      return;
    }
    this.clear();
    this.__insert(value);
    this.value = value;
  }
  __commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? "" : value;
    const valueAsString = typeof value === "string" ? value : String(value);
    if (node === this.endNode.previousSibling && node.nodeType === 3) {
      node.data = valueAsString;
    } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }
    this.value = value;
  }
  __commitTemplateResult(value) {
    const template = this.options.templateFactory(value);
    if (this.value instanceof TemplateInstance && this.value.template === template) {
      this.value.update(value.values);
    } else {
      const instance = new TemplateInstance(template, value.processor, this.options);
      const fragment = instance._clone();
      instance.update(value.values);
      this.__commitNode(fragment);
      this.value = instance;
    }
  }
  __commitIterable(value) {
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    }
    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      itemPart = itemParts[partIndex];
      if (itemPart === void 0) {
        itemPart = new _NodePart(this.options);
        itemParts.push(itemPart);
        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }
      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }
  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }
};
var BooleanAttributePart = class {
  constructor(element, name, strings) {
    this.value = void 0;
    this.__pendingValue = void 0;
    if (strings.length !== 2 || strings[0] !== "" || strings[1] !== "") {
      throw new Error("Boolean attributes can only contain a single expression");
    }
    this.element = element;
    this.name = name;
    this.strings = strings;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const value = !!this.__pendingValue;
    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, "");
      } else {
        this.element.removeAttribute(this.name);
      }
      this.value = value;
    }
    this.__pendingValue = noChange;
  }
};
var PropertyCommitter = class extends AttributeCommitter {
  constructor(element, name, strings) {
    super(element, name, strings);
    this.single = strings.length === 2 && strings[0] === "" && strings[1] === "";
  }
  _createPart() {
    return new PropertyPart(this);
  }
  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }
    return super._getValue();
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element[this.name] = this._getValue();
    }
  }
};
var PropertyPart = class extends AttributePart {
};
var eventOptionsSupported = false;
(() => {
  try {
    const options = {
      get capture() {
        eventOptionsSupported = true;
        return false;
      }
    };
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (_e) {
  }
})();
var EventPart = class {
  constructor(element, eventName, eventContext) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;
    this.__boundHandleEvent = (e6) => this.handleEvent(e6);
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    this.value = newListener;
    this.__pendingValue = noChange;
  }
  handleEvent(event2) {
    if (typeof this.value === "function") {
      this.value.call(this.eventContext || this.element, event2);
    } else {
      this.value.handleEvent(event2);
    }
  }
};
var getOptions = (o8) => o8 && (eventOptionsSupported ? { capture: o8.capture, passive: o8.passive, once: o8.once } : o8.capture);

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/template-factory.js
function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(result.type, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    template = new Template(result, result.getTemplateElement());
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
}
var templateCaches = /* @__PURE__ */ new Map();

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/render.js
var parts = /* @__PURE__ */ new WeakMap();
var render = (result, container, options) => {
  let part = parts.get(container);
  if (part === void 0) {
    removeNodes(container, container.firstChild);
    parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
    part.appendInto(container);
  }
  part.setValue(result);
  part.commit();
};

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/default-template-processor.js
var DefaultTemplateProcessor = class {
  /**
   * Create parts for an attribute-position binding, given the event, attribute
   * name, and string literals.
   *
   * @param element The element containing the binding
   * @param name  The attribute name
   * @param strings The string literals. There are always at least two strings,
   *   event for fully-controlled bindings with a single expression.
   */
  handleAttributeExpressions(element, name, strings, options) {
    const prefix = name[0];
    if (prefix === ".") {
      const committer2 = new PropertyCommitter(element, name.slice(1), strings);
      return committer2.parts;
    }
    if (prefix === "@") {
      return [new EventPart(element, name.slice(1), options.eventContext)];
    }
    if (prefix === "?") {
      return [new BooleanAttributePart(element, name.slice(1), strings)];
    }
    const committer = new AttributeCommitter(element, name, strings);
    return committer.parts;
  }
  /**
   * Create parts for a text-position binding.
   * @param templateFactory
   */
  handleTextExpression(options) {
    return new NodePart(options);
  }
};
var defaultTemplateProcessor = new DefaultTemplateProcessor();

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lit-html.js
if (typeof window !== "undefined") {
  (window["litHtmlVersions"] || (window["litHtmlVersions"] = [])).push("1.4.1");
}
var html = (strings, ...values) => new TemplateResult(strings, values, "html", defaultTemplateProcessor);

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/lib/shady-render.js
var getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
var compatibleShadyCSSVersion = true;
if (typeof window.ShadyCSS === "undefined") {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === "undefined") {
  console.warn(`Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
var shadyTemplateFactory = (scopeName) => (result) => {
  const cacheKey = getTemplateCacheKey(result.type, scopeName);
  let templateCache = templateCaches.get(cacheKey);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(cacheKey, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    const element = result.getTemplateElement();
    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element, scopeName);
    }
    template = new Template(result, element);
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
};
var TEMPLATE_TYPES = ["html", "svg"];
var removeStylesFromLitTemplates = (scopeName) => {
  TEMPLATE_TYPES.forEach((type) => {
    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
    if (templates !== void 0) {
      templates.keyString.forEach((template) => {
        const { element: { content } } = template;
        const styles = /* @__PURE__ */ new Set();
        Array.from(content.querySelectorAll("style")).forEach((s6) => {
          styles.add(s6);
        });
        removeNodesFromTemplate(template, styles);
      });
    }
  });
};
var shadyRenderSet = /* @__PURE__ */ new Set();
var prepareTemplateStyles = (scopeName, renderedDOM, template) => {
  shadyRenderSet.add(scopeName);
  const templateElement = !!template ? template.element : document.createElement("template");
  const styles = renderedDOM.querySelectorAll("style");
  const { length } = styles;
  if (length === 0) {
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    return;
  }
  const condensedStyle = document.createElement("style");
  for (let i5 = 0; i5 < length; i5++) {
    const style2 = styles[i5];
    style2.parentNode.removeChild(style2);
    condensedStyle.textContent += style2.textContent;
  }
  removeStylesFromLitTemplates(scopeName);
  const content = templateElement.content;
  if (!!template) {
    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
  } else {
    content.insertBefore(condensedStyle, content.firstChild);
  }
  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
  const style = content.querySelector("style");
  if (window.ShadyCSS.nativeShadow && style !== null) {
    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
  } else if (!!template) {
    content.insertBefore(condensedStyle, content.firstChild);
    const removes = /* @__PURE__ */ new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template, removes);
  }
};
var render2 = (result, container, options) => {
  if (!options || typeof options !== "object" || !options.scopeName) {
    throw new Error("The `scopeName` option is required.");
  }
  const scopeName = options.scopeName;
  const hasRendered = parts.has(container);
  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 && !!container.host;
  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
  if (firstScopeRender) {
    const part = parts.get(renderContainer);
    parts.delete(renderContainer);
    const template = part.value instanceof TemplateInstance ? part.value.template : void 0;
    prepareTemplateStyles(scopeName, renderContainer, template);
    removeNodes(container, container.firstChild);
    container.appendChild(renderContainer);
    parts.set(container, part);
  }
  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};

// node_modules/.pnpm/lit-element@2.5.1/node_modules/lit-element/lib/updating-element.js
var _a;
window.JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value ? "" : null;
      case Object:
      case Array:
        return value == null ? value : JSON.stringify(value);
    }
    return value;
  },
  fromAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value !== null;
      case Number:
        return value === null ? null : Number(value);
      case Object:
      case Array:
        return JSON.parse(value);
    }
    return value;
  }
};
var notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
var STATE_HAS_UPDATED = 1;
var STATE_UPDATE_REQUESTED = 1 << 2;
var STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
var STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
var finalized = "finalized";
var UpdatingElement = class extends HTMLElement {
  constructor() {
    super();
    this.initialize();
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   */
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this._classProperties.forEach((v2, p2) => {
      const attr = this._attributeNameForProperty(p2, v2);
      if (attr !== void 0) {
        this._attributeToPropertyMap.set(attr, p2);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  /**
   * Ensures the private `_classProperties` property metadata is created.
   * In addition to `finalize` this is also called in `createProperty` to
   * ensure the `@property` decorator can add property metadata.
   */
  /** @nocollapse */
  static _ensureClassProperties() {
    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
      this._classProperties = /* @__PURE__ */ new Map();
      const superProperties = Object.getPrototypeOf(this)._classProperties;
      if (superProperties !== void 0) {
        superProperties.forEach((v2, k2) => this._classProperties.set(k2, v2));
      }
    }
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a PropertyDeclaration for the property with the given options.
   * The property setter calls the property's `hasChanged` property option
   * or uses a strict identity check to determine whether or not to request
   * an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   *
   * @nocollapse
   */
  static createProperty(name, options = defaultPropertyDeclaration) {
    this._ensureClassProperties();
    this._classProperties.set(name, options);
    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }
    const key = typeof name === "symbol" ? Symbol() : `__${name}`;
    const descriptor = this.getPropertyDescriptor(name, key, options);
    if (descriptor !== void 0) {
      Object.defineProperty(this.prototype, name, descriptor);
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   *   class MyElement extends LitElement {
   *     static getPropertyDescriptor(name, key, options) {
   *       const defaultDescriptor =
   *           super.getPropertyDescriptor(name, key, options);
   *       const setter = defaultDescriptor.set;
   *       return {
   *         get: defaultDescriptor.get,
   *         set(value) {
   *           setter.call(this, value);
   *           // custom action.
   *         },
   *         configurable: true,
   *         enumerable: true
   *       }
   *     }
   *   }
   *
   * @nocollapse
   */
  static getPropertyDescriptor(name, key, options) {
    return {
      // tslint:disable-next-line:no-any no symbol in index
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name];
        this[key] = value;
        this.requestUpdateInternal(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a PropertyDeclaration via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override `createProperty`.
   *
   * @nocollapse
   * @final
   */
  static getPropertyOptions(name) {
    return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
  }
  /**
   * Creates property accessors for registered properties and ensures
   * any superclasses are also finalized.
   * @nocollapse
   */
  static finalize() {
    const superCtor = Object.getPrototypeOf(this);
    if (!superCtor.hasOwnProperty(finalized)) {
      superCtor.finalize();
    }
    this[finalized] = true;
    this._ensureClassProperties();
    this._attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...typeof Object.getOwnPropertySymbols === "function" ? Object.getOwnPropertySymbols(props) : []
      ];
      for (const p2 of propKeys) {
        this.createProperty(p2, props[p2]);
      }
    }
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */
  static _attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  /**
   * Returns true if a property should request an update.
   * Called when a property value is set and uses the `hasChanged`
   * option for the property if present or a strict identity check.
   * @nocollapse
   */
  static _valueHasChanged(value, old, hasChanged = notEqual) {
    return hasChanged(value, old);
  }
  /**
   * Returns the property value for the given attribute value.
   * Called via the `attributeChangedCallback` and uses the property's
   * `converter` or `converter.fromAttribute` property option.
   * @nocollapse
   */
  static _propertyValueFromAttribute(value, options) {
    const type = options.type;
    const converter = options.converter || defaultConverter;
    const fromAttribute = typeof converter === "function" ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value, type) : value;
  }
  /**
   * Returns the attribute value for the given property value. If this
   * returns undefined, the property will *not* be reflected to an attribute.
   * If this returns null, the attribute will be removed, otherwise the
   * attribute will be set to the value.
   * This uses the property's `reflect` and `type.toAttribute` property options.
   * @nocollapse
   */
  static _propertyValueToAttribute(value, options) {
    if (options.reflect === void 0) {
      return;
    }
    const type = options.type;
    const converter = options.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value, type);
  }
  /**
   * Performs element initialization. By default captures any pre-set values for
   * registered properties.
   */
  initialize() {
    this._updateState = 0;
    this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);
    this._changedProperties = /* @__PURE__ */ new Map();
    this._saveInstanceProperties();
    this.requestUpdateInternal();
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
   * (<=41), properties created for native platform properties like (`id` or
   * `name`) may not have default values set in the element constructor. On
   * these browsers native properties appear on instances and therefore their
   * default value will overwrite any element default (e.g. if the element sets
   * this.id = 'id' in the constructor, the 'id' will become '' since this is
   * the native platform default).
   */
  _saveInstanceProperties() {
    this.constructor._classProperties.forEach((_v, p2) => {
      if (this.hasOwnProperty(p2)) {
        const value = this[p2];
        delete this[p2];
        if (!this._instanceProperties) {
          this._instanceProperties = /* @__PURE__ */ new Map();
        }
        this._instanceProperties.set(p2, value);
      }
    });
  }
  /**
   * Applies previously saved instance properties.
   */
  _applyInstanceProperties() {
    this._instanceProperties.forEach((v2, p2) => this[p2] = v2);
    this._instanceProperties = void 0;
  }
  connectedCallback() {
    this.enableUpdating();
  }
  enableUpdating() {
    if (this._enableUpdatingResolver !== void 0) {
      this._enableUpdatingResolver();
      this._enableUpdatingResolver = void 0;
    }
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   */
  disconnectedCallback() {
  }
  /**
   * Synchronizes property values when attributes change.
   */
  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this._attributeToProperty(name, value);
    }
  }
  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    const ctor = this.constructor;
    const attr = ctor._attributeNameForProperty(name, options);
    if (attr !== void 0) {
      const attrValue = ctor._propertyValueToAttribute(value, options);
      if (attrValue === void 0) {
        return;
      }
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }
  _attributeToProperty(name, value) {
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }
    const ctor = this.constructor;
    const propName = ctor._attributeToPropertyMap.get(name);
    if (propName !== void 0) {
      const options = ctor.getPropertyOptions(propName);
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = // tslint:disable-next-line:no-any
      ctor._propertyValueFromAttribute(value, options);
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  /**
   * This protected version of `requestUpdate` does not access or return the
   * `updateComplete` promise. This promise can be overridden and is therefore
   * not free to access.
   */
  requestUpdateInternal(name, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name !== void 0) {
      const ctor = this.constructor;
      options = options || ctor.getPropertyOptions(name);
      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        }
        if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === void 0) {
            this._reflectingProperties = /* @__PURE__ */ new Map();
          }
          this._reflectingProperties.set(name, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._updatePromise = this._enqueueUpdate();
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should
   * be called when an element should update based on some state not triggered
   * by setting a property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored. Returns the `updateComplete` Promise which is resolved
   * when the update completes.
   *
   * @param name {PropertyKey} (optional) name of requesting property
   * @param oldValue {any} (optional) old value of requesting property
   * @returns {Promise} A Promise that is resolved when the update completes.
   */
  requestUpdate(name, oldValue) {
    this.requestUpdateInternal(name, oldValue);
    return this.updateComplete;
  }
  /**
   * Sets up the element to asynchronously update.
   */
  async _enqueueUpdate() {
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
    try {
      await this._updatePromise;
    } catch (e6) {
    }
    const result = this.performUpdate();
    if (result != null) {
      await result;
    }
    return !this._hasRequestedUpdate;
  }
  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }
  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * You can override this method to change the timing of updates. If this
   * method is overridden, `super.performUpdate()` must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```
   * protected async performUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.performUpdate();
   * }
   * ```
   */
  performUpdate() {
    if (!this._hasRequestedUpdate) {
      return;
    }
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }
    let shouldUpdate = false;
    const changedProperties = this._changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.update(changedProperties);
      } else {
        this._markUpdated();
      }
    } catch (e6) {
      shouldUpdate = false;
      this._markUpdated();
      throw e6;
    }
    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
    }
  }
  _markUpdated() {
    this._changedProperties = /* @__PURE__ */ new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `_getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super._getUpdateComplete()`, then any subsequent state.
   *
   * @returns {Promise} The Promise returns a boolean that indicates if the
   * update resolved without triggering another update.
   */
  get updateComplete() {
    return this._getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   *   class MyElement extends LitElement {
   *     async _getUpdateComplete() {
   *       await super._getUpdateComplete();
   *       await this._myChild.updateComplete;
   *     }
   *   }
   * @deprecated Override `getUpdateComplete()` instead for forward
   *     compatibility with `lit-element` 3.0 / `@lit/reactive-element`.
   */
  _getUpdateComplete() {
    return this.getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   *   class MyElement extends LitElement {
   *     async getUpdateComplete() {
   *       await super.getUpdateComplete();
   *       await this._myChild.updateComplete;
   *     }
   *   }
   */
  getUpdateComplete() {
    return this._updatePromise;
  }
  /**
   * Controls whether or not `update` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  update(_changedProperties) {
    if (this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0) {
      this._reflectingProperties.forEach((v2, k2) => this._propertyToAttribute(k2, this[k2], v2));
      this._reflectingProperties = void 0;
    }
    this._markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  updated(_changedProperties) {
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  firstUpdated(_changedProperties) {
  }
};
_a = finalized;
UpdatingElement[_a] = true;

// node_modules/.pnpm/lit-element@2.5.1/node_modules/lit-element/lib/decorators.js
var legacyCustomElement = (tagName, clazz) => {
  window.customElements.define(tagName, clazz);
  return clazz;
};
var standardCustomElement = (tagName, descriptor) => {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    // This callback is called once the class is otherwise fully defined
    finisher(clazz) {
      window.customElements.define(tagName, clazz);
    }
  };
};
var customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
var standardProperty = (options, element) => {
  if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
    return Object.assign(Object.assign({}, element), { finisher(clazz) {
      clazz.createProperty(element.key, options);
    } });
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      // When @babel/plugin-proposal-decorators implements initializers,
      // do this instead of the initializer below. See:
      // https://github.com/babel/babel/issues/9260 extras: [
      //   {
      //     kind: 'initializer',
      //     placement: 'own',
      //     initializer: descriptor.initializer,
      //   }
      // ],
      initializer() {
        if (typeof element.initializer === "function") {
          this[element.key] = element.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    };
  }
};
var legacyProperty = (options, proto, name) => {
  proto.constructor.createProperty(name, options);
};
function property(options) {
  return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
}
function internalProperty(options) {
  return property({ attribute: false, hasChanged: options === null || options === void 0 ? void 0 : options.hasChanged });
}
var state = (options) => internalProperty(options);
function query(selector, cache) {
  return (protoOrDescriptor, name) => {
    const descriptor = {
      get() {
        return this.renderRoot.querySelector(selector);
      },
      enumerable: true,
      configurable: true
    };
    if (cache) {
      const prop = name !== void 0 ? name : protoOrDescriptor.key;
      const key = typeof prop === "symbol" ? Symbol() : `__${prop}`;
      descriptor.get = function() {
        if (this[key] === void 0) {
          this[key] = this.renderRoot.querySelector(selector);
        }
        return this[key];
      };
    }
    return name !== void 0 ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}
var legacyQuery = (descriptor, proto, name) => {
  Object.defineProperty(proto, name, descriptor);
};
var standardQuery = (descriptor, element) => ({
  kind: "method",
  placement: "prototype",
  key: element.key,
  descriptor
});
var ElementProto = Element.prototype;
var legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;
function queryAssignedNodes(slotName = "", flatten2 = false, selector = "") {
  return (protoOrDescriptor, name) => {
    const descriptor = {
      get() {
        const slotSelector = `slot${slotName ? `[name=${slotName}]` : ":not([name])"}`;
        const slot = this.renderRoot.querySelector(slotSelector);
        let nodes = slot && slot.assignedNodes({ flatten: flatten2 });
        if (nodes && selector) {
          nodes = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && // tslint:disable-next-line:no-any testing existence on older browsers
          (node.matches ? node.matches(selector) : legacyMatches.call(node, selector)));
        }
        return nodes;
      },
      enumerable: true,
      configurable: true
    };
    return name !== void 0 ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}

// node_modules/.pnpm/lit-element@2.5.1/node_modules/lit-element/lib/css-tag.js
var supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var CSSResult = class {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
  }
  // Note, this is a getter so that it's lazy. In practice, this means
  // stylesheets are not created until the first element instance is made.
  get styleSheet() {
    if (this._styleSheet === void 0) {
      if (supportsAdoptingStyleSheets) {
        this._styleSheet = new CSSStyleSheet();
        this._styleSheet.replaceSync(this.cssText);
      } else {
        this._styleSheet = null;
      }
    }
    return this._styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var unsafeCSS = (value) => {
  return new CSSResult(String(value), constructionToken);
};
var textFromCSSResult = (value) => {
  if (value instanceof CSSResult) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
  }
};
var css = (strings, ...values) => {
  const cssText = values.reduce((acc, v2, idx) => acc + textFromCSSResult(v2) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, constructionToken);
};

// node_modules/.pnpm/lit-element@2.5.1/node_modules/lit-element/lit-element.js
(window["litElementVersions"] || (window["litElementVersions"] = [])).push("2.5.1");
var renderNotImplemented = {};
var LitElement = class extends UpdatingElement {
  /**
   * Return the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * @nocollapse
   */
  static getStyles() {
    return this.styles;
  }
  /** @nocollapse */
  static _getUniqueStyles() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) {
      return;
    }
    const userStyles = this.getStyles();
    if (Array.isArray(userStyles)) {
      const addStyles = (styles2, set2) => styles2.reduceRight((set3, s6) => (
        // Note: On IE set.add() does not return the set
        Array.isArray(s6) ? addStyles(s6, set3) : (set3.add(s6), set3)
      ), set2);
      const set = addStyles(userStyles, /* @__PURE__ */ new Set());
      const styles = [];
      set.forEach((v2) => styles.unshift(v2));
      this._styles = styles;
    } else {
      this._styles = userStyles === void 0 ? [] : [userStyles];
    }
    this._styles = this._styles.map((s6) => {
      if (s6 instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
        const cssText = Array.prototype.slice.call(s6.cssRules).reduce((css2, rule) => css2 + rule.cssText, "");
        return unsafeCSS(cssText);
      }
      return s6;
    });
  }
  /**
   * Performs element initialization. By default this calls
   * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and
   * captures any pre-set values for registered properties.
   */
  initialize() {
    super.initialize();
    this.constructor._getUniqueStyles();
    this.renderRoot = this.createRenderRoot();
    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   * @returns {Element|DocumentFragment} Returns a node into which to render.
   */
  createRenderRoot() {
    return this.attachShadow(this.constructor.shadowRootOptions);
  }
  /**
   * Applies styling to the element shadowRoot using the [[`styles`]]
   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
   * available and will fallback otherwise. When Shadow DOM is polyfilled,
   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
   * is available but `adoptedStyleSheets` is not, styles are appended to the
   * end of the `shadowRoot` to [mimic spec
   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
   */
  adoptStyles() {
    const styles = this.constructor._styles;
    if (styles.length === 0) {
      return;
    }
    if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s6) => s6.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles.map((s6) => s6 instanceof CSSStyleSheet ? s6 : s6.styleSheet);
    } else {
      this._needsShimAdoptedStyleSheets = true;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.hasUpdated && window.ShadyCSS !== void 0) {
      window.ShadyCSS.styleElement(this);
    }
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param _changedProperties Map of changed properties with old values
   */
  update(changedProperties) {
    const templateResult = this.render();
    super.update(changedProperties);
    if (templateResult !== renderNotImplemented) {
      this.constructor.render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
    }
    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;
      this.constructor._styles.forEach((s6) => {
        const style = document.createElement("style");
        style.textContent = s6.cssText;
        this.renderRoot.appendChild(style);
      });
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's `NodePart` - typically a
   * `TemplateResult`. Setting properties inside this method will *not* trigger
   * the element to update.
   */
  render() {
    return renderNotImplemented;
  }
};
LitElement["finalized"] = true;
LitElement.render = render2;
LitElement.shadowRootOptions = { mode: "open" };

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/internal/decorators.js
var EventEmitter = class {
  constructor(target, eventName) {
    this.target = target;
    this.eventName = eventName;
  }
  emit(eventOptions) {
    const eventTarget = new CustomEvent(this.eventName, Object.assign({ bubbles: true, cancelable: true, composed: true, detail: {} }, eventOptions));
    this.target.dispatchEvent(eventTarget);
    return eventTarget;
  }
};
function event(eventName) {
  function legacyEvent(descriptor, protoOrDescriptor, name) {
    Object.defineProperty(protoOrDescriptor, name, descriptor);
  }
  function standardEvent(descriptor, element) {
    return {
      kind: "method",
      placement: "prototype",
      key: element.key,
      descriptor
    };
  }
  return (protoOrDescriptor, name) => {
    const descriptor = {
      get() {
        return new EventEmitter(this, eventName || (name !== void 0 ? name : protoOrDescriptor.key));
      },
      enumerable: true,
      configurable: true
    };
    return name !== void 0 ? legacyEvent(descriptor, protoOrDescriptor, name) : standardEvent(descriptor, protoOrDescriptor);
  };
}
function watch(propName) {
  return (protoOrDescriptor, name) => {
    const { firstUpdated, update } = protoOrDescriptor;
    protoOrDescriptor.firstUpdated = function(changedProps) {
      firstUpdated.call(this, changedProps);
      this.__didFirstUpdate = true;
    };
    protoOrDescriptor.update = function(changedProps) {
      if (this.__didFirstUpdate && changedProps.has(propName)) {
        const oldValue = changedProps.get(propName);
        const newValue = this[propName];
        if (oldValue !== newValue) {
          this[name].call(this, oldValue, newValue);
        }
      }
      update.call(this, changedProps);
    };
  };
}

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/EhrElement.js
var __decorate = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var EhrElement = class extends LitElement {
  constructor() {
    super(...arguments);
    this.variant = "normal";
    this.isMbElement = true;
  }
  reportValidity() {
    return true;
  }
  handlePathChange(oldPath, newPath) {
    this._pathChangeHandler.emit({ detail: { oldPath, newPath } });
  }
  connectedCallback() {
    super.connectedCallback();
    this._mbConnect.emit({ detail: this.path });
    this._mbInput.emit();
  }
  disconnectedCallback() {
    if (this.mbForm) {
      this.mbForm.mbElementSet.delete(this);
      this.mbForm.triggerInput();
    }
    super.disconnectedCallback();
  }
  _label() {
    if (this.label)
      return html`<p style="font-weight: 600;">${this.label}</p>`;
    return void 0;
  }
};
__decorate([
  property({ type: String, reflect: true })
], EhrElement.prototype, "path", void 0);
__decorate([
  property({ type: String, reflect: true })
], EhrElement.prototype, "label", void 0);
__decorate([
  property({ type: String, reflect: true })
], EhrElement.prototype, "repeatprefix", void 0);
__decorate([
  property({ type: String, reflect: true })
], EhrElement.prototype, "repeatsuffix", void 0);
__decorate([
  property({ type: String, reflect: true })
], EhrElement.prototype, "variant", void 0);
__decorate([
  property({ type: Function })
], EhrElement.prototype, "handleSearch", void 0);
__decorate([
  property({ type: String, reflect: true })
], EhrElement.prototype, "datatype", void 0);
__decorate([
  event("mb-input")
], EhrElement.prototype, "_mbInput", void 0);
__decorate([
  event("mb-dependency")
], EhrElement.prototype, "_mbDependency", void 0);
__decorate([
  event("mb-path-change")
], EhrElement.prototype, "_pathChangeHandler", void 0);
__decorate([
  event("mb-connect")
], EhrElement.prototype, "_mbConnect", void 0);
__decorate([
  event("mb-disconnect")
], EhrElement.prototype, "_mbDisconnect", void 0);
__decorate([
  watch("path")
], EhrElement.prototype, "handlePathChange", null);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/context/context.js
var __decorate2 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbContext = class MbContext2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.data = void 0;
    this.bind = void 0;
    this.autocontext = true;
  }
  connectedCallback() {
    super.connectedCallback();
    setTimeout(() => {
      this._mbInput.emit();
    }, 50);
  }
};
MbContext.styles = css`
    :host {
      display: none;
    }
  `;
__decorate2([
  property({ type: Object })
], MbContext.prototype, "data", void 0);
__decorate2([
  property()
], MbContext.prototype, "bind", void 0);
__decorate2([
  event("mb-input")
], MbContext.prototype, "_mbInput", void 0);
__decorate2([
  property({ type: Boolean })
], MbContext.prototype, "autocontext", void 0);
MbContext = __decorate2([
  customElement("mb-context")
], MbContext);
var context_default = MbContext;

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/form/utils.js
var flatten = /* @__PURE__ */ function(isArray, wrapped) {
  function reduce(path, accumulator, table) {
    if (isArray(table)) {
      const { length } = table;
      if (length) {
        let index = 0;
        while (index < length) {
          const property2 = `${path}[${index}]`;
          const item = table[index++];
          if (wrapped(item) !== item)
            accumulator[property2] = item;
          else
            reduce(property2, accumulator, item);
        }
      } else
        accumulator[path] = table;
    } else {
      let empty = true;
      if (path) {
        Object.keys(table).forEach((property2) => {
          const item = table[property2];
          const newPath = `${path}.${property2}`;
          empty = false;
          if (wrapped(item) !== item)
            accumulator[newPath] = item;
          else
            reduce(newPath, accumulator, item);
        });
      } else {
        Object.keys(table).forEach((property2) => {
          const item = table[property2];
          empty = false;
          if (wrapped(item) !== item)
            accumulator[property2] = item;
          else
            reduce(property2, accumulator, item);
        });
      }
      if (empty)
        accumulator[path] = table;
    }
    return accumulator;
  }
  return function(table) {
    return reduce("", {}, table);
  };
}(Array.isArray, Object);
function unflatten(table) {
  const result = {};
  Object.keys(table).forEach((path) => {
    const { length } = path;
    let cursor = result;
    let property2 = "";
    let index = 0;
    while (index < length) {
      const char = path.charAt(index);
      if (char === "[") {
        cursor[property2] = cursor[property2] || [];
        cursor = cursor[property2];
        const start = index + 1;
        const end = path.indexOf("]", start);
        property2 = path.slice(start, end);
        index = end + 1;
      } else {
        cursor[property2] = cursor[property2] || {};
        cursor = cursor[property2];
        const start = char === "." ? index + 1 : index;
        const bracket = path.indexOf("[", start);
        const dot = path.indexOf(".", start);
        let end;
        if (bracket < 0 && dot < 0) {
          end = length;
          index = length;
        } else if (bracket < 0) {
          end = dot;
          index = dot;
        } else if (dot < 0) {
          end = bracket;
          index = bracket;
        } else {
          end = bracket < dot ? bracket : dot;
          index = bracket < dot ? bracket : dot;
        }
        property2 = path.slice(start, end);
      }
    }
    cursor[property2] = table[path];
  });
  return result[""];
}

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/form/plugins/openEHRFlat.js
function getIndexedPath({ i: i5, prefix, suffix, path }) {
  if (prefix && suffix) {
    return `${prefix}:${i5}/${suffix}`;
  }
  return `${path}:${i5}`;
}
function multipleSelectArray(value, path, flat, prefix, suffix) {
  value.forEach((val, i5) => {
    if (typeof val === "object") {
      Object.keys(val).forEach((item) => {
        if (prefix && suffix) {
          flat[`${getIndexedPath({ i: i5, prefix, suffix })}|${item}`] = val[item];
        } else {
          flat[`${getIndexedPath({ i: i5, path })}|${item}`] = val[item];
        }
      });
    } else {
      const key = prefix && suffix ? getIndexedPath({ i: i5, prefix, suffix }) : getIndexedPath({ i: i5, path });
      flat[key] = val;
    }
  });
}
function toFlat(data, mbElements) {
  const flat = {};
  Object.keys(data).forEach((path) => {
    if (path !== "") {
      const value = data[path];
      const ehrElement = mbElements[path];
      if (typeof value === "object") {
        if (Array.isArray(value)) {
          multipleSelectArray(value, path, flat, ehrElement === null || ehrElement === void 0 ? void 0 : ehrElement.repeatprefix, ehrElement === null || ehrElement === void 0 ? void 0 : ehrElement.repeatsuffix);
        } else {
          Object.keys(value).forEach((frag) => {
            const key = frag !== "_root" ? `${path}|${frag}` : path;
            flat[key] = value[frag];
          });
        }
      } else if (value !== "") {
        flat[path] = value;
      }
    }
  });
  return flat;
}
function fromFlat(flat) {
  const data = {};
  Object.keys(flat).forEach((path) => {
    const value = flat[path];
    const [subpath, frag] = path.split("|");
    if (frag) {
      if (data[subpath] && typeof data[subpath] !== "object") {
        data[subpath] = { _root: data[subpath] };
      }
      data[subpath] = Object.assign(Object.assign({}, data[subpath]), { [frag]: value });
    } else if (data[subpath]) {
      data[subpath] = Object.assign(Object.assign({}, data[subpath]), { _root: value });
    } else {
      data[subpath] = value;
    }
  });
  return data;
}
function formatPath(path) {
  return path.replace(/\//g, ".").replace(/\|/g, ".").replace(/:(\d)/g, (_2, number) => `[${number}]`);
}
function formatFlatComposition(flat) {
  const newComposition = {};
  Object.entries(flat).forEach(([path, value]) => {
    const formattedPath = formatPath(path);
    newComposition[formattedPath] = value;
  });
  return newComposition;
}
function unflattenComposition(flat, path) {
  if (!path) {
    return unflatten(formatFlatComposition(flat));
  }
  const newObject = {};
  const paths = Object.keys(flat).filter((p2) => p2.includes(path));
  paths.forEach((p2) => {
    const newPath = p2.replace(path, "");
    newObject[newPath] = flat[p2];
  });
  return unflatten(formatFlatComposition(newObject));
}
function toInsertContext(path, nonNullPaths, mbElements) {
  const segments = path.split("/");
  if (segments.length <= 2) {
    return true;
  }
  let previousPath;
  previousPath = segments.slice(0, -1).join("/");
  const previousSegment = segments[segments.length - 2];
  if (previousSegment === "context") {
    return true;
  }
  if (previousSegment === "ism_transition") {
    previousPath = segments.slice(0, -2).join("/");
  }
  const repeatableElementPaths = Object.keys(mbElements).filter((key) => {
    var _a2;
    return (_a2 = mbElements[key]) === null || _a2 === void 0 ? void 0 : _a2.multiple;
  }).flatMap((pathKey) => {
    const el = mbElements[pathKey];
    const data = el === null || el === void 0 ? void 0 : el.data;
    return data ? data.map((_2, i5) => getIndexedPath({
      prefix: el.repeatprefix,
      suffix: el.repeatsuffix,
      path: el.path,
      i: i5
    })) : [];
  });
  const nonNullIncludingRepeatable = [
    ...nonNullPaths,
    ...repeatableElementPaths
  ];
  if (nonNullIncludingRepeatable.some((p2) => p2.startsWith(previousPath))) {
    return true;
  }
  return false;
}
var openEHRFlatPlugin = {
  parse(mbElements, data) {
    const parsedData = fromFlat(data);
    const mbElementsWithMultiple = Object.keys(mbElements).filter((path) => {
      const element = mbElements[path];
      return element.multiple;
    });
    let pathWithMultiple = [];
    let dataWithMultiple = {};
    mbElementsWithMultiple.forEach((basePath2) => {
      const prefix = mbElements[basePath2].repeatprefix;
      const suffix = mbElements[basePath2].repeatsuffix;
      let elementsWithBasePath;
      if (prefix && suffix) {
        elementsWithBasePath = Object.keys(parsedData).filter((path) => path.split(":")[0] === prefix && path.endsWith(suffix));
      } else {
        elementsWithBasePath = Object.keys(parsedData).filter((path) => path.startsWith(basePath2));
      }
      const arrayOfValues = elementsWithBasePath.map((path) => parsedData[path]);
      dataWithMultiple = Object.assign(Object.assign({}, dataWithMultiple), { [basePath2]: arrayOfValues });
      pathWithMultiple = [...pathWithMultiple, ...elementsWithBasePath];
    });
    pathWithMultiple.forEach((path) => {
      delete parsedData[path];
    });
    return Object.assign(Object.assign({}, parsedData), dataWithMultiple);
  },
  serialize(mbElements) {
    const data = {};
    Object.entries(mbElements).forEach(([path, node]) => {
      if (path) {
        data[path] = node.data;
      }
    });
    return JSON.parse(JSON.stringify(toFlat(data, mbElements)));
  },
  getContext(path, ctx = {}, nonNullPaths, mbElements) {
    if (!toInsertContext(path, nonNullPaths, mbElements)) {
      return;
    }
    const parts2 = path.split("/");
    const contextId = parts2[parts2.length - 1];
    const context = mbElements[path];
    if (context.bind) {
      return context.bind;
    }
    if (ctx[contextId] != null) {
      return ctx[contextId];
    }
    switch (contextId) {
      case "start_time":
      case "time":
        return ctx.time || (/* @__PURE__ */ new Date()).toISOString();
      case "category":
        return {
          code: "433",
          value: "event",
          terminology: "openehr"
        };
      case "setting":
        return {
          code: "238",
          value: "other care",
          terminology: "openehr"
        };
      case "language":
        return {
          code: ctx.language || "en",
          terminology: "ISO_639-1"
        };
      case "territory":
        return {
          code: ctx.territory || "IN",
          terminology: "ISO_3166-1"
        };
      case "encoding":
        return {
          code: "UTF-8",
          terminology: "IANA_character-sets"
        };
      case "composer":
        if (ctx.composer_name) {
          return {
            name: ctx.composer_name
          };
        }
        return {
          name: "Medblocks UI"
        };
      case "_health_care_facility":
        return {
          name: ctx._health_care_facility || "Medblocks Hospital",
          id: ctx._health_care_facility_id || "Encounter ID",
          id_scheme: "Encounter",
          id_namespace: "FHIR"
        };
      default:
    }
  }
};

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/repeat/Repeatable.js
var __decorate3 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
function getRepeatableRegex(path) {
  return new RegExp(`(${path}):(\\d+)`, "g");
}
var Repeatable = class extends LitElement {
  constructor() {
    super(...arguments);
    this.isRepeatable = true;
    this.count = 0;
  }
  get regex() {
    return getRepeatableRegex(this.path);
  }
  connectedCallback() {
    super.connectedCallback();
    this._mbConnectRepeatable.emit({ detail: this.path });
  }
  handleCountChange(_2, newCount) {
    this._mbCount.emit({ detail: newCount });
  }
};
__decorate3([
  property({ type: Number, reflect: true })
], Repeatable.prototype, "count", void 0);
__decorate3([
  property({ type: String, reflect: true })
], Repeatable.prototype, "path", void 0);
__decorate3([
  event("mb-count")
], Repeatable.prototype, "_mbCount", void 0);
__decorate3([
  event("mb-connect-repeatable")
], Repeatable.prototype, "_mbConnectRepeatable", void 0);
__decorate3([
  watch("count")
], Repeatable.prototype, "handleCountChange", null);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/form/form.js
var __decorate4 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var __rest = function(s6, e6) {
  var t5 = {};
  for (var p2 in s6) if (Object.prototype.hasOwnProperty.call(s6, p2) && e6.indexOf(p2) < 0)
    t5[p2] = s6[p2];
  if (s6 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p2 = Object.getOwnPropertySymbols(s6); i5 < p2.length; i5++) {
      if (e6.indexOf(p2[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s6, p2[i5]))
        t5[p2[i5]] = s6[p2[i5]];
    }
  return t5;
};
var MedblockForm = class MedblockForm2 extends LitElement {
  constructor() {
    super(...arguments);
    this.overwritectx = false;
    this.novalidate = false;
    this.templateId = "";
    this.nosuggest = false;
    this.variant = "normal";
    this.plugin = openEHRFlatPlugin;
    this.serializeDeferredData = true;
    this.mbElementSet = /* @__PURE__ */ new Set();
    this.repeatables = {};
    this.updates = [];
    this.deferredData = {};
    this.suggestDomain = "*";
    this.triggerInputRequested = false;
    this.handleParentMessage = (e6) => {
      var _a2, _b;
      const message = e6 === null || e6 === void 0 ? void 0 : e6.data;
      if ((message === null || message === void 0 ? void 0 : message.type) === "mb-suggestion") {
        const suggestion = (_a2 = message === null || message === void 0 ? void 0 : message.data) === null || _a2 === void 0 ? void 0 : _a2.suggestion;
        const templateId = (_b = message === null || message === void 0 ? void 0 : message.data) === null || _b === void 0 ? void 0 : _b.templateId;
        if (suggestion && this.templateId === templateId) {
          this.addSuggestion(suggestion);
        }
      }
    };
  }
  handleVariantChange(_2, newVariant) {
    this.mbElementSet.forEach((el) => {
      if (!el.variant) {
        el.variant = newVariant;
      }
    });
  }
  handleSearchChange(_2, newHandleSearch) {
    this.mbElementSet.forEach((el) => {
      if (!el.handleSearch) {
        el.handleSearch = newHandleSearch;
      }
    });
  }
  get mbElements() {
    const result = {};
    this.mbElementSet.forEach((el) => {
      const { path } = el;
      result[path] = el;
    });
    return result;
  }
  validate() {
    if (this.novalidate) {
      return true;
    }
    const report = Object.values(this.mbElements).map((el) => el.reportValidity());
    return report.every((a4) => a4 === true);
  }
  parse(data) {
    return this.plugin.parse(this.mbElements, data);
  }
  serialize(mbElements = this.mbElements) {
    const toSerialize = this.serializeDeferredData ? Object.assign(Object.assign({}, mbElements), this.dataToContextElements(this.deferredData)) : mbElements;
    const filteredObject = {};
    Object.keys(toSerialize).forEach((key) => {
      if (this.hasValue(toSerialize[key].data))
        filteredObject[key] = toSerialize[key];
    });
    return this.plugin.serialize(filteredObject);
  }
  dataToContextElements(data) {
    const result = {};
    Object.keys(data).forEach((key) => {
      const context = new context_default();
      context.data = data[key];
      result[key] = context;
    });
    return result;
  }
  import(data) {
    this.data = this.parse(data);
  }
  export(validate = false) {
    if (validate)
      this.validate();
    this.insertContext();
    return this.serialize();
  }
  clear() {
    this.data = this.parse({});
  }
  getStructured(flat, path) {
    return unflattenComposition(flat, path);
  }
  async handleSubmit() {
    if (this.validate()) {
      this.insertContext();
      await 0;
      const data = this.serialize();
      this.submit.emit({ detail: data, cancelable: true });
      this.sendWebMessage(true);
    }
  }
  hasValue(value) {
    if (Array.isArray(value)) {
      return value.length > 0;
    }
    if (value && Object.getPrototypeOf(value) === Object.prototype) {
      return Object.keys(value).length > 0;
    }
    if (value === "") {
      return false;
    }
    return value != null;
  }
  isContextElement(element) {
    return (element === null || element === void 0 ? void 0 : element.autocontext) != null;
  }
  nonEmptyPaths() {
    return Object.keys(this.mbElements).filter((k2) => this.hasValue(this.mbElements[k2].data) && !this.isContextElement(this.mbElements[k2]));
  }
  nonContextPaths() {
    return Object.keys(this.mbElements).filter((k2) => {
      var _a2;
      return ((_a2 = this.mbElements[k2]) === null || _a2 === void 0 ? void 0 : _a2.autocontext) == null;
    });
  }
  insertContext() {
    const nonNullPaths = this.nonEmptyPaths();
    Object.values(this.mbElements).filter((element) => !!element.autocontext).forEach((element) => {
      var _a2;
      const { path } = element;
      const valueToInsert = this.plugin.getContext(path, this.ctx, nonNullPaths, this.mbElements);
      if (valueToInsert != null) {
        const contextData = this.overwritectx ? this.plugin.getContext(path, this.ctx, nonNullPaths, this.mbElements) : (_a2 = element.data) !== null && _a2 !== void 0 ? _a2 : this.plugin.getContext(path, this.ctx, nonNullPaths, this.mbElements);
        element.data = contextData;
      } else {
        element.data = void 0;
      }
    });
  }
  async ensureContextsRegistered() {
    await new Promise((resolve) => setTimeout(resolve, 0));
    const contexts = Array.from(this.querySelectorAll("mb-context"));
    contexts.forEach((context) => {
      const path = context.getAttribute("path");
      if (path && !this.mbElements[path]) {
        this.mbElementSet.add(context);
      }
    });
  }
  get submitButton() {
    return this.querySelector("mb-submit");
  }
  get data() {
    const newValue = {};
    Object.entries(this.mbElements).forEach(([path, node]) => {
      newValue[path] = node.data;
    });
    return newValue;
  }
  getCount(pathString, data) {
    let regex;
    if (typeof pathString === "string") {
      regex = getRepeatableRegex(pathString);
    } else {
      regex = pathString;
    }
    const keys = Object.keys(data);
    const matches = keys.map((path) => {
      const match = regex.exec(path);
      regex.lastIndex = 0;
      return match;
    }).map((match) => match === null || match === void 0 ? void 0 : match[2]).filter((match) => match).map((str) => str && parseInt(str, 10));
    if (matches.length === 0) {
      return 0;
    }
    const count2 = Math.max(...matches) + 1;
    return count2;
  }
  set data(data) {
    this.deferredData = {};
    const { mbElements } = this;
    const mbElementPaths = Object.keys(mbElements);
    Object.values(this.repeatables).forEach((el) => {
      const { regex } = el;
      el.count = this.getCount(regex, data);
    });
    mbElementPaths.forEach((path) => {
      const element = mbElements[path];
      const value = data[path];
      element.data = value;
    });
    const inDataButNotElements = Object.keys(data).filter((path) => !mbElementPaths.includes(path));
    if (inDataButNotElements.length > 0) {
      const object = Object.fromEntries(inDataButNotElements.map((key) => [key, data[key]]));
      this.deferredData = Object.assign(Object.assign({}, this.deferredData), object);
    }
    this.sendWebMessage();
  }
  sendWebMessage(postSubmit = false, data = this.data) {
    if (window.top && !this.nosuggest) {
      const message = {
        type: "mb-input",
        data: {
          composition: data,
          templateId: this.templateId,
          format: "MB-FLAT",
          postSubmit
        }
      };
      window.top.postMessage(message, this.suggestDomain);
    }
  }
  handleInput(e6) {
    e6.stopPropagation();
    this.triggerInput();
  }
  async triggerInput() {
    if (!this.triggerInputRequested) {
      this.triggerInputRequested = true;
      this.triggerInputRequested = await false;
      this._input.emit();
      this.sendWebMessage();
    }
  }
  handleSlotChange() {
    this.triggerInput();
  }
  getTarget(e6) {
    return e6.composedPath()[0];
  }
  handleChildConnect(e6) {
    const path = e6.detail;
    const element = this.getTarget(e6);
    element.mbForm = this;
    element.variant = this.variant;
    this.mbElementSet.add(element);
    if (this.deferredData[path] != null) {
      const _a2 = this.deferredData, _b = path, data = _a2[_b], excluded = __rest(_a2, [typeof _b === "symbol" ? _b : _b + ""]);
      this.mbElements[path].data = data;
      this.deferredData = excluded;
    }
    this.triggerInput();
  }
  handleRepeatableConnect(e6) {
    const path = e6.detail;
    this.repeatables[path] = this.getTarget(e6);
    this.triggerInput();
  }
  handleChildDisconnect(e6) {
    this.mbElementSet.delete(e6.detail.target);
    this.triggerInput();
  }
  handleChildPathChange(_2) {
    this.triggerInput();
  }
  addSuggestion(data) {
    const suggestElements = Object.keys(data).map((key) => {
      var _a2;
      return {
        key,
        suggest: (_a2 = this.mbElements[key]) === null || _a2 === void 0 ? void 0 : _a2.parentElement
      };
    }).filter(({ suggest }) => (suggest === null || suggest === void 0 ? void 0 : suggest.nodeName) === "MB-SUGGEST");
    suggestElements.forEach(({ key, suggest }) => {
      const suggestions = data[key];
      suggest.suggestions = suggestions;
      suggest.path = key;
    });
    const hideElements = this.querySelectorAll("mb-hide");
    hideElements.forEach((el) => {
      if (data[el.path]) {
        el.show = true;
      } else {
        el.show = false;
      }
    });
    const globalSuggests = this.querySelectorAll("mb-suggest[global]");
    globalSuggests.forEach((el) => {
      const suggestion = data[el.path];
      if (suggestion) {
        el.suggestions = suggestion;
      }
    });
  }
  handleSuggestion(e6) {
    const { suggestion, path, global } = e6.detail;
    if (global) {
      this.import(suggestion.data);
      return;
    }
    const element = this.mbElements[path];
    if (element) {
      const oldData = element.data;
      if (suggestion.op === "replace") {
        element.data = suggestion.data;
      } else if (suggestion.op === "add") {
        if (Array.isArray(element.data)) {
          element.data = [...oldData, suggestion.data];
        } else if (element.data == null) {
          element.data = [suggestion.data];
        } else {
          element.data = suggestion.data;
        }
      } else {
        element.data = suggestion.data;
      }
    }
    this.triggerInput();
  }
  handleTodos() {
    this.triggerInput();
    this.updates.forEach((todo) => todo.bind(this));
    this.updates = [];
  }
  async connectedCallback() {
    super.connectedCallback();
    if (Object.keys(this.deferredData).length > 0) {
      const contextElements = this.dataToContextElements(this.deferredData);
      Object.entries(contextElements).forEach(([path, element]) => {
        console.log("Registering context:", path);
        this.mbElementSet.add(element);
      });
    }
    this.addEventListener("mb-connect", this.handleChildConnect);
    this.addEventListener("mb-connect-repeatable", this.handleRepeatableConnect);
    this.addEventListener("mb-disconnect", this.handleChildDisconnect);
    this.addEventListener("mb-path-change", this.handleChildPathChange);
    this.addEventListener("mb-suggestion", this.handleSuggestion);
    if (window.top && !this.nosuggest) {
      window.addEventListener("message", this.handleParentMessage);
    }
    await this.ensureContextsRegistered();
    this.load.emit();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("mb-connect", this.handleChildConnect);
    this.removeEventListener("mb-connect-repeatable", this.handleRepeatableConnect);
    this.removeEventListener("mb-disconnect", this.handleChildDisconnect);
    this.removeEventListener("mb-path-change", this.handleChildPathChange);
    this.removeEventListener("mb-suggestion", this.handleSuggestion);
    if (window.top && !this.nosuggest) {
      window.removeEventListener("message", this.handleParentMessage);
    }
    this.sendWebMessage(false, {});
  }
  render() {
    return html`<slot
      @slotchange=${this.handleSlotChange}
      @mb-input=${this.handleInput}
      @mb-trigger-submit=${this.handleSubmit}
    ></slot>`;
  }
};
MedblockForm.styles = css`
    :host {
      display: block;
    }
  `;
__decorate4([
  property({ type: Object })
], MedblockForm.prototype, "ctx", void 0);
__decorate4([
  property({ type: Boolean, reflect: true })
], MedblockForm.prototype, "overwritectx", void 0);
__decorate4([
  property({ type: Boolean, reflect: true })
], MedblockForm.prototype, "novalidate", void 0);
__decorate4([
  property({ type: String, reflect: true })
], MedblockForm.prototype, "templateId", void 0);
__decorate4([
  property({ type: Boolean, reflect: true })
], MedblockForm.prototype, "nosuggest", void 0);
__decorate4([
  property({ type: String, reflect: true })
], MedblockForm.prototype, "variant", void 0);
__decorate4([
  property({ type: Function })
], MedblockForm.prototype, "handleSearch", void 0);
__decorate4([
  watch("variant")
], MedblockForm.prototype, "handleVariantChange", null);
__decorate4([
  watch("handleSearch")
], MedblockForm.prototype, "handleSearchChange", null);
__decorate4([
  event("mb-input")
], MedblockForm.prototype, "_input", void 0);
__decorate4([
  event("mb-load")
], MedblockForm.prototype, "load", void 0);
__decorate4([
  property({ type: Object })
], MedblockForm.prototype, "plugin", void 0);
__decorate4([
  property({ type: Boolean, reflect: true })
], MedblockForm.prototype, "serializeDeferredData", void 0);
__decorate4([
  state()
], MedblockForm.prototype, "mbElementSet", void 0);
__decorate4([
  state()
], MedblockForm.prototype, "repeatables", void 0);
__decorate4([
  state()
], MedblockForm.prototype, "updates", void 0);
__decorate4([
  event("mb-submit")
], MedblockForm.prototype, "submit", void 0);
__decorate4([
  state()
], MedblockForm.prototype, "deferredData", void 0);
__decorate4([
  property({ type: String, reflect: true })
], MedblockForm.prototype, "suggestDomain", void 0);
__decorate4([
  state()
], MedblockForm.prototype, "observer", void 0);
__decorate4([
  state()
], MedblockForm.prototype, "intervalId", void 0);
MedblockForm = __decorate4([
  customElement("mb-form")
], MedblockForm);
var form_default = MedblockForm;

// node_modules/.pnpm/query-selector-shadow-dom@1.0.1/node_modules/query-selector-shadow-dom/src/normalize.js
function normalizeSelector(sel) {
  function saveUnmatched() {
    if (unmatched) {
      if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {
        tokens.push(" ");
      }
      tokens.push(unmatched);
    }
  }
  var tokens = [], match, unmatched, regex, state2 = [0], next_match_idx = 0, prev_match_idx, not_escaped_pattern = /(?:[^\\]|(?:^|[^\\])(?:\\\\)+)$/, whitespace_pattern = /^\s+$/, state_patterns = [
    /\s+|\/\*|["'>~+[(]/g,
    // general
    /\s+|\/\*|["'[\]()]/g,
    // [..] set
    /\s+|\/\*|["'[\]()]/g,
    // (..) set
    null,
    // string literal (placeholder)
    /\*\//g
    // comment
  ];
  sel = sel.trim();
  while (true) {
    unmatched = "";
    regex = state_patterns[state2[state2.length - 1]];
    regex.lastIndex = next_match_idx;
    match = regex.exec(sel);
    if (match) {
      prev_match_idx = next_match_idx;
      next_match_idx = regex.lastIndex;
      if (prev_match_idx < next_match_idx - match[0].length) {
        unmatched = sel.substring(
          prev_match_idx,
          next_match_idx - match[0].length
        );
      }
      if (state2[state2.length - 1] < 3) {
        saveUnmatched();
        if (match[0] === "[") {
          state2.push(1);
        } else if (match[0] === "(") {
          state2.push(2);
        } else if (/^["']$/.test(match[0])) {
          state2.push(3);
          state_patterns[3] = new RegExp(match[0], "g");
        } else if (match[0] === "/*") {
          state2.push(4);
        } else if (/^[\])]$/.test(match[0]) && state2.length > 0) {
          state2.pop();
        } else if (/^(?:\s+|[~+>])$/.test(match[0])) {
          if (tokens.length > 0 && !whitespace_pattern.test(tokens[tokens.length - 1]) && state2[state2.length - 1] === 0) {
            tokens.push(" ");
          }
          if (state2[state2.length - 1] === 1 && tokens.length === 5 && tokens[2].charAt(tokens[2].length - 1) === "=") {
            tokens[4] = " " + tokens[4];
          }
          if (whitespace_pattern.test(match[0])) {
            continue;
          }
        }
        tokens.push(match[0]);
      } else {
        tokens[tokens.length - 1] += unmatched;
        if (not_escaped_pattern.test(tokens[tokens.length - 1])) {
          if (state2[state2.length - 1] === 4) {
            if (tokens.length < 2 || whitespace_pattern.test(tokens[tokens.length - 2])) {
              tokens.pop();
            } else {
              tokens[tokens.length - 1] = " ";
            }
            match[0] = "";
          }
          state2.pop();
        }
        tokens[tokens.length - 1] += match[0];
      }
    } else {
      unmatched = sel.substr(next_match_idx);
      saveUnmatched();
      break;
    }
  }
  return tokens.join("").trim();
}

// node_modules/.pnpm/query-selector-shadow-dom@1.0.1/node_modules/query-selector-shadow-dom/src/querySelectorDeep.js
function querySelectorAllDeep(selector, root = document, allElements = null) {
  return _querySelectorDeep(selector, true, root, allElements);
}
function querySelectorDeep(selector, root = document, allElements = null) {
  return _querySelectorDeep(selector, false, root, allElements);
}
function _querySelectorDeep(selector, findMany, root, allElements = null) {
  selector = normalizeSelector(selector);
  let lightElement = root.querySelector(selector);
  if (document.head.createShadowRoot || document.head.attachShadow) {
    if (!findMany && lightElement) {
      return lightElement;
    }
    const selectionsToMake = splitByCharacterUnlessQuoted(selector, ",");
    return selectionsToMake.reduce((acc, minimalSelector) => {
      if (!findMany && acc) {
        return acc;
      }
      const splitSelector = splitByCharacterUnlessQuoted(minimalSelector.replace(/^\s+/g, "").replace(/\s*([>+~]+)\s*/g, "$1"), " ").filter((entry) => !!entry).map((entry) => splitByCharacterUnlessQuoted(entry, ">"));
      const possibleElementsIndex = splitSelector.length - 1;
      const lastSplitPart = splitSelector[possibleElementsIndex][splitSelector[possibleElementsIndex].length - 1];
      const possibleElements = collectAllElementsDeep(lastSplitPart, root, allElements);
      const findElements = findMatchingElement(splitSelector, possibleElementsIndex, root);
      if (findMany) {
        acc = acc.concat(possibleElements.filter(findElements));
        return acc;
      } else {
        acc = possibleElements.find(findElements);
        return acc || null;
      }
    }, findMany ? [] : null);
  } else {
    if (!findMany) {
      return lightElement;
    } else {
      return root.querySelectorAll(selector);
    }
  }
}
function findMatchingElement(splitSelector, possibleElementsIndex, root) {
  return (element) => {
    let position = possibleElementsIndex;
    let parent = element;
    let foundElement = false;
    while (parent && !isDocumentNode(parent)) {
      let foundMatch = true;
      if (splitSelector[position].length === 1) {
        foundMatch = parent.matches(splitSelector[position]);
      } else {
        const reversedParts = [].concat(splitSelector[position]).reverse();
        let newParent = parent;
        for (const part of reversedParts) {
          if (!newParent || !newParent.matches(part)) {
            foundMatch = false;
            break;
          }
          newParent = findParentOrHost(newParent, root);
        }
      }
      if (foundMatch && position === 0) {
        foundElement = true;
        break;
      }
      if (foundMatch) {
        position--;
      }
      parent = findParentOrHost(parent, root);
    }
    return foundElement;
  };
}
function splitByCharacterUnlessQuoted(selector, character) {
  return selector.match(/\\?.|^$/g).reduce((p2, c2) => {
    if (c2 === '"' && !p2.sQuote) {
      p2.quote ^= 1;
      p2.a[p2.a.length - 1] += c2;
    } else if (c2 === "'" && !p2.quote) {
      p2.sQuote ^= 1;
      p2.a[p2.a.length - 1] += c2;
    } else if (!p2.quote && !p2.sQuote && c2 === character) {
      p2.a.push("");
    } else {
      p2.a[p2.a.length - 1] += c2;
    }
    return p2;
  }, { a: [""] }).a;
}
function isDocumentNode(node) {
  return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;
}
function findParentOrHost(element, root) {
  const parentNode = element.parentNode;
  return parentNode && parentNode.host && parentNode.nodeType === 11 ? parentNode.host : parentNode === root ? null : parentNode;
}
function collectAllElementsDeep(selector = null, root, cachedElements = null) {
  let allElements = [];
  if (cachedElements) {
    allElements = cachedElements;
  } else {
    const findAllElements = function(nodes) {
      for (let i5 = 0; i5 < nodes.length; i5++) {
        const el = nodes[i5];
        allElements.push(el);
        if (el.shadowRoot) {
          findAllElements(el.shadowRoot.querySelectorAll("*"));
        }
      }
    };
    if (root.shadowRoot) {
      findAllElements(root.shadowRoot.querySelectorAll("*"));
    }
    findAllElements(root.querySelectorAll("*"));
  }
  return selector ? allElements.filter((el) => el.matches(selector)) : allElements;
}

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/extension/transform.js
var transformations = {
  DV_QUANTITY: (n6) => {
    var _a2, _b, _c, _d;
    return [
      {
        name: "Quantity",
        html: `<mb-quantity default="${((_d = (_c = (_b = (_a2 = n6 === null || n6 === void 0 ? void 0 : n6.inputs) === null || _a2 === void 0 ? void 0 : _a2[1]) === null || _b === void 0 ? void 0 : _b.list) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.value) || ""}" path="${n6.path}" label="${n6.name}">
                  ${n6.inputs && n6.inputs[1] && n6.inputs[1].list ? n6.inputs[1].list.map((unit) => {
          var _a3, _b2, _c2, _d2;
          return `<mb-unit unit="${unit === null || unit === void 0 ? void 0 : unit.value}" label="${(unit === null || unit === void 0 ? void 0 : unit.label) || ""}" min="${((_b2 = (_a3 = unit === null || unit === void 0 ? void 0 : unit.validation) === null || _a3 === void 0 ? void 0 : _a3.range) === null || _b2 === void 0 ? void 0 : _b2.min) || ""}" max="${((_d2 = (_c2 = unit === null || unit === void 0 ? void 0 : unit.validation) === null || _c2 === void 0 ? void 0 : _c2.range) === null || _d2 === void 0 ? void 0 : _d2.max) || ""}"></mb-unit>`;
        }).join("\n") : ""}
              </mb-quantity>`
      }
    ];
  },
  DV_CODED_TEXT: (n6) => {
    var _a2, _b;
    let templates;
    if (n6.max === -1) {
      templates = [
        {
          name: "Select-Multiple",
          html: `<mb-select multiple path="${n6.path.slice(0, n6.path.length - 2)}" label="${n6.name || ""}" terminology="${n6.inputs[0].terminology || "local"}">
              ${n6.inputs && n6.inputs[0] && n6.inputs[0].list ? n6.inputs[0].list.map((option) => `<mb-option value="${option.value}" label="${option.label}"></mb-option>`).join("\n") : ""}
            </mb-select>`
        },
        {
          name: "Buttons-Multiple",
          html: `<mb-buttons-multiple path="${n6.path.slice(0, n6.path.length - 2)}" label="${n6.name || ""}" terminology="${n6.inputs[0].terminology || "local"}">
        ${n6.inputs && n6.inputs[0] && n6.inputs[0].list ? n6.inputs[0].list.map((option) => `<mb-option value="${option.value}" label="${option.label}"></mb-option>`).join("\n") : ""}
        </mb-buttons-multiple>`
        },
        {
          name: "Search-Multiple",
          html: `<mb-search-multiple disablefallback path="${n6.path.slice(0, n6.path.length - 2)}" label="${n6.name || ""}" terminology="${n6.inputs[0].terminology || ((_a2 = n6 === null || n6 === void 0 ? void 0 : n6.annotations) === null || _a2 === void 0 ? void 0 : _a2.MB_VALUESET) || "local"}">
        </mb-search-multiple>`
        }
      ];
    } else {
      templates = [
        {
          name: "Select",
          html: `<mb-select path="${n6.path}" label="${n6.name || ""}" terminology="${n6.inputs[0].terminology || "local"}">
              ${n6.inputs && n6.inputs[0] && n6.inputs[0].list ? n6.inputs[0].list.map((option) => `<mb-option value="${option.value}" label="${option.label}"></mb-option>`).join("\n") : ""}
            </mb-select>`
        },
        {
          name: "Buttons",
          html: `<mb-buttons path="${n6.path}" label="${n6.name || ""}" terminology="${n6.inputs[0].terminology || "local"}">
        ${n6.inputs && n6.inputs[0] && n6.inputs[0].list ? n6.inputs[0].list.map((option) => `<mb-option value="${option.value}" label="${option.label}"></mb-option>`).join("\n") : ""}
        </mb-buttons>`
        },
        {
          name: "Search",
          html: `<mb-search disablefallback path="${n6.path}" label="${n6.name || ""}" terminology="${n6.inputs[0].terminology || ((_b = n6 === null || n6 === void 0 ? void 0 : n6.annotations) === null || _b === void 0 ? void 0 : _b.MB_VALUESET) || "local"}">
        </mb-search>`
        }
      ];
    }
    return templates;
  },
  DV_COUNT: (n6) => [
    {
      name: "Count",
      html: `<mb-count path="${n6.path}" label="${n6.name || ""}"
      min="${n6.min}" max="${n6.max}"></mb-count>`
    }
  ],
  DV_PROPORTION: (n6) => {
    var _a2, _b;
    return [
      ...((_a2 = n6.proportionTypes) === null || _a2 === void 0 ? void 0 : _a2.some((props) => props === "percent")) ? [
        {
          name: "Percent",
          html: `<mb-proportion path="${n6.path}" label="${n6.name || ""}" min="0" max="100" step="1" type="percent"></mb-proportion>`
        }
      ] : [],
      ...((_b = n6.proportionTypes) === null || _b === void 0 ? void 0 : _b.some((props) => props === "unitary")) ? [
        {
          name: "Unitary",
          html: `<mb-proportion path="${n6.path}" label="${n6.name || ""}" min="0" max="1" step="0.01"></mb-proportion>`
        }
      ] : []
    ];
  },
  DV_TEXT: (n6) => {
    var _a2, _b, _c, _d;
    let templates;
    if (n6.max === -1) {
      templates = [
        ...((_a2 = n6 === null || n6 === void 0 ? void 0 : n6.annotations) === null || _a2 === void 0 ? void 0 : _a2.MB_VALUESET) ? [
          {
            name: "Search-Multiple",
            html: `<mb-search-multiple path="${n6.path.slice(0, n6.path.length - 2)}" label="${n6.name || ""}" terminology="${(_b = n6 === null || n6 === void 0 ? void 0 : n6.annotations) === null || _b === void 0 ? void 0 : _b.MB_VALUESET}">
                </mb-search-multiple>`
          }
        ] : [],
        {
          name: "Input-Multiple",
          html: `<mb-input-multiple path="${n6.path.slice(0, n6.path.length - 2)}" label="${n6.name || ""}"></mb-input-multiple>`
        },
        {
          name: "Text-Select-Multiple",
          html: `<mb-text-select multiple path="${n6.path.slice(0, n6.path.length - 2)}" label="${n6.name || ""}">
          ${n6.inputs && n6.inputs[0] && n6.inputs[0].list ? n6.inputs[0].list.map((option) => `<mb-option value="${option.value}" label="${option.label}"></mb-option>`).join("\n") : ""}
        </mb-text-select>`
        }
      ];
    } else {
      templates = [
        ...((_c = n6 === null || n6 === void 0 ? void 0 : n6.annotations) === null || _c === void 0 ? void 0 : _c.MB_VALUESET) ? [
          {
            name: "Search",
            html: `<mb-search path="${n6.path}" label="${n6.name || ""}" terminology="${(_d = n6 === null || n6 === void 0 ? void 0 : n6.annotations) === null || _d === void 0 ? void 0 : _d.MB_VALUESET}">
            </mb-search>`
          }
        ] : [],
        {
          name: "Input",
          html: `<mb-input path="${n6.path}" label="${n6.name || ""}"></mb-input>`
        },
        {
          name: "Textarea",
          html: `<mb-input textarea path="${n6.path}" label="${n6.name || ""}"></mb-input>`
        },
        {
          name: "Text-Select",
          html: `<mb-text-select path="${n6.path}" label="${n6.name || ""}">
              ${n6.inputs && n6.inputs[0] && n6.inputs[0].list ? n6.inputs[0].list.map((option) => `<mb-option value="${option.value}" label="${option.label}"></mb-option>`).join("\n") : ""}
            </mb-text-select>`
        }
      ];
    }
    return templates;
  },
  DV_DURATION: (n6) => {
    const suffixes = [];
    n6.inputs.forEach((input) => {
      if (input.suffix) {
        suffixes.push(input.suffix);
      }
    });
    return [
      {
        name: "Duration",
        html: `<mb-duration ${suffixes.join(" ")} path="${n6.path}" label="${n6.name || ""}"></mb-duration>`
      }
    ];
  },
  DV_DATE_TIME: (n6) => [
    {
      name: "Date & Time",
      html: `<mb-date time path="${n6.path}" label="${n6.name || ""}"></mb-date>`
    },
    {
      name: "Date",
      html: `<mb-date dvdatetime path="${n6.path}" label="${n6.name || ""}"></mb-date>`
    }
  ],
  DV_DATE: (n6) => [
    {
      name: "Date",
      html: `<mb-date path="${n6.path}" label="${n6.name || ""}"></mb-date>`
    }
  ],
  DV_BOOLEAN: (n6) => [
    {
      name: "Boolean",
      html: `<mb-checkbox path="${n6.path}" label="${n6.name || ""}"></mb-checkbox>`
    }
  ],
  DV_MULTIMEDIA: (n6) => [
    {
      name: "Multimedia",
      html: `<mb-multimedia path="${n6.path}" label="${n6.name || ""}"></mb-multimedia>`
    }
  ],
  DV_ORDINAL: (n6) => [
    {
      name: "Ordinal",
      html: `<mb-select path="${n6.path}" label="${n6.name || ""}" terminology="${n6.inputs[0].terminology}">
        ${n6.inputs && n6.inputs[0] && n6.inputs[0].list ? n6.inputs[0].list.map((option) => `<mb-option value="${option.value}" label="${option.label}" ordinal="${option.ordinal}" ></mb-option>`).join("\n") : ""}</mb-select>`
    },
    {
      name: "Buttons",
      html: `<mb-buttons path="${n6.path}" label="${n6.name || ""}">
        ${n6.inputs && n6.inputs[0] && n6.inputs[0].list ? n6.inputs[0].list.map((option) => `<mb-option value="${option.value}" label="${option.label}" ordinal="${option.ordinal}"></mb-option>`).join("\n") : ""}
        </mb-buttons>`
    }
  ],
  context: (n6) => [
    { name: "Context", html: `<mb-context path="${n6.path}"></mb-context>` }
  ]
};
var transform_default = (leaf) => {
  if (leaf.inContext) {
    return transformations.context(leaf);
  }
  const fn = transformations[leaf.rmType];
  if (fn) {
    const nodes = fn(leaf);
    return nodes;
  }
  return [];
};

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/utils.js
var count = (composition, path, initialCount = 1) => {
  if (!composition)
    return initialCount;
  const pattern = new RegExp(`${path}:(\\d)+`, "g");
  const arrayOfPaths = Object.keys(composition).filter((key) => key.match(pattern));
  if (arrayOfPaths.length > 0) {
    const fieldCount = pattern.exec(arrayOfPaths[arrayOfPaths.length - 1]);
    return parseInt(fieldCount[1], 10) + 1;
  }
  return initialCount;
};

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/form/autoform-utils.js
var storageAPI = {
  upload: async ({ file, axios }) => {
    const form = new FormData();
    form.append("file", file);
    form.append("key", `${Date.now()}-${encodeURIComponent(file.name)}`);
    form.append("type", file.type);
    const response = await axios.post("/api/s3", form, {
      headers: {
        "Content-Type": "multipart/form-data"
      }
    });
    const key = response.data.hashName;
    return key;
  },
  download: async ({ axios, key }) => {
    const response = await axios.get(`/api/s3?object=${key}`);
    return response.data;
  }
};
var storageApiPlugin = {
  storageAPI
};
function handleMediaPlugin(element) {
  element.base64 = true;
  element.plugin = storageApiPlugin;
}
var healthCareFacilityContextNode = {
  id: "_health_care_facility",
  name: "_health_care_facility",
  rmType: "PARTY_PROXY",
  min: 1,
  max: 1,
  aqlPath: "/_health_care_facility",
  inputs: [
    {
      suffix: "id",
      type: "TEXT"
    },
    {
      suffix: "id_scheme",
      type: "TEXT"
    },
    {
      suffix: "id_namespace",
      type: "TEXT"
    },
    {
      suffix: "name",
      type: "TEXT"
    },
    {
      suffix: "function",
      type: "TEXT"
    },
    {
      suffix: "mode",
      type: "TEXT"
    }
  ],
  inContext: true
};
var participationContextNode = {
  id: "_participation",
  name: "_participation",
  rmType: "PARTY_PROXY",
  min: 1,
  max: 1,
  aqlPath: "/_participation",
  inputs: [
    {
      suffix: "id",
      type: "TEXT"
    },
    {
      suffix: "id_scheme",
      type: "TEXT"
    },
    {
      suffix: "id_namespace",
      type: "TEXT"
    },
    {
      suffix: "name",
      type: "TEXT"
    }
  ],
  inContext: true
};
function removeNElementsFromArray(arr, n6) {
  arr.splice(0, n6);
  return arr;
}
function encodeText(value) {
  const lt = /</g;
  const gt = />/g;
  const ap = /'/g;
  const ic = /"/g;
  const val = value === null || value === void 0 ? void 0 : value.toString().replace(lt, "&lt;").replace(gt, "&gt;").replace(ap, "&#39;").replace(ic, "&#34;");
  return val;
}
function stripIndex(string) {
  const id = string === null || string === void 0 ? void 0 : string.split(":");
  id.pop();
  const elementId = id.join(":");
  return elementId;
}
var getDepthClass = (depth) => {
  const baseClasses = "p-depth";
  switch (depth) {
    case 0:
      return `${baseClasses} bg-slate-700`;
    case 1:
      return `${baseClasses} bg-slate-600`;
    case 2:
      return `${baseClasses} bg-slate-500`;
    default:
      return `${baseClasses} bg-slate-400`;
  }
};
function generateNewId(currentId, baseIdPath) {
  const baseIdArray = baseIdPath.split("/").filter((a4) => a4);
  const relativeIdArray = removeNElementsFromArray(currentId.split("/"), baseIdArray.length);
  return [...baseIdArray, ...relativeIdArray].join("/");
}
function createRepeatableElement(path) {
  return `<mb-repeatable-headless path=${stripIndex(path)} count="1" />`;
}
function createContextElement(path) {
  return `<mb-context path=${path} />`;
}
function getDefaultTransform(node, index = 0) {
  var _a2;
  const results = transform_default(node);
  return (_a2 = results[index]) === null || _a2 === void 0 ? void 0 : _a2.html;
}
function prepareClonedDiv(divId, newId) {
  const referenceId = divId.replace(/:\d+/g, ":0").replace(/([!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~])/g, "\\$1");
  const referenceDiv = querySelectorAllDeep(`#${referenceId}`)[0] || null;
  const cloneDiv = referenceDiv.cloneNode(true);
  cloneDiv.classList.remove("hidden", "reference");
  cloneDiv.id = newId;
  return cloneDiv;
}
function isMultipleInput(element) {
  return element.tagName === "MB-INPUT-MULTIPLE" || element.tagName === "TEXT-SELECT-MULTIPLE";
}
function updateElementPath(element, newId) {
  if (element.isMbElement || element.isRepeatable) {
    element.path = isMultipleInput(element) ? newId.slice(0, -2) : newId;
  }
}
function handlePlugins(element) {
  const plugins = {
    "MB-MULTIMEDIA": () => handleMediaPlugin(element)
  };
  const handler = plugins[element.tagName];
  if (handler)
    handler();
}
function setupButtons(cloneDiv, originalDiv, handleSearch, config) {
  var _a2;
  const addButtons = cloneDiv.querySelectorAll(".addButton");
  for (const buttons of addButtons) {
    const parentNode = (_a2 = buttons === null || buttons === void 0 ? void 0 : buttons.parentNode) === null || _a2 === void 0 ? void 0 : _a2.parentNode;
    addButtonEventListener(buttons, parentNode, handleSearch, config);
  }
  const deleteButtons = cloneDiv === null || cloneDiv === void 0 ? void 0 : cloneDiv.querySelectorAll(".deleteButton");
  const targetDeleteButton = deleteButtons[deleteButtons.length - 1];
  targetDeleteButton.classList.remove("hidden");
  deleteButtonEventListener(targetDeleteButton);
  const currentDivButtons = originalDiv === null || originalDiv === void 0 ? void 0 : originalDiv.querySelectorAll(".divButton");
  const targetDivButton = currentDivButtons[currentDivButtons.length - 1];
  targetDivButton.classList.add("hidden");
}
function processChildDiv(childDiv, baseIdPath, handleSearch) {
  childDiv.classList.remove("reference", "hidden");
  const newId = generateNewId(childDiv.id, baseIdPath);
  childDiv.id = newId;
  const firstChild = childDiv.children[0];
  if (firstChild) {
    updateElementPath(firstChild, newId);
    if ((firstChild === null || firstChild === void 0 ? void 0 : firstChild.tagName) === "MB-SEARCH" || (firstChild === null || firstChild === void 0 ? void 0 : firstChild.tagName) === "MB-SEARCH-MULTIPLE") {
      firstChild.handleSearch = handleSearch;
    }
    handlePlugins(firstChild);
  }
}
function processChildElements(cloneDiv, baseId, handleSearch) {
  const childDivs = cloneDiv.querySelectorAll("div");
  const baseIdPath = `${baseId}/`;
  for (const childDiv of childDivs) {
    processChildDiv(childDiv, baseIdPath, handleSearch);
  }
}
function deleteButtonEventListener(button) {
  button === null || button === void 0 ? void 0 : button.addEventListener("click", (e6) => {
    var _a2, _b, _c, _d;
    e6.stopPropagation();
    const currentNode = (_a2 = button.parentNode) === null || _a2 === void 0 ? void 0 : _a2.parentNode;
    const splitArray = (_b = currentNode === null || currentNode === void 0 ? void 0 : currentNode.id) === null || _b === void 0 ? void 0 : _b.split(":");
    const length = splitArray.length - 1;
    splitArray[length] = `${Number(splitArray[length]) - 1}`;
    const divId = splitArray.join(":");
    const children = (_c = currentNode === null || currentNode === void 0 ? void 0 : currentNode.parentNode) === null || _c === void 0 ? void 0 : _c.children;
    const divsWithPrefix = Array.from(children).filter((child) => child.tagName.toLowerCase() === "div" && child.id.startsWith(divId));
    const divButtons = divsWithPrefix[0].querySelectorAll(".divButton");
    const targetDivButton = divButtons[divButtons.length - 1];
    targetDivButton === null || targetDivButton === void 0 ? void 0 : targetDivButton.classList.remove("hidden");
    (_d = currentNode === null || currentNode === void 0 ? void 0 : currentNode.parentNode) === null || _d === void 0 ? void 0 : _d.removeChild(currentNode);
  });
}
function treeChildrenPTag(tree, div, depth) {
  if (tree.rmType !== "COMPOSITION" && tree.rmType !== "EVENT_CONTEXT" && tree.rmType !== "ISM_TRANSITION") {
    div.className = "heading";
    if (tree.path.split("/").length === 2)
      div.className = `${div.className} margin-bottom-4 `;
    const p2 = document.createElement("p");
    p2.className = getDepthClass(depth);
    p2.innerHTML = encodeText(tree.name);
    div === null || div === void 0 ? void 0 : div.appendChild(p2);
  }
}
function noChildrenCondition(tree, div, handleSearch, config) {
  var _a2;
  if (!tree.mbElement)
    return;
  if (!tree.inContext)
    div.classList.add("leaf-child");
  div.innerHTML = tree.mbElement;
  const innerDiv = div.childNodes[0];
  if ((innerDiv === null || innerDiv === void 0 ? void 0 : innerDiv.tagName) === "MB-SEARCH" || (innerDiv === null || innerDiv === void 0 ? void 0 : innerDiv.tagName) === "MB-SEARCH-MULTIPLE") {
    innerDiv.handleSearch = handleSearch;
  }
  if ((innerDiv === null || innerDiv === void 0 ? void 0 : innerDiv.tagName) === "MB-MULTIMEDIA") {
    handleMediaPlugin(innerDiv);
  }
  if ((innerDiv === null || innerDiv === void 0 ? void 0 : innerDiv.tagName) === "MB-INPUT" && ((_a2 = config === null || config === void 0 ? void 0 : config.TEXT_AREA) === null || _a2 === void 0 ? void 0 : _a2.includes(innerDiv.path)))
    innerDiv.textarea = true;
}
function runAddEventListener(div, handleSearch, config) {
  var _a2, _b;
  let elementId = stripIndex(div === null || div === void 0 ? void 0 : div.id);
  const children = (_a2 = div === null || div === void 0 ? void 0 : div.parentNode) === null || _a2 === void 0 ? void 0 : _a2.children;
  const divsWithPrefix = Array.from(children).filter((child) => child.tagName.toLowerCase() === "div" && child.id.startsWith(`${elementId}:`) && child.className !== "repeatables");
  elementId = `${elementId}:${divsWithPrefix.length}`;
  const cloneDiv = prepareClonedDiv(div.id, elementId);
  processChildElements(cloneDiv, elementId, handleSearch);
  const pTag = cloneDiv.querySelector("p.label");
  const pTagArray = (_b = pTag === null || pTag === void 0 ? void 0 : pTag.textContent) === null || _b === void 0 ? void 0 : _b.split(".");
  pTagArray[0] = `${(divsWithPrefix === null || divsWithPrefix === void 0 ? void 0 : divsWithPrefix.length) + 1}`;
  pTag.textContent = pTagArray.join(" . ");
  setupButtons(cloneDiv, div, handleSearch, config);
  const parentNode = div === null || div === void 0 ? void 0 : div.parentNode;
  parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(cloneDiv, div.nextSibling);
}
function addMBRepeatables(tree, container) {
  if (!(tree === null || tree === void 0 ? void 0 : tree.path) || !tree.mbElement || !container)
    return;
  const fragment = document.createDocumentFragment();
  const newDiv = document.createElement("div");
  Object.assign(newDiv, {
    className: "repeatables",
    id: stripIndex(encodeText(tree.path)),
    innerHTML: tree.mbElement
  });
  fragment === null || fragment === void 0 ? void 0 : fragment.appendChild(newDiv);
  container === null || container === void 0 ? void 0 : container.appendChild(fragment);
}
function createRepeatableButtons(tree, div, handleSearch, config) {
  const addButton = document.createElement("sl-button");
  addButton.innerHTML = `+  ${tree.name}`;
  addButton.size = "small";
  addButton.className = "addButton";
  addButton.addEventListener("click", () => {
    runAddEventListener(div, handleSearch, config);
  });
  const deleteButton = document.createElement("sl-button");
  deleteButton.textContent = "Delete";
  deleteButton.className = "deleteButton hidden";
  deleteButton.size = "small";
  deleteButton.variant = "neutral";
  const divButton = document.createElement("div");
  divButton.className = "divButton flex justify-end";
  divButton.append(addButton, deleteButton);
  return divButton;
}
function addButtonEventListener(button, div, handleSearch, config) {
  button === null || button === void 0 ? void 0 : button.addEventListener("click", () => {
    runAddEventListener(div, handleSearch, config);
  });
}
function traverse(tree, container, document2, reference, handleSearch, config, depth = -1) {
  var _a2, _b, _c;
  if (!tree || !document2)
    return;
  if (!tree.path || !((_a2 = tree.children) === null || _a2 === void 0 ? void 0 : _a2.length) && !tree.mbElement)
    return;
  const fragment = document2.createDocumentFragment();
  const div = fragment === null || fragment === void 0 ? void 0 : fragment.appendChild(document2.createElement("div"));
  div.id = encodeText(tree.path);
  if (tree.max === -1 && ((_b = tree.children) === null || _b === void 0 ? void 0 : _b.length)) {
    addMBRepeatables(tree, container);
    treeChildrenPTag(tree, div, depth + 1);
    const pTag = div.querySelector("p");
    pTag === null || pTag === void 0 ? void 0 : pTag.classList.add("label");
    const index = div.id.split(":").pop() || 0;
    pTag.innerHTML = `${Number(index) + 1} . ${encodeText(tree.name)}`;
    for (const child of tree.children || []) {
      traverse(child, div, document2, reference, handleSearch, config, depth + 1);
    }
    div.append(createRepeatableButtons(tree, div, handleSearch, config));
  } else if ((_c = tree.children) === null || _c === void 0 ? void 0 : _c.length) {
    treeChildrenPTag(tree, div, depth + 1);
    for (const child of tree.children || []) {
      traverse(child, div, document2, reference, handleSearch, config, depth + 1);
    }
  } else
    noChildrenCondition(tree, div, handleSearch, config);
  if (reference)
    div.className = `${encodeText(div.className)} reference hidden`;
  container === null || container === void 0 ? void 0 : container.appendChild(fragment);
}
function handleLeafNode(node) {
  var _a2, _b;
  if (node.inContext) {
    node.mbElement = getDefaultTransform(node);
  } else if (node.rmType === "DV_CODED_TEXT") {
    const lists = (_a2 = node.inputs.find((input) => input.suffix === "code")) === null || _a2 === void 0 ? void 0 : _a2.list;
    if (lists === null || lists === void 0 ? void 0 : lists.length) {
      if (lists.length <= 3)
        node.mbElement = getDefaultTransform(node, 1);
      else
        node.mbElement = getDefaultTransform(node);
    } else
      node.mbElement = getDefaultTransform(node, 2);
  } else if ((_b = node === null || node === void 0 ? void 0 : node.path) === null || _b === void 0 ? void 0 : _b.endsWith("expiry_time")) {
    node.mbElement = createContextElement(node.path);
  } else
    node.mbElement = getDefaultTransform(node);
}
function addIgniteContext(node) {
  var _a2, _b, _c;
  const contextNode = (_a2 = node === null || node === void 0 ? void 0 : node.children) === null || _a2 === void 0 ? void 0 : _a2.find((n6) => (n6 === null || n6 === void 0 ? void 0 : n6.id) === "context");
  (_b = contextNode === null || contextNode === void 0 ? void 0 : contextNode.children) === null || _b === void 0 ? void 0 : _b.push(healthCareFacilityContextNode);
  (_c = contextNode === null || contextNode === void 0 ? void 0 : contextNode.children) === null || _c === void 0 ? void 0 : _c.push(participationContextNode);
  return node;
}
function addPathToChildren(node, parentPath = "") {
  node.path = parentPath === "" ? node === null || node === void 0 ? void 0 : node.id : `${parentPath}/${node === null || node === void 0 ? void 0 : node.id}`;
  if ((node === null || node === void 0 ? void 0 : node.max) === -1)
    node.path += ":0";
  if (node === null || node === void 0 ? void 0 : node.children)
    for (const child of node.children) {
      addPathToChildren(child, `${node === null || node === void 0 ? void 0 : node.path}`);
    }
  return node;
}
function handleNodeWithChildren(node) {
  const children = node.children;
  if (node.max === -1) {
    node.mbElement = createRepeatableElement(node.path);
  }
  for (const child of children) {
    addMbElements(child);
  }
}
function addMbElements(node) {
  var _a2;
  if (!node)
    return node;
  if ((_a2 = node === null || node === void 0 ? void 0 : node.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
    handleNodeWithChildren(node);
  } else
    handleLeafNode(node);
  return node;
}
function createAutoFormTree(webTemplate, addContext = false) {
  const baseTree = webTemplate === null || webTemplate === void 0 ? void 0 : webTemplate.tree;
  const treeWithContext = addContext ? addIgniteContext(baseTree) : baseTree;
  const treeWithPaths = addPathToChildren(treeWithContext, "");
  return addMbElements(treeWithPaths);
}
function createAutoFormByTemplateId(webTemplate, handleSearch, config, addContext = false) {
  const container = querySelectorDeep("#autoForm");
  const newTree = createAutoFormTree(webTemplate, addContext);
  if (container)
    container.innerHTML = "";
  traverse(newTree, container, document, true, handleSearch, config);
  traverse(newTree, container, document, false, handleSearch, config);
}
function bindRepeatables(mbRepeatables, repeatableArray, formNode, composition, handleSearch, config) {
  var _a2;
  for (const repeatable of repeatableArray) {
    const path = repeatable.path;
    const countIndex = count(composition, path);
    const parentNode = (_a2 = repeatable.parentNode) === null || _a2 === void 0 ? void 0 : _a2.parentNode;
    for (let j = 1; j < countIndex; j++) {
      requestAnimationFrame(() => {
        var _a3;
        const divsWithPrefix = Array.from(parentNode === null || parentNode === void 0 ? void 0 : parentNode.children).filter((child) => child.tagName.toLowerCase() === "div" && child.id.startsWith(path) && child.className !== "repeatables");
        const targetDiv = divsWithPrefix[divsWithPrefix.length - 1];
        const addButtons = targetDiv === null || targetDiv === void 0 ? void 0 : targetDiv.querySelectorAll(".addButton");
        const targetAddButton = addButtons === null || addButtons === void 0 ? void 0 : addButtons[(addButtons === null || addButtons === void 0 ? void 0 : addButtons.length) - 1];
        const buttonParentNode = (_a3 = targetAddButton === null || targetAddButton === void 0 ? void 0 : targetAddButton.parentNode) === null || _a3 === void 0 ? void 0 : _a3.parentNode;
        runAddEventListener(buttonParentNode, handleSearch, config);
      });
    }
  }
  requestAnimationFrame(() => {
    const newMbRepeatables = formNode === null || formNode === void 0 ? void 0 : formNode.querySelectorAll("mb-repeatable-headless");
    const oldMbRepeatables = /* @__PURE__ */ new Set([...repeatableArray, ...mbRepeatables]);
    const newArray = Array.from(newMbRepeatables || []).filter((item) => !Array.from(oldMbRepeatables).some((ele) => item.path === ele.path));
    if (newArray.length)
      bindRepeatables(Array.from(oldMbRepeatables), newArray, formNode, composition, handleSearch, config);
  });
}

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/form/autoForm.js
var __decorate5 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MedblocksAutoForm = class MedblocksAutoForm2 extends LitElement {
  constructor() {
    super(...arguments);
    this.templateId = "";
    this.ctx = {};
    this.config = {};
    this.webTemplate = void 0;
    this.variant = "small";
    this.addContext = false;
  }
  handleInput(event2) {
    this.dispatchEvent(new CustomEvent("mb-input", {
      detail: event2.detail,
      bubbles: true,
      composed: true
    }));
  }
  firstUpdated() {
    this.generateAutoForm();
  }
  generateAutoForm() {
    if (this.webTemplate) {
      try {
        createAutoFormByTemplateId(this.webTemplate, this.handleSearch, this.config, this.addContext);
      } catch (error) {
        console.error("Error generating auto form:", error);
      }
    }
  }
  import(composition) {
    this.bindValue(composition);
  }
  clear() {
    this.bindValue({});
  }
  bindValue(composition) {
    const mbForm = this.renderRoot.querySelector("mb-form");
    mbForm.data = {};
    const container = mbForm.querySelector("#autoForm");
    const formNode = container.children[1];
    const mbRepeatables = [
      ...formNode.querySelectorAll("mb-repeatable-headless")
    ];
    bindRepeatables(mbRepeatables, mbRepeatables, formNode, composition, this.handleSearch, this.config);
    setTimeout(() => {
      mbForm.import(composition);
    }, 10);
  }
  export() {
    return this.submit();
  }
  submit() {
    const mbForm = this.renderRoot.querySelector("mb-form");
    if (mbForm.validate()) {
      mbForm.insertContext();
      return mbForm.serialize();
    }
  }
  render() {
    return html`
      <mb-form
        variant=${this.variant}
        templateId=${this.templateId}
        .ctx=${this.ctx}
        overwritectx
        @mb-input=${this.handleInput}
        .handleSearch=${this.handleSearch}
      >
        <div id="autoForm"></div>
      </mb-form>
    `;
  }
};
MedblocksAutoForm.styles = css`
    :host {
      display: block;
      width: 100%;
    }
    #autoForm {
      padding: 0.5rem;
    }
    .flex {
      display: flex;
    }
    .justify-end {
      justify-content: flex-end;
    }
    .hidden {
      display: none;
    }
    .addButton {
      display: flex;
      margin: 8px;
    }
    .deleteButton {
      margin: 8px 8px 8px 0px;
    }
    .leaf-child {
      padding: 0px 16px 8px;
    }
    .heading {
      font-family: system-ui;
      margin: 8px;
      border-radius: 8px;
      border: 2px solid #e2e8f0;
    }
    margin-bottom-4 : {
      margin-bottom: 16px;
    }
    .p-depth {
      margin: -2px;
      border-top-left-radius: 6px;
      border-top-right-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      line-height: 20px;
      padding: 8px 12px;
      margin-bottom: 8px;
      color: white;
    }
    .bg-slate-700 {
      background-color: #334155;
    }
    .bg-slate-600 {
      background-color: #475569;
    }
    .bg-slate-500 {
      background-color: #64748b;
    }
    .bg-slate-400 {
      background-color: #94a3b8;
    }
  `;
__decorate5([
  property({ type: String, reflect: true })
], MedblocksAutoForm.prototype, "templateId", void 0);
__decorate5([
  property({ type: Object })
], MedblocksAutoForm.prototype, "ctx", void 0);
__decorate5([
  property({ type: Object })
], MedblocksAutoForm.prototype, "config", void 0);
__decorate5([
  property({ type: Object })
], MedblocksAutoForm.prototype, "webTemplate", void 0);
__decorate5([
  property({ type: String, reflect: true })
], MedblocksAutoForm.prototype, "variant", void 0);
__decorate5([
  property({ type: Boolean, reflect: true })
], MedblocksAutoForm.prototype, "addContext", void 0);
__decorate5([
  property({ type: Function })
], MedblocksAutoForm.prototype, "handleSearch", void 0);
__decorate5([
  watch("webTemplate")
], MedblocksAutoForm.prototype, "generateAutoForm", null);
MedblocksAutoForm = __decorate5([
  customElement("mb-auto-form")
], MedblocksAutoForm);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/form/plugins/fhir.js
var serialize = (mbElement) => {
  var _a2, _b, _c, _d, _e, _f, _g;
  if (mbElement.datatype === "CodableConcept") {
    const codable = mbElement;
    if ((_a2 = codable.data) === null || _a2 === void 0 ? void 0 : _a2.code) {
      return {
        text: (_b = codable.data) === null || _b === void 0 ? void 0 : _b.value,
        coding: [
          {
            system: (_c = codable.data) === null || _c === void 0 ? void 0 : _c.terminology,
            code: (_d = codable.data) === null || _d === void 0 ? void 0 : _d.code,
            display: (_e = codable.data) === null || _e === void 0 ? void 0 : _e.value
          }
        ]
      };
    }
  } else if (mbElement.datatype === "code") {
    const code = mbElement;
    if ((_f = code.data) === null || _f === void 0 ? void 0 : _f.code) {
      return (_g = code.data) === null || _g === void 0 ? void 0 : _g.code;
    }
  }
  return mbElement.data;
};
var deserialize = (mbElement, data) => {
  var _a2, _b, _c;
  if (mbElement.datatype === "CodableConcept") {
    const terminology = (_a2 = data === null || data === void 0 ? void 0 : data.coding) === null || _a2 === void 0 ? void 0 : _a2[0].system;
    const code = (_b = data === null || data === void 0 ? void 0 : data.coding) === null || _b === void 0 ? void 0 : _b[0].code;
    const value = (_c = data === null || data === void 0 ? void 0 : data.coding) === null || _c === void 0 ? void 0 : _c[0].display;
    if (terminology || code || value) {
      return {
        terminology,
        code,
        value
      };
    }
  } else if (mbElement.datatype === "code") {
    const el = mbElement;
    const code = data;
    const { terminology } = el;
    if (terminology || code) {
      return {
        terminology,
        code
      };
    }
  }
  return data;
};
var isEmpty = (value) => {
  if (value == null) {
    return true;
  }
  if (value && (value === null || value === void 0 ? void 0 : value.constructor) === Object && Object.keys(value).length === 0) {
    return true;
  }
  return false;
};
function toInsertContext2(path, nonNullPaths) {
  if (path === "resourceType") {
    return true;
  }
  const segments = path.split(".");
  const previousPath = segments.slice(0, -1).join(".");
  if (nonNullPaths.some((p2) => p2.startsWith(previousPath))) {
    return true;
  }
  return false;
}
var FHIRPlugin = {
  serialize(mbElements) {
    const transformed = {};
    for (const path of Object.keys(mbElements)) {
      const value = mbElements[path];
      if (!isEmpty(value.data)) {
        transformed[path] = serialize(value);
      }
    }
    const filtered = JSON.parse(JSON.stringify(transformed));
    return unflatten(filtered);
  },
  parse(mbElements, data) {
    const flat = flatten(data);
    const newObj = {};
    for (const path of Object.keys(mbElements)) {
      const value = flat[path];
      if (value) {
        newObj[path] = deserialize(mbElements[path], value);
      } else {
        const includesPath = Object.keys(flat).filter((p2) => p2.startsWith(path));
        const simplifiedObject = {};
        for (const p2 of includesPath) {
          let simplifiedPath = p2.replace(path, "");
          if (simplifiedPath.startsWith(".")) {
            simplifiedPath = simplifiedPath.replace(".", "");
          }
          simplifiedObject[simplifiedPath] = flat[p2];
        }
        const simplifiedUnflattened = unflatten(simplifiedObject);
        newObj[path] = deserialize(mbElements[path], simplifiedUnflattened);
      }
    }
    return newObj;
  },
  getContext(path, ctx, nonNullPaths, mbElements) {
    if (!toInsertContext2(path, nonNullPaths)) {
      return;
    }
    const context = mbElements[path];
    if (context.bind) {
      return context.bind;
    }
    const parts2 = path.split(".");
    const partsLength = parts2.length;
    const contextId = parts2.slice(partsLength - 2, partsLength).join(".");
    if (ctx[contextId] !== null) {
      return ctx[contextId];
    }
  }
};

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/form/fhirForm.js
var __decorate6 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var FHIRForm = class FHIRForm2 extends form_default {
  constructor() {
    super(...arguments);
    this.plugin = FHIRPlugin;
  }
};
FHIRForm = __decorate6([
  customElement("mb-fhir-form")
], FHIRForm);

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/directives/until.js
var _state = /* @__PURE__ */ new WeakMap();
var _infinity = 2147483647;
var until = directive((...args) => (part) => {
  let state2 = _state.get(part);
  if (state2 === void 0) {
    state2 = {
      lastRenderedIndex: _infinity,
      values: []
    };
    _state.set(part, state2);
  }
  const previousValues3 = state2.values;
  let previousLength = previousValues3.length;
  state2.values = args;
  for (let i5 = 0; i5 < args.length; i5++) {
    if (i5 > state2.lastRenderedIndex) {
      break;
    }
    const value = args[i5];
    if (isPrimitive(value) || typeof value.then !== "function") {
      part.setValue(value);
      state2.lastRenderedIndex = i5;
      break;
    }
    if (i5 < previousLength && value === previousValues3[i5]) {
      continue;
    }
    state2.lastRenderedIndex = _infinity;
    previousLength = 0;
    Promise.resolve(value).then((resolvedValue) => {
      const index = state2.values.indexOf(value);
      if (index > -1 && index < state2.lastRenderedIndex) {
        state2.lastRenderedIndex = index;
        part.setValue(resolvedValue);
        part.commit();
      }
    });
  }
});

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/directives/class-map.js
var ClassList = class {
  constructor(element) {
    this.classes = /* @__PURE__ */ new Set();
    this.changed = false;
    this.element = element;
    const classList = (element.getAttribute("class") || "").split(/\s+/);
    for (const cls of classList) {
      this.classes.add(cls);
    }
  }
  add(cls) {
    this.classes.add(cls);
    this.changed = true;
  }
  remove(cls) {
    this.classes.delete(cls);
    this.changed = true;
  }
  commit() {
    if (this.changed) {
      let classString = "";
      this.classes.forEach((cls) => classString += cls + " ");
      this.element.setAttribute("class", classString);
    }
  }
};
var previousClassesCache = /* @__PURE__ */ new WeakMap();
var classMap = directive((classInfo) => (part) => {
  if (!(part instanceof AttributePart) || part instanceof PropertyPart || part.committer.name !== "class" || part.committer.parts.length > 1) {
    throw new Error("The `classMap` directive must be used in the `class` attribute and must be the only part in the attribute.");
  }
  const { committer } = part;
  const { element } = committer;
  let previousClasses = previousClassesCache.get(part);
  if (previousClasses === void 0) {
    element.setAttribute("class", committer.strings.join(" "));
    previousClassesCache.set(part, previousClasses = /* @__PURE__ */ new Set());
  }
  const classList = element.classList || new ClassList(element);
  previousClasses.forEach((name) => {
    if (!(name in classInfo)) {
      classList.remove(name);
      previousClasses.delete(name);
    }
  });
  for (const name in classInfo) {
    const value = classInfo[name];
    if (value != previousClasses.has(name)) {
      if (value) {
        classList.add(name);
        previousClasses.add(name);
      } else {
        classList.remove(name);
        previousClasses.delete(name);
      }
    }
  }
  if (typeof classList.commit === "function") {
    classList.commit();
  }
});

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/directives/if-defined.js
var previousValues = /* @__PURE__ */ new WeakMap();
var ifDefined = directive((value) => (part) => {
  const previousValue = previousValues.get(part);
  if (value === void 0 && part instanceof AttributePart) {
    if (previousValue !== void 0 || !previousValues.has(part)) {
      const name = part.committer.name;
      part.committer.element.removeAttribute(name);
    }
  } else if (value !== previousValue) {
    part.setValue(value);
  }
  previousValues.set(part, value);
});

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PEQICPKO.js
var t = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var e = Symbol();
var n = /* @__PURE__ */ new Map();
var s = class {
  constructor(t33, n52) {
    if (this._$cssResult$ = true, n52 !== e)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t33;
  }
  get styleSheet() {
    let e42 = n.get(this.cssText);
    return t && e42 === void 0 && (n.set(this.cssText, e42 = new CSSStyleSheet()), e42.replaceSync(this.cssText)), e42;
  }
  toString() {
    return this.cssText;
  }
};
var o = (t33) => new s(typeof t33 == "string" ? t33 : t33 + "", e);
var r = (t33, ...n52) => {
  const o52 = t33.length === 1 ? t33[0] : n52.reduce((e42, n6, s52) => e42 + ((t42) => {
    if (t42._$cssResult$ === true)
      return t42.cssText;
    if (typeof t42 == "number")
      return t42;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t42 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n6) + t33[s52 + 1], t33[0]);
  return new s(o52, e);
};
var i = (e42, n52) => {
  t ? e42.adoptedStyleSheets = n52.map((t33) => t33 instanceof CSSStyleSheet ? t33 : t33.styleSheet) : n52.forEach((t33) => {
    const n6 = document.createElement("style"), s52 = window.litNonce;
    s52 !== void 0 && n6.setAttribute("nonce", s52), n6.textContent = t33.cssText, e42.appendChild(n6);
  });
};
var S = t ? (t33) => t33 : (t33) => t33 instanceof CSSStyleSheet ? ((t42) => {
  let e42 = "";
  for (const n52 of t42.cssRules)
    e42 += n52.cssText;
  return o(e42);
})(t33) : t33;
var s2;
var e2 = window.trustedTypes;
var r2 = e2 ? e2.emptyScript : "";
var h = window.reactiveElementPolyfillSupport;
var o2 = { toAttribute(t33, i32) {
  switch (i32) {
    case Boolean:
      t33 = t33 ? r2 : null;
      break;
    case Object:
    case Array:
      t33 = t33 == null ? t33 : JSON.stringify(t33);
  }
  return t33;
}, fromAttribute(t33, i32) {
  let s52 = t33;
  switch (i32) {
    case Boolean:
      s52 = t33 !== null;
      break;
    case Number:
      s52 = t33 === null ? null : Number(t33);
      break;
    case Object:
    case Array:
      try {
        s52 = JSON.parse(t33);
      } catch (t42) {
        s52 = null;
      }
  }
  return s52;
} };
var n2 = (t33, i32) => i32 !== t33 && (i32 == i32 || t33 == t33);
var l = { attribute: true, type: String, converter: o2, reflect: false, hasChanged: n2 };
var a = class extends HTMLElement {
  constructor() {
    super(), this._$Et = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$Ei = null, this.o();
  }
  static addInitializer(t33) {
    var i32;
    (i32 = this.l) !== null && i32 !== void 0 || (this.l = []), this.l.push(t33);
  }
  static get observedAttributes() {
    this.finalize();
    const t33 = [];
    return this.elementProperties.forEach((i32, s52) => {
      const e42 = this._$Eh(s52, i32);
      e42 !== void 0 && (this._$Eu.set(e42, s52), t33.push(e42));
    }), t33;
  }
  static createProperty(t33, i32 = l) {
    if (i32.state && (i32.attribute = false), this.finalize(), this.elementProperties.set(t33, i32), !i32.noAccessor && !this.prototype.hasOwnProperty(t33)) {
      const s52 = typeof t33 == "symbol" ? Symbol() : "__" + t33, e42 = this.getPropertyDescriptor(t33, s52, i32);
      e42 !== void 0 && Object.defineProperty(this.prototype, t33, e42);
    }
  }
  static getPropertyDescriptor(t33, i32, s52) {
    return { get() {
      return this[i32];
    }, set(e42) {
      const r42 = this[t33];
      this[i32] = e42, this.requestUpdate(t33, r42, s52);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t33) {
    return this.elementProperties.get(t33) || l;
  }
  static finalize() {
    if (this.hasOwnProperty("finalized"))
      return false;
    this.finalized = true;
    const t33 = Object.getPrototypeOf(this);
    if (t33.finalize(), this.elementProperties = new Map(t33.elementProperties), this._$Eu = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const t42 = this.properties, i32 = [...Object.getOwnPropertyNames(t42), ...Object.getOwnPropertySymbols(t42)];
      for (const s52 of i32)
        this.createProperty(s52, t42[s52]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(i32) {
    const s52 = [];
    if (Array.isArray(i32)) {
      const e42 = new Set(i32.flat(1 / 0).reverse());
      for (const i42 of e42)
        s52.unshift(S(i42));
    } else
      i32 !== void 0 && s52.push(S(i32));
    return s52;
  }
  static _$Eh(t33, i32) {
    const s52 = i32.attribute;
    return s52 === false ? void 0 : typeof s52 == "string" ? s52 : typeof t33 == "string" ? t33.toLowerCase() : void 0;
  }
  o() {
    var t33;
    this._$Ep = new Promise((t42) => this.enableUpdating = t42), this._$AL = /* @__PURE__ */ new Map(), this._$Em(), this.requestUpdate(), (t33 = this.constructor.l) === null || t33 === void 0 || t33.forEach((t42) => t42(this));
  }
  addController(t33) {
    var i32, s52;
    ((i32 = this._$Eg) !== null && i32 !== void 0 ? i32 : this._$Eg = []).push(t33), this.renderRoot !== void 0 && this.isConnected && ((s52 = t33.hostConnected) === null || s52 === void 0 || s52.call(t33));
  }
  removeController(t33) {
    var i32;
    (i32 = this._$Eg) === null || i32 === void 0 || i32.splice(this._$Eg.indexOf(t33) >>> 0, 1);
  }
  _$Em() {
    this.constructor.elementProperties.forEach((t33, i32) => {
      this.hasOwnProperty(i32) && (this._$Et.set(i32, this[i32]), delete this[i32]);
    });
  }
  createRenderRoot() {
    var t33;
    const s52 = (t33 = this.shadowRoot) !== null && t33 !== void 0 ? t33 : this.attachShadow(this.constructor.shadowRootOptions);
    return i(s52, this.constructor.elementStyles), s52;
  }
  connectedCallback() {
    var t33;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t33 = this._$Eg) === null || t33 === void 0 || t33.forEach((t42) => {
      var i32;
      return (i32 = t42.hostConnected) === null || i32 === void 0 ? void 0 : i32.call(t42);
    });
  }
  enableUpdating(t33) {
  }
  disconnectedCallback() {
    var t33;
    (t33 = this._$Eg) === null || t33 === void 0 || t33.forEach((t42) => {
      var i32;
      return (i32 = t42.hostDisconnected) === null || i32 === void 0 ? void 0 : i32.call(t42);
    });
  }
  attributeChangedCallback(t33, i32, s52) {
    this._$AK(t33, s52);
  }
  _$ES(t33, i32, s52 = l) {
    var e42, r42;
    const h3 = this.constructor._$Eh(t33, s52);
    if (h3 !== void 0 && s52.reflect === true) {
      const n52 = ((r42 = (e42 = s52.converter) === null || e42 === void 0 ? void 0 : e42.toAttribute) !== null && r42 !== void 0 ? r42 : o2.toAttribute)(i32, s52.type);
      this._$Ei = t33, n52 == null ? this.removeAttribute(h3) : this.setAttribute(h3, n52), this._$Ei = null;
    }
  }
  _$AK(t33, i32) {
    var s52, e42, r42;
    const h3 = this.constructor, n52 = h3._$Eu.get(t33);
    if (n52 !== void 0 && this._$Ei !== n52) {
      const t42 = h3.getPropertyOptions(n52), l42 = t42.converter, a32 = (r42 = (e42 = (s52 = l42) === null || s52 === void 0 ? void 0 : s52.fromAttribute) !== null && e42 !== void 0 ? e42 : typeof l42 == "function" ? l42 : null) !== null && r42 !== void 0 ? r42 : o2.fromAttribute;
      this._$Ei = n52, this[n52] = a32(i32, t42.type), this._$Ei = null;
    }
  }
  requestUpdate(t33, i32, s52) {
    let e42 = true;
    t33 !== void 0 && (((s52 = s52 || this.constructor.getPropertyOptions(t33)).hasChanged || n2)(this[t33], i32) ? (this._$AL.has(t33) || this._$AL.set(t33, i32), s52.reflect === true && this._$Ei !== t33 && (this._$E_ === void 0 && (this._$E_ = /* @__PURE__ */ new Map()), this._$E_.set(t33, s52))) : e42 = false), !this.isUpdatePending && e42 && (this._$Ep = this._$EC());
  }
  async _$EC() {
    this.isUpdatePending = true;
    try {
      await this._$Ep;
    } catch (t42) {
      Promise.reject(t42);
    }
    const t33 = this.scheduleUpdate();
    return t33 != null && await t33, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t33;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Et && (this._$Et.forEach((t42, i42) => this[i42] = t42), this._$Et = void 0);
    let i32 = false;
    const s52 = this._$AL;
    try {
      i32 = this.shouldUpdate(s52), i32 ? (this.willUpdate(s52), (t33 = this._$Eg) === null || t33 === void 0 || t33.forEach((t42) => {
        var i42;
        return (i42 = t42.hostUpdate) === null || i42 === void 0 ? void 0 : i42.call(t42);
      }), this.update(s52)) : this._$EU();
    } catch (t42) {
      throw i32 = false, this._$EU(), t42;
    }
    i32 && this._$AE(s52);
  }
  willUpdate(t33) {
  }
  _$AE(t33) {
    var i32;
    (i32 = this._$Eg) === null || i32 === void 0 || i32.forEach((t42) => {
      var i42;
      return (i42 = t42.hostUpdated) === null || i42 === void 0 ? void 0 : i42.call(t42);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t33)), this.updated(t33);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Ep;
  }
  shouldUpdate(t33) {
    return true;
  }
  update(t33) {
    this._$E_ !== void 0 && (this._$E_.forEach((t42, i32) => this._$ES(i32, this[i32], t42)), this._$E_ = void 0), this._$EU();
  }
  updated(t33) {
  }
  firstUpdated(t33) {
  }
};
a.finalized = true, a.elementProperties = /* @__PURE__ */ new Map(), a.elementStyles = [], a.shadowRootOptions = { mode: "open" }, h == null || h({ ReactiveElement: a }), ((s2 = globalThis.reactiveElementVersions) !== null && s2 !== void 0 ? s2 : globalThis.reactiveElementVersions = []).push("1.2.3");
var t2;
var i2 = globalThis.trustedTypes;
var s3 = i2 ? i2.createPolicy("lit-html", { createHTML: (t33) => t33 }) : void 0;
var e3 = `lit$${(Math.random() + "").slice(9)}$`;
var o3 = "?" + e3;
var n3 = `<${o3}>`;
var l2 = document;
var h2 = (t33 = "") => l2.createComment(t33);
var r3 = (t33) => t33 === null || typeof t33 != "object" && typeof t33 != "function";
var d = Array.isArray;
var u = (t33) => {
  var i32;
  return d(t33) || typeof ((i32 = t33) === null || i32 === void 0 ? void 0 : i32[Symbol.iterator]) == "function";
};
var c = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var a2 = />/g;
var f = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g;
var _ = /'/g;
var m = /"/g;
var g = /^(?:script|style|textarea|title)$/i;
var p = (t33) => (i32, ...s52) => ({ _$litType$: t33, strings: i32, values: s52 });
var $ = p(1);
var y = p(2);
var b = Symbol.for("lit-noChange");
var w = Symbol.for("lit-nothing");
var T = /* @__PURE__ */ new WeakMap();
var x = (t33, i32, s52) => {
  var e42, o52;
  const n52 = (e42 = s52 == null ? void 0 : s52.renderBefore) !== null && e42 !== void 0 ? e42 : i32;
  let l42 = n52._$litPart$;
  if (l42 === void 0) {
    const t42 = (o52 = s52 == null ? void 0 : s52.renderBefore) !== null && o52 !== void 0 ? o52 : null;
    n52._$litPart$ = l42 = new N(i32.insertBefore(h2(), t42), t42, void 0, s52 != null ? s52 : {});
  }
  return l42._$AI(t33), l42;
};
var A = l2.createTreeWalker(l2, 129, null, false);
var C = (t33, i32) => {
  const o52 = t33.length - 1, l42 = [];
  let h3, r42 = i32 === 2 ? "<svg>" : "", d2 = c;
  for (let i42 = 0; i42 < o52; i42++) {
    const s52 = t33[i42];
    let o62, u3, p2 = -1, $2 = 0;
    for (; $2 < s52.length && (d2.lastIndex = $2, u3 = d2.exec(s52), u3 !== null); )
      $2 = d2.lastIndex, d2 === c ? u3[1] === "!--" ? d2 = v : u3[1] !== void 0 ? d2 = a2 : u3[2] !== void 0 ? (g.test(u3[2]) && (h3 = RegExp("</" + u3[2], "g")), d2 = f) : u3[3] !== void 0 && (d2 = f) : d2 === f ? u3[0] === ">" ? (d2 = h3 != null ? h3 : c, p2 = -1) : u3[1] === void 0 ? p2 = -2 : (p2 = d2.lastIndex - u3[2].length, o62 = u3[1], d2 = u3[3] === void 0 ? f : u3[3] === '"' ? m : _) : d2 === m || d2 === _ ? d2 = f : d2 === v || d2 === a2 ? d2 = c : (d2 = f, h3 = void 0);
    const y2 = d2 === f && t33[i42 + 1].startsWith("/>") ? " " : "";
    r42 += d2 === c ? s52 + n3 : p2 >= 0 ? (l42.push(o62), s52.slice(0, p2) + "$lit$" + s52.slice(p2) + e3 + y2) : s52 + e3 + (p2 === -2 ? (l42.push(void 0), i42) : y2);
  }
  const u2 = r42 + (t33[o52] || "<?>") + (i32 === 2 ? "</svg>" : "");
  if (!Array.isArray(t33) || !t33.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [s3 !== void 0 ? s3.createHTML(u2) : u2, l42];
};
var E = class {
  constructor({ strings: t33, _$litType$: s52 }, n52) {
    let l42;
    this.parts = [];
    let r42 = 0, d2 = 0;
    const u2 = t33.length - 1, c2 = this.parts, [v2, a32] = C(t33, s52);
    if (this.el = E.createElement(v2, n52), A.currentNode = this.el.content, s52 === 2) {
      const t42 = this.el.content, i32 = t42.firstChild;
      i32.remove(), t42.append(...i32.childNodes);
    }
    for (; (l42 = A.nextNode()) !== null && c2.length < u2; ) {
      if (l42.nodeType === 1) {
        if (l42.hasAttributes()) {
          const t42 = [];
          for (const i32 of l42.getAttributeNames())
            if (i32.endsWith("$lit$") || i32.startsWith(e3)) {
              const s6 = a32[d2++];
              if (t42.push(i32), s6 !== void 0) {
                const t5 = l42.getAttribute(s6.toLowerCase() + "$lit$").split(e3), i42 = /([.?@])?(.*)/.exec(s6);
                c2.push({ type: 1, index: r42, name: i42[2], strings: t5, ctor: i42[1] === "." ? M : i42[1] === "?" ? H : i42[1] === "@" ? I : S2 });
              } else
                c2.push({ type: 6, index: r42 });
            }
          for (const i32 of t42)
            l42.removeAttribute(i32);
        }
        if (g.test(l42.tagName)) {
          const t42 = l42.textContent.split(e3), s6 = t42.length - 1;
          if (s6 > 0) {
            l42.textContent = i2 ? i2.emptyScript : "";
            for (let i32 = 0; i32 < s6; i32++)
              l42.append(t42[i32], h2()), A.nextNode(), c2.push({ type: 2, index: ++r42 });
            l42.append(t42[s6], h2());
          }
        }
      } else if (l42.nodeType === 8)
        if (l42.data === o3)
          c2.push({ type: 2, index: r42 });
        else {
          let t42 = -1;
          for (; (t42 = l42.data.indexOf(e3, t42 + 1)) !== -1; )
            c2.push({ type: 7, index: r42 }), t42 += e3.length - 1;
        }
      r42++;
    }
  }
  static createElement(t33, i32) {
    const s52 = l2.createElement("template");
    return s52.innerHTML = t33, s52;
  }
};
function P(t33, i32, s52 = t33, e42) {
  var o52, n52, l42, h3;
  if (i32 === b)
    return i32;
  let d2 = e42 !== void 0 ? (o52 = s52._$Cl) === null || o52 === void 0 ? void 0 : o52[e42] : s52._$Cu;
  const u2 = r3(i32) ? void 0 : i32._$litDirective$;
  return (d2 == null ? void 0 : d2.constructor) !== u2 && ((n52 = d2 == null ? void 0 : d2._$AO) === null || n52 === void 0 || n52.call(d2, false), u2 === void 0 ? d2 = void 0 : (d2 = new u2(t33), d2._$AT(t33, s52, e42)), e42 !== void 0 ? ((l42 = (h3 = s52)._$Cl) !== null && l42 !== void 0 ? l42 : h3._$Cl = [])[e42] = d2 : s52._$Cu = d2), d2 !== void 0 && (i32 = P(t33, d2._$AS(t33, i32.values), d2, e42)), i32;
}
var V = class {
  constructor(t33, i32) {
    this.v = [], this._$AN = void 0, this._$AD = t33, this._$AM = i32;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  p(t33) {
    var i32;
    const { el: { content: s52 }, parts: e42 } = this._$AD, o52 = ((i32 = t33 == null ? void 0 : t33.creationScope) !== null && i32 !== void 0 ? i32 : l2).importNode(s52, true);
    A.currentNode = o52;
    let n52 = A.nextNode(), h3 = 0, r42 = 0, d2 = e42[0];
    for (; d2 !== void 0; ) {
      if (h3 === d2.index) {
        let i42;
        d2.type === 2 ? i42 = new N(n52, n52.nextSibling, this, t33) : d2.type === 1 ? i42 = new d2.ctor(n52, d2.name, d2.strings, this, t33) : d2.type === 6 && (i42 = new L(n52, this, t33)), this.v.push(i42), d2 = e42[++r42];
      }
      h3 !== (d2 == null ? void 0 : d2.index) && (n52 = A.nextNode(), h3++);
    }
    return o52;
  }
  m(t33) {
    let i32 = 0;
    for (const s52 of this.v)
      s52 !== void 0 && (s52.strings !== void 0 ? (s52._$AI(t33, s52, i32), i32 += s52.strings.length - 2) : s52._$AI(t33[i32])), i32++;
  }
};
var N = class {
  constructor(t33, i32, s52, e42) {
    var o52;
    this.type = 2, this._$AH = w, this._$AN = void 0, this._$AA = t33, this._$AB = i32, this._$AM = s52, this.options = e42, this._$Cg = (o52 = e42 == null ? void 0 : e42.isConnected) === null || o52 === void 0 || o52;
  }
  get _$AU() {
    var t33, i32;
    return (i32 = (t33 = this._$AM) === null || t33 === void 0 ? void 0 : t33._$AU) !== null && i32 !== void 0 ? i32 : this._$Cg;
  }
  get parentNode() {
    let t33 = this._$AA.parentNode;
    const i32 = this._$AM;
    return i32 !== void 0 && t33.nodeType === 11 && (t33 = i32.parentNode), t33;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t33, i32 = this) {
    t33 = P(this, t33, i32), r3(t33) ? t33 === w || t33 == null || t33 === "" ? (this._$AH !== w && this._$AR(), this._$AH = w) : t33 !== this._$AH && t33 !== b && this.$(t33) : t33._$litType$ !== void 0 ? this.T(t33) : t33.nodeType !== void 0 ? this.S(t33) : u(t33) ? this.A(t33) : this.$(t33);
  }
  M(t33, i32 = this._$AB) {
    return this._$AA.parentNode.insertBefore(t33, i32);
  }
  S(t33) {
    this._$AH !== t33 && (this._$AR(), this._$AH = this.M(t33));
  }
  $(t33) {
    this._$AH !== w && r3(this._$AH) ? this._$AA.nextSibling.data = t33 : this.S(l2.createTextNode(t33)), this._$AH = t33;
  }
  T(t33) {
    var i32;
    const { values: s52, _$litType$: e42 } = t33, o52 = typeof e42 == "number" ? this._$AC(t33) : (e42.el === void 0 && (e42.el = E.createElement(e42.h, this.options)), e42);
    if (((i32 = this._$AH) === null || i32 === void 0 ? void 0 : i32._$AD) === o52)
      this._$AH.m(s52);
    else {
      const t42 = new V(o52, this), i42 = t42.p(this.options);
      t42.m(s52), this.S(i42), this._$AH = t42;
    }
  }
  _$AC(t33) {
    let i32 = T.get(t33.strings);
    return i32 === void 0 && T.set(t33.strings, i32 = new E(t33)), i32;
  }
  A(t33) {
    d(this._$AH) || (this._$AH = [], this._$AR());
    const i32 = this._$AH;
    let s52, e42 = 0;
    for (const o52 of t33)
      e42 === i32.length ? i32.push(s52 = new N(this.M(h2()), this.M(h2()), this, this.options)) : s52 = i32[e42], s52._$AI(o52), e42++;
    e42 < i32.length && (this._$AR(s52 && s52._$AB.nextSibling, e42), i32.length = e42);
  }
  _$AR(t33 = this._$AA.nextSibling, i32) {
    var s52;
    for ((s52 = this._$AP) === null || s52 === void 0 || s52.call(this, false, true, i32); t33 && t33 !== this._$AB; ) {
      const i42 = t33.nextSibling;
      t33.remove(), t33 = i42;
    }
  }
  setConnected(t33) {
    var i32;
    this._$AM === void 0 && (this._$Cg = t33, (i32 = this._$AP) === null || i32 === void 0 || i32.call(this, t33));
  }
};
var S2 = class {
  constructor(t33, i32, s52, e42, o52) {
    this.type = 1, this._$AH = w, this._$AN = void 0, this.element = t33, this.name = i32, this._$AM = e42, this.options = o52, s52.length > 2 || s52[0] !== "" || s52[1] !== "" ? (this._$AH = Array(s52.length - 1).fill(new String()), this.strings = s52) : this._$AH = w;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t33, i32 = this, s52, e42) {
    const o52 = this.strings;
    let n52 = false;
    if (o52 === void 0)
      t33 = P(this, t33, i32, 0), n52 = !r3(t33) || t33 !== this._$AH && t33 !== b, n52 && (this._$AH = t33);
    else {
      const e52 = t33;
      let l42, h3;
      for (t33 = o52[0], l42 = 0; l42 < o52.length - 1; l42++)
        h3 = P(this, e52[s52 + l42], i32, l42), h3 === b && (h3 = this._$AH[l42]), n52 || (n52 = !r3(h3) || h3 !== this._$AH[l42]), h3 === w ? t33 = w : t33 !== w && (t33 += (h3 != null ? h3 : "") + o52[l42 + 1]), this._$AH[l42] = h3;
    }
    n52 && !e42 && this.k(t33);
  }
  k(t33) {
    t33 === w ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t33 != null ? t33 : "");
  }
};
var M = class extends S2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  k(t33) {
    this.element[this.name] = t33 === w ? void 0 : t33;
  }
};
var k = i2 ? i2.emptyScript : "";
var H = class extends S2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  k(t33) {
    t33 && t33 !== w ? this.element.setAttribute(this.name, k) : this.element.removeAttribute(this.name);
  }
};
var I = class extends S2 {
  constructor(t33, i32, s52, e42, o52) {
    super(t33, i32, s52, e42, o52), this.type = 5;
  }
  _$AI(t33, i32 = this) {
    var s52;
    if ((t33 = (s52 = P(this, t33, i32, 0)) !== null && s52 !== void 0 ? s52 : w) === b)
      return;
    const e42 = this._$AH, o52 = t33 === w && e42 !== w || t33.capture !== e42.capture || t33.once !== e42.once || t33.passive !== e42.passive, n52 = t33 !== w && (e42 === w || o52);
    o52 && this.element.removeEventListener(this.name, this, e42), n52 && this.element.addEventListener(this.name, this, t33), this._$AH = t33;
  }
  handleEvent(t33) {
    var i32, s52;
    typeof this._$AH == "function" ? this._$AH.call((s52 = (i32 = this.options) === null || i32 === void 0 ? void 0 : i32.host) !== null && s52 !== void 0 ? s52 : this.element, t33) : this._$AH.handleEvent(t33);
  }
};
var L = class {
  constructor(t33, i32, s52) {
    this.element = t33, this.type = 6, this._$AN = void 0, this._$AM = i32, this.options = s52;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t33) {
    P(this, t33);
  }
};
var z = window.litHtmlPolyfillSupport;
z == null || z(E, N), ((t2 = globalThis.litHtmlVersions) !== null && t2 !== void 0 ? t2 : globalThis.litHtmlVersions = []).push("2.1.3");
var l3;
var o4;
var s4 = class extends a {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Dt = void 0;
  }
  createRenderRoot() {
    var t33, e42;
    const i32 = super.createRenderRoot();
    return (t33 = (e42 = this.renderOptions).renderBefore) !== null && t33 !== void 0 || (e42.renderBefore = i32.firstChild), i32;
  }
  update(t33) {
    const i32 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t33), this._$Dt = x(i32, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t33;
    super.connectedCallback(), (t33 = this._$Dt) === null || t33 === void 0 || t33.setConnected(true);
  }
  disconnectedCallback() {
    var t33;
    super.disconnectedCallback(), (t33 = this._$Dt) === null || t33 === void 0 || t33.setConnected(false);
  }
  render() {
    return b;
  }
};
s4.finalized = true, s4._$litElement$ = true, (l3 = globalThis.litElementHydrateSupport) === null || l3 === void 0 || l3.call(globalThis, { LitElement: s4 });
var n4 = globalThis.litElementPolyfillSupport;
n4 == null || n4({ LitElement: s4 });
((o4 = globalThis.litElementVersions) !== null && o4 !== void 0 ? o4 : globalThis.litElementVersions = []).push("3.1.2");

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KNVYX3FQ.js
var component_styles_default = r`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AMWHV6KC.js
var spinner_styles_default = r`
  ${component_styles_default}

  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
    mix-blend-mode: multiply;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.01em, 2.75em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.01em, 2.75em;
    }
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.72DLNKYZ.js
var n5 = (n32) => (e42) => typeof e42 == "function" ? ((n42, e52) => (window.customElements.define(n42, e52), e52))(n32, e42) : ((n42, e52) => {
  const { kind: t22, elements: i32 } = e52;
  return { kind: t22, elements: i32, finisher(e6) {
    window.customElements.define(n42, e6);
  } };
})(n32, e42);
var i3 = (i32, e42) => e42.kind === "method" && e42.descriptor && !("value" in e42.descriptor) ? __spreadProps(__spreadValues({}, e42), { finisher(n32) {
  n32.createProperty(e42.key, i32);
} }) : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e42.key, initializer() {
  typeof e42.initializer == "function" && (this[e42.key] = e42.initializer.call(this));
}, finisher(n32) {
  n32.createProperty(e42.key, i32);
} };
function e4(e42) {
  return (n32, t22) => t22 !== void 0 ? ((i32, e52, n42) => {
    e52.constructor.createProperty(n42, i32);
  })(e42, n32, t22) : i3(e42, n32);
}
function t3(t22) {
  return e4(__spreadProps(__spreadValues({}, t22), { state: true }));
}
var o5 = ({ finisher: e42, descriptor: t22 }) => (o23, n32) => {
  var r6;
  if (n32 === void 0) {
    const n42 = (r6 = o23.originalKey) !== null && r6 !== void 0 ? r6 : o23.key, i32 = t22 != null ? { kind: "method", placement: "prototype", key: n42, descriptor: t22(o23.key) } : __spreadProps(__spreadValues({}, o23), { key: n42 });
    return e42 != null && (i32.finisher = function(t33) {
      e42(t33, n42);
    }), i32;
  }
  {
    const r22 = o23.constructor;
    t22 !== void 0 && Object.defineProperty(o23, n32, t22(n32)), e42 == null || e42(r22, n32);
  }
};
function i22(i32, n32) {
  return o5({ descriptor: (o23) => {
    const t22 = { get() {
      var o32, n42;
      return (n42 = (o32 = this.renderRoot) === null || o32 === void 0 ? void 0 : o32.querySelector(i32)) !== null && n42 !== void 0 ? n42 : null;
    }, enumerable: true, configurable: true };
    if (n32) {
      const n42 = typeof o23 == "symbol" ? Symbol() : "__" + o23;
      t22.get = function() {
        var o32, t33;
        return this[n42] === void 0 && (this[n42] = (t33 = (o32 = this.renderRoot) === null || o32 === void 0 ? void 0 : o32.querySelector(i32)) !== null && t33 !== void 0 ? t33 : null), this[n42];
      };
    }
    return t22;
  } });
}
var n22;
var e32 = ((n22 = window.HTMLSlotElement) === null || n22 === void 0 ? void 0 : n22.prototype.assignedElements) != null ? (o23, n32) => o23.assignedElements(n32) : (o23, n32) => o23.assignedNodes(n32).filter((o32) => o32.nodeType === Node.ELEMENT_NODE);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FTWX6OPR.js
var SlSpinner = class extends s4 {
  render() {
    return $`
      <svg part="base" class="spinner" role="status">
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = spinner_styles_default;
SlSpinner = __decorateClass([
  n5("sl-spinner")
], SlSpinner);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.R2YZVUVK.js
var menu_styles_default = r`
  ${component_styles_default}

  :host {
    display: block;
  }

  .menu {
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    background: var(--sl-panel-background-color);
    padding: var(--sl-spacing-x-small) 0;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.HQSLB26P.js
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    (this.host = host).addController(this);
    this.slotNames = slotNames;
    this.handleSlotChange = this.handleSlotChange.bind(this);
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
  handleSlotChange(event2) {
    const slot = event2.target;
    if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
      this.host.requestUpdate();
    }
  }
};
function getTextContent(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({ flatten: true });
  let text = "";
  [...nodes].forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IVOHDN3H.js
var hasFocusVisible = (() => {
  const style = document.createElement("style");
  let isSupported;
  try {
    document.head.appendChild(style);
    style.sheet.insertRule(":focus-visible { color: inherit }");
    isSupported = true;
  } catch (e6) {
    isSupported = false;
  } finally {
    style.remove();
  }
  return isSupported;
})();
var focusVisibleSelector = o(hasFocusVisible ? ":focus-visible" : ":focus");

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.CDTZZV7W.js
function emit(el, name, options) {
  const event2 = new CustomEvent(name, __spreadValues({
    bubbles: true,
    cancelable: false,
    composed: true,
    detail: {}
  }, options));
  el.dispatchEvent(event2);
  return event2;
}
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event2) {
      if (event2.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2ZCLEOHE.js
var SlMenu = class extends s4 {
  constructor() {
    super(...arguments);
    this.typeToSelectString = "";
  }
  firstUpdated() {
    this.setAttribute("role", "menu");
  }
  getAllItems(options = { includeDisabled: true }) {
    return [...this.defaultSlot.assignedElements({ flatten: true })].filter((el) => {
      if (el.getAttribute("role") !== "menuitem") {
        return false;
      }
      if (!options.includeDisabled && el.disabled) {
        return false;
      }
      return true;
    });
  }
  getCurrentItem() {
    return this.getAllItems({ includeDisabled: false }).find((i24) => i24.getAttribute("tabindex") === "0");
  }
  setCurrentItem(item) {
    const items = this.getAllItems({ includeDisabled: false });
    const activeItem = item.disabled ? items[0] : item;
    items.forEach((i24) => {
      i24.setAttribute("tabindex", i24 === activeItem ? "0" : "-1");
    });
  }
  typeToSelect(event2) {
    var _a2;
    const items = this.getAllItems({ includeDisabled: false });
    clearTimeout(this.typeToSelectTimeout);
    this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
    if (event2.key === "Backspace") {
      if (event2.metaKey || event2.ctrlKey) {
        this.typeToSelectString = "";
      } else {
        this.typeToSelectString = this.typeToSelectString.slice(0, -1);
      }
    } else {
      this.typeToSelectString += event2.key.toLowerCase();
    }
    if (!hasFocusVisible) {
      items.forEach((item) => item.classList.remove("sl-focus-invisible"));
    }
    for (const item of items) {
      const slot = (_a2 = item.shadowRoot) == null ? void 0 : _a2.querySelector("slot:not([name])");
      const label = getTextContent(slot).toLowerCase().trim();
      if (label.startsWith(this.typeToSelectString)) {
        this.setCurrentItem(item);
        item.focus();
        break;
      }
    }
  }
  handleClick(event2) {
    const target = event2.target;
    const item = target.closest("sl-menu-item");
    if ((item == null ? void 0 : item.disabled) === false) {
      emit(this, "sl-select", { detail: { item } });
    }
  }
  handleKeyUp() {
    if (!hasFocusVisible) {
      const items = this.getAllItems();
      items.forEach((item) => {
        item.classList.remove("sl-focus-invisible");
      });
    }
  }
  handleKeyDown(event2) {
    if (event2.key === "Enter") {
      const item = this.getCurrentItem();
      event2.preventDefault();
      item == null ? void 0 : item.click();
    }
    if (event2.key === " ") {
      event2.preventDefault();
    }
    if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event2.key)) {
      const items = this.getAllItems({ includeDisabled: false });
      const activeItem = this.getCurrentItem();
      let index = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event2.preventDefault();
        if (event2.key === "ArrowDown") {
          index++;
        } else if (event2.key === "ArrowUp") {
          index--;
        } else if (event2.key === "Home") {
          index = 0;
        } else if (event2.key === "End") {
          index = items.length - 1;
        }
        if (index < 0) {
          index = 0;
        }
        if (index > items.length - 1) {
          index = items.length - 1;
        }
        this.setCurrentItem(items[index]);
        items[index].focus();
        return;
      }
    }
    this.typeToSelect(event2);
  }
  handleMouseDown(event2) {
    const target = event2.target;
    if (target.getAttribute("role") === "menuitem") {
      this.setCurrentItem(target);
      if (!hasFocusVisible) {
        target.classList.add("sl-focus-invisible");
      }
    }
  }
  handleSlotChange() {
    const items = this.getAllItems({ includeDisabled: false });
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  render() {
    return $`
      <div
        part="base"
        class="menu"
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @keyup=${this.handleKeyUp}
        @mousedown=${this.handleMouseDown}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlMenu.styles = menu_styles_default;
__decorateClass([
  i22(".menu")
], SlMenu.prototype, "menu", 2);
__decorateClass([
  i22("slot")
], SlMenu.prototype, "defaultSlot", 2);
SlMenu = __decorateClass([
  n5("sl-menu")
], SlMenu);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PWMZHGCP.js
var menu_item_styles_default = r`
  ${component_styles_default}

  :host {
    display: block;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    text-align: left;
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    color: var(--sl-color-neutral-400);
    cursor: not-allowed;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix ::slotted(*) {
    margin-right: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix ::slotted(*) {
    margin-left: var(--sl-spacing-x-small);
  }

  :host(:focus) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'])) .menu-item,
  :host(${focusVisibleSelector}:not(.sl-focus-invisible):not([aria-disabled='true'])) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2JQPDYNA.js
var t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e5 = (t22) => (...e22) => ({ _$litDirective$: t22, values: e22 });
var i4 = class {
  constructor(t22) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t22, e22, i24) {
    this._$Ct = t22, this._$AM = e22, this._$Ci = i24;
  }
  _$AS(t22, e22) {
    return this.update(t22, e22);
  }
  update(t22, e22) {
    return this.render(...e22);
  }
};

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7BXY5XRG.js
var o6 = e5(class extends i4 {
  constructor(t22) {
    var i24;
    if (super(t22), t22.type !== t4.ATTRIBUTE || t22.name !== "class" || ((i24 = t22.strings) === null || i24 === void 0 ? void 0 : i24.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t22) {
    return " " + Object.keys(t22).filter((i24) => t22[i24]).join(" ") + " ";
  }
  update(i24, [s6]) {
    var r6, o23;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), i24.strings !== void 0 && (this.et = new Set(i24.strings.join(" ").split(/\s/).filter((t22) => t22 !== "")));
      for (const t22 in s6)
        s6[t22] && !((r6 = this.et) === null || r6 === void 0 ? void 0 : r6.has(t22)) && this.st.add(t22);
      return this.render(s6);
    }
    const e22 = i24.element.classList;
    this.st.forEach((t22) => {
      t22 in s6 || (e22.remove(t22), this.st.delete(t22));
    });
    for (const t22 in s6) {
      const i32 = !!s6[t22];
      i32 === this.st.has(t22) || ((o23 = this.et) === null || o23 === void 0 ? void 0 : o23.has(t22)) || (i32 ? (e22.add(t22), this.st.add(t22)) : (e22.remove(t22), this.st.delete(t22)));
    }
    return b;
  }
});

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PQ5VRVXF.js
function watch2(propName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update } = proto;
    if (propName in proto) {
      const propNameKey = propName;
      proto.update = function(changedProps) {
        if (changedProps.has(propNameKey)) {
          const oldValue = changedProps.get(propNameKey);
          const newValue = this[propNameKey];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
        update.call(this, changedProps);
      };
    }
  };
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XTJ7LSDZ.js
var SlMenuItem = class extends s4 {
  constructor() {
    super(...arguments);
    this.checked = false;
    this.value = "";
    this.disabled = false;
  }
  firstUpdated() {
    this.setAttribute("role", "menuitem");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return $`
      <div
        part="base"
        class=${o6({
      "menu-item": true,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--has-submenu": false
    })}
      >
        <span class="menu-item__check">
          <sl-icon name="check-lg" library="default" aria-hidden="true"></sl-icon>
        </span>

        <span part="prefix" class="menu-item__prefix">
          <slot name="prefix"></slot>
        </span>

        <span part="label" class="menu-item__label">
          <slot></slot>
        </span>

        <span part="suffix" class="menu-item__suffix">
          <slot name="suffix"></slot>
        </span>

        <span class="menu-item__chevron">
          <sl-icon name="chevron-right" library="default" aria-hidden="true"></sl-icon>
        </span>
      </div>
    `;
  }
};
SlMenuItem.styles = menu_item_styles_default;
__decorateClass([
  i22(".menu-item")
], SlMenuItem.prototype, "menuItem", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "checked", 2);
__decorateClass([
  e4()
], SlMenuItem.prototype, "value", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "disabled", 2);
__decorateClass([
  watch2("checked")
], SlMenuItem.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch2("disabled")
], SlMenuItem.prototype, "handleDisabledChange", 1);
SlMenuItem = __decorateClass([
  n5("sl-menu-item")
], SlMenuItem);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RPB53XXV.js
var includeFiles = /* @__PURE__ */ new Map();
function requestInclude(src, mode = "cors") {
  if (includeFiles.has(src)) {
    return includeFiles.get(src);
  }
  const fileDataPromise = fetch(src, { mode }).then(async (response) => {
    return {
      ok: response.ok,
      status: response.status,
      html: await response.text()
    };
  });
  includeFiles.set(src, fileDataPromise);
  return fileDataPromise;
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P52GZVKG.js
var iconFiles = /* @__PURE__ */ new Map();
async function requestIcon(url) {
  if (iconFiles.has(url)) {
    return iconFiles.get(url);
  }
  const fileData = await requestInclude(url);
  const iconFileData = {
    ok: fileData.ok,
    status: fileData.status,
    svg: null
  };
  if (fileData.ok) {
    const div = document.createElement("div");
    div.innerHTML = fileData.html;
    const svg2 = div.firstElementChild;
    iconFileData.svg = (svg2 == null ? void 0 : svg2.tagName.toLowerCase()) === "svg" ? svg2.outerHTML : "";
  }
  iconFiles.set(url, iconFileData);
  return iconFileData;
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NPYVPRSA.js
var icon_styles_default = r`
  ${component_styles_default}

  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    contain: strict;
    box-sizing: content-box !important;
  }

  .icon,
  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.R37SUKY2.js
var l4 = (l23) => l23 != null ? l23 : w;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.X2HKYC6R.js
var e33 = class extends i4 {
  constructor(i24) {
    if (super(i24), this.it = w, i24.type !== t4.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(r6) {
    if (r6 === w || r6 == null)
      return this.vt = void 0, this.it = r6;
    if (r6 === b)
      return r6;
    if (typeof r6 != "string")
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (r6 === this.it)
      return this.vt;
    this.it = r6;
    const s23 = [r6];
    return s23.raw = s23, this.vt = { _$litType$: this.constructor.resultType, strings: s23, values: [] };
  }
};
e33.directiveName = "unsafeHTML", e33.resultType = 1;
var o7 = e5(e33);
var t32 = class extends e33 {
};
t32.directiveName = "unsafeSVG", t32.resultType = 2;
var o22 = e5(t32);
var parser = new DOMParser();
var SlIcon = class extends s4 {
  constructor() {
    super(...arguments);
    this.svg = "";
    this.label = "";
    this.library = "default";
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getUrl() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return library2.resolver(this.name);
    }
    return this.src;
  }
  redraw() {
    this.setIcon();
  }
  async setIcon() {
    var _a2;
    const library2 = getIconLibrary(this.library);
    const url = this.getUrl();
    if (url) {
      try {
        const file = await requestIcon(url);
        if (url !== this.getUrl()) {
          return;
        } else if (file.ok) {
          const doc = parser.parseFromString(file.svg, "text/html");
          const svgEl = doc.body.querySelector("svg");
          if (svgEl !== null) {
            (_a2 = library2 == null ? void 0 : library2.mutator) == null ? void 0 : _a2.call(library2, svgEl);
            this.svg = svgEl.outerHTML;
            emit(this, "sl-load");
          } else {
            this.svg = "";
            emit(this, "sl-error", { detail: { status: file.status } });
          }
        } else {
          this.svg = "";
          emit(this, "sl-error", { detail: { status: file.status } });
        }
      } catch (e42) {
        emit(this, "sl-error", { detail: { status: -1 } });
      }
    } else if (this.svg.length > 0) {
      this.svg = "";
    }
  }
  handleChange() {
    this.setIcon();
  }
  render() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    return $` <div
      part="base"
      class="icon"
      role=${l4(hasLabel ? "img" : void 0)}
      aria-label=${l4(hasLabel ? this.label : void 0)}
      aria-hidden=${l4(hasLabel ? void 0 : "true")}
    >
      ${o22(this.svg)}
    </div>`;
  }
};
SlIcon.styles = icon_styles_default;
__decorateClass([
  t3()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  e4()
], SlIcon.prototype, "name", 2);
__decorateClass([
  e4()
], SlIcon.prototype, "src", 2);
__decorateClass([
  e4()
], SlIcon.prototype, "label", 2);
__decorateClass([
  e4()
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch2("name"),
  watch2("src"),
  watch2("library")
], SlIcon.prototype, "setIcon", 1);
SlIcon = __decorateClass([
  n5("sl-icon")
], SlIcon);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GX6HO7XH.js
var tag_styles_default = r`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    cursor: default;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--small .tag__remove {
    margin-left: var(--sl-spacing-2x-small);
    margin-right: calc(-1 * var(--sl-spacing-3x-small));
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag__remove {
    margin-left: var(--sl-spacing-2x-small);
    margin-right: calc(-1 * var(--sl-spacing-2x-small));
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    font-size: 1.4em;
    margin-left: var(--sl-spacing-2x-small);
    margin-right: calc(-1 * var(--sl-spacing-x-small));
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TYK5CQ2Z.js
var SlTag = class extends s4 {
  constructor() {
    super(...arguments);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    emit(this, "sl-remove");
  }
  render() {
    return $`
      <span
        part="base"
        class=${o6({
      tag: true,
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <span part="content" class="tag__content">
          <slot></slot>
        </span>

        ${this.removable ? $`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x"
                library="system"
                class="tag__remove"
                @click=${this.handleRemoveClick}
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = tag_styles_default;
__decorateClass([
  e4({ reflect: true })
], SlTag.prototype, "variant", 2);
__decorateClass([
  e4({ reflect: true })
], SlTag.prototype, "size", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlTag.prototype, "pill", 2);
__decorateClass([
  e4({ type: Boolean })
], SlTag.prototype, "removable", 2);
SlTag = __decorateClass([
  n5("sl-tag")
], SlTag);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FE67GRYM.js
var icon_button_styles_default = r`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button${focusVisibleSelector} {
    box-shadow: var(--sl-focus-ring);
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TGQTNU23.js
var SlIconButton = class extends s4 {
  constructor() {
    super(...arguments);
    this.label = "";
    this.disabled = false;
  }
  render() {
    const isLink = this.href ? true : false;
    const interior = $`
      <sl-icon
        name=${l4(this.name)}
        library=${l4(this.library)}
        src=${l4(this.src)}
        aria-hidden="true"
      ></sl-icon>
    `;
    return isLink ? $`
          <a
            part="base"
            class="icon-button"
            href=${l4(this.href)}
            target=${l4(this.target)}
            download=${l4(this.download)}
            rel=${l4(this.target ? "noreferrer noopener" : void 0)}
            role="button"
            aria-disabled=${this.disabled ? "true" : "false"}
            aria-label="${this.label}"
            tabindex=${this.disabled ? "-1" : "0"}
          >
            ${interior}
          </a>
        ` : $`
          <button
            part="base"
            class=${o6({
      "icon-button": true,
      "icon-button--disabled": this.disabled
    })}
            ?disabled=${this.disabled}
            type="button"
            aria-label=${this.label}
          >
            ${interior}
          </button>
        `;
  }
};
SlIconButton.styles = icon_button_styles_default;
__decorateClass([
  i22("button")
], SlIconButton.prototype, "button", 2);
__decorateClass([
  e4()
], SlIconButton.prototype, "name", 2);
__decorateClass([
  e4()
], SlIconButton.prototype, "library", 2);
__decorateClass([
  e4()
], SlIconButton.prototype, "src", 2);
__decorateClass([
  e4()
], SlIconButton.prototype, "href", 2);
__decorateClass([
  e4()
], SlIconButton.prototype, "target", 2);
__decorateClass([
  e4()
], SlIconButton.prototype, "download", 2);
__decorateClass([
  e4()
], SlIconButton.prototype, "label", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);
SlIconButton = __decorateClass([
  n5("sl-icon-button")
], SlIconButton);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6Q6RSBMS.js
var divider_styles_default = r`
  ${component_styles_default}

  :host {
    --color: var(--sl-panel-border-color);
    --width: var(--sl-panel-border-width);
    --spacing: var(--sl-spacing-medium);
  }

  :host(:not([vertical])) {
    display: block;
    border-top: solid var(--width) var(--color);
    margin: var(--spacing) 0;
  }

  :host([vertical]) {
    display: inline-block;
    height: 100%;
    border-left: solid var(--width) var(--color);
    margin: 0 var(--spacing);
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FITQ3IRS.js
var SlDivider = class extends s4 {
  constructor() {
    super(...arguments);
    this.vertical = false;
  }
  firstUpdated() {
    this.setAttribute("role", "separator");
  }
  handleVerticalChange() {
    this.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
  }
};
SlDivider.styles = divider_styles_default;
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlDivider.prototype, "vertical", 2);
__decorateClass([
  watch2("vertical")
], SlDivider.prototype, "handleVerticalChange", 1);
SlDivider = __decorateClass([
  n5("sl-divider")
], SlDivider);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.M72JNJAN.js
var menu_label_styles_default = r`
  ${component_styles_default}

  :host {
    display: block;
  }

  .menu-label {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-large);
    user-select: none;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OTJEEAQN.js
var SlMenuLabel = class extends s4 {
  render() {
    return $`
      <div part="base" class="menu-label">
        <slot></slot>
      </div>
    `;
  }
};
SlMenuLabel.styles = menu_label_styles_default;
SlMenuLabel = __decorateClass([
  n5("sl-menu-label")
], SlMenuLabel);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.4SHATWZF.js
var skeleton_styles_default = r`
  ${component_styles_default}

  :host {
    --border-radius: var(--sl-border-radius-pill);
    --color: var(--sl-color-neutral-200);
    --sheen-color: var(--sl-color-neutral-300);

    display: block;
    position: relative;
  }

  .skeleton {
    display: flex;
    width: 100%;
    height: 100%;
    min-height: 1rem;
  }

  .skeleton__indicator {
    flex: 1 1 auto;
    background: var(--color);
    border-radius: var(--border-radius);
  }

  .skeleton--sheen .skeleton__indicator {
    background: linear-gradient(270deg, var(--sheen-color), var(--color), var(--color), var(--sheen-color));
    background-size: 400% 100%;
    background-size: 400% 100%;
    animation: sheen 8s ease-in-out infinite;
  }

  .skeleton--pulse .skeleton__indicator {
    animation: pulse 2s ease-in-out 0.5s infinite;
  }

  @keyframes sheen {
    0% {
      background-position: 200% 0;
    }
    to {
      background-position: -200% 0;
    }
  }

  @keyframes pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.4;
    }
    100% {
      opacity: 1;
    }
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LFCTWBU7.js
var SlSkeleton = class extends s4 {
  constructor() {
    super(...arguments);
    this.effect = "none";
  }
  render() {
    return $`
      <div
        part="base"
        class=${o6({
      skeleton: true,
      "skeleton--pulse": this.effect === "pulse",
      "skeleton--sheen": this.effect === "sheen"
    })}
        aria-busy="true"
        aria-live="polite"
      >
        <div part="indicator" class="skeleton__indicator"></div>
      </div>
    `;
  }
};
SlSkeleton.styles = skeleton_styles_default;
__decorateClass([
  e4()
], SlSkeleton.prototype, "effect", 2);
SlSkeleton = __decorateClass([
  n5("sl-skeleton")
], SlSkeleton);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/CodedTextElement.js
var __decorate7 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var CodedTextElement = class extends EhrElement {
  constructor() {
    super(...arguments);
    this.terminology = "local";
    this.value = "";
  }
  getDisplay(value) {
    if (typeof value === "string") {
      return value;
    }
    if (value === null || value === void 0 ? void 0 : value.value) {
      return value.value;
    }
    return "";
  }
};
__decorate7([
  property({ type: Object })
], CodedTextElement.prototype, "data", void 0);
__decorate7([
  property({ type: String })
], CodedTextElement.prototype, "terminology", void 0);
__decorate7([
  property({ type: String })
], CodedTextElement.prototype, "value", void 0);
__decorate7([
  event("mb-input")
], CodedTextElement.prototype, "_mbInput", void 0);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DIQYRTQ3.js
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  if (false) {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (middleware.filter((_ref) => {
      let {
        name
      } = _ref;
      return name === "autoPlacement" || name === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  const skippedMiddlewareNames = /* @__PURE__ */ new Set();
  let _debug_loop_count_ = 0;
  for (let i5 = 0; i5 < middleware.length; i5++) {
    if (false) {
      _debug_loop_count_++;
      if (_debug_loop_count_ > 100) {
        throw new Error(["Floating UI: The middleware lifecycle appears to be", "running in an infinite loop. This is usually caused by a `reset`", "continually being returned without a break condition."].join(" "));
      }
    }
    const {
      name,
      fn
    } = middleware[i5];
    if (skippedMiddlewareNames.has(name)) {
      continue;
    }
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset) {
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        if (reset.skip !== false) {
          skippedMiddlewareNames.add(name);
        }
      }
      i5 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return __spreadProps(__spreadValues({}, rect), {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary
  }));
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? __spreadProps(__spreadValues({}, rects.floating), {
      x: x2,
      y: y2
    }) : rects.reference,
    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const _a2 = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true
      } = _a2, detectOverflowOptions = __objRest(_a2, [
        "mainAxis",
        "crossAxis",
        "fallbackPlacements",
        "fallbackStrategy",
        "flipAlignment"
      ]);
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              skip: false,
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a4, b2) => a4.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function convertValueToCoords(placement, rects, value, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  let crossAxisMulti = 1;
  if (alignment === "end") {
    crossAxisMulti = -1;
  }
  if (rtl && isVertical) {
    crossAxisMulti *= -1;
  }
  const rawValue = typeof value === "function" ? value(__spreadProps(__spreadValues({}, rects), {
    placement
  })) : value;
  const {
    mainAxis,
    crossAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0
  } : __spreadValues({
    mainAxis: 0,
    crossAxis: 0
  }, rawValue);
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        platform: platform2,
        elements
      } = middlewareArguments;
      const diffCoords = convertValueToCoords(placement, rects, value, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement
      } = middlewareArguments;
      const _a2 = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x22,
              y: y22
            } = _ref;
            return {
              x: x22,
              y: y22
            };
          }
        }
      } = _a2, detectOverflowOptions = __objRest(_a2, [
        "mainAxis",
        "crossAxis",
        "limiter"
      ]);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, middlewareArguments), {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return __spreadProps(__spreadValues({}, limitedCoords), {
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      });
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(middlewareArguments) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = middlewareArguments;
      const _a2 = options, {
        apply
      } = _a2, detectOverflowOptions = __objRest(_a2, [
        "apply"
      ]);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const xMin = max(overflow.left, 0);
      const xMax = max(overflow.right, 0);
      const yMin = max(overflow.top, 0);
      const yMax = max(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])
      };
      apply == null ? void 0 : apply(__spreadValues(__spreadValues({}, dimensions), rects));
      return {
        reset: {
          rects: true
        }
      };
    }
  };
};
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css2 = getComputedStyle$1(element);
  return css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].includes(css2.willChange) || isFirefox && css2.willChange === "filter" || isFirefox && (css2.filter ? css2.filter !== "none" : false);
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect.width / scaleX,
    height: clientRect.height / scaleY,
    top: clientRect.top / scaleY,
    right: clientRect.right / scaleX,
    bottom: clientRect.bottom / scaleY,
    left: clientRect.left / scaleX,
    x: clientRect.left / scaleX,
    y: clientRect.top / scaleY
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isWindow(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return __spreadProps(__spreadValues({}, rect), {
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  });
}
function getViewportRect(element) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max2(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max2(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body || html2).direction === "rtl") {
    x2 += max2(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getNearestOverflowAncestor(node) {
  if (["html", "body", "#document"].includes(getNodeName(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isOverflowElement(node)) {
    return node;
  }
  return getNearestOverflowAncestor(getParentNode(node));
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(getOverflowAncestors(getParentNode(target)));
}
function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element) {
  const clientRect = getBoundingClientRect(element);
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingAncestor(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref;
  const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: __spreadProps(__spreadValues({}, getDimensions(floating)), {
        x: 0,
        y: 0
      })
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize: _elementResize = true,
    animationFrame = false
  } = options;
  let cleanedUp = false;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const elementResize = _elementResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    observer = new ResizeObserver(update);
    isElement(reference) && observer.observe(reference);
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    if (cleanedUp) {
      return;
    }
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  return () => {
    var _observer;
    cleanedUp = true;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => computePosition(reference, floating, __spreadValues({
  platform
}, options));

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2BK5N6NV.js
var dropdown_styles_default = r`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .dropdown {
    position: relative;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__positioner {
    position: absolute;
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    box-shadow: var(--sl-shadow-large);
    overflow: auto;
    overscroll-behavior: none;
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    pointer-events: all;
  }

  .dropdown__positioner[data-placement^='top'] .dropdown__panel {
    transform-origin: bottom;
  }

  .dropdown__positioner[data-placement^='bottom'] .dropdown__panel {
    transform-origin: top;
  }

  .dropdown__positioner[data-placement^='left'] .dropdown__panel {
    transform-origin: right;
  }

  .dropdown__positioner[data-placement^='right'] .dropdown__panel {
    transform-origin: left;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SCUNOITN.js
function isTabbable(el) {
  const tag = el.tagName.toLowerCase();
  if (el.getAttribute("tabindex") === "-1") {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") !== "false") {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) {
    return false;
  }
  if (el.offsetParent === null) {
    return false;
  }
  if (window.getComputedStyle(el).visibility === "hidden") {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
    return true;
  }
  return ["button", "input", "select", "textarea", "a", "audio", "video", "summary"].includes(tag);
}
function getTabbableBoundary(root) {
  var _a2, _b;
  const allElements = [];
  function walk(el) {
    if (el instanceof HTMLElement) {
      allElements.push(el);
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    [...el.querySelectorAll("*")].forEach((e6) => walk(e6));
  }
  walk(root);
  const start = (_a2 = allElements.find((el) => isTabbable(el))) != null ? _a2 : null;
  const end = (_b = allElements.reverse().find((el) => isTabbable(el))) != null ? _b : null;
  return { start, end };
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.H262HIXG.js
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset2 = getOffset(element, container);
  const offsetTop = offset2.top + container.scrollTop;
  const offsetLeft = offset2.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.YBI4N56R.js
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function prefersReducedMotion() {
  const query2 = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query2.matches;
}
function stopAnimations(el) {
  return Promise.all(el.getAnimations().map((animation) => {
    return new Promise((resolve) => {
      const handleAnimationEvent = requestAnimationFrame(resolve);
      animation.addEventListener("cancel", () => handleAnimationEvent, { once: true });
      animation.addEventListener("finish", () => handleAnimationEvent, { once: true });
      animation.cancel();
    });
  }));
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6SAGALY4.js
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return customAnimation[animationName];
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return defaultAnimation;
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QDIDEMYF.js
var SlDropdown = class extends s4 {
  constructor() {
    super(...arguments);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.handleMenuItemActivate = this.handleMenuItemActivate.bind(this);
    this.handlePanelSelect = this.handlePanelSelect.bind(this);
    this.handleDocumentKeyDown = this.handleDocumentKeyDown.bind(this);
    this.handleDocumentMouseDown = this.handleDocumentMouseDown.bind(this);
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  async firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      await this.updateComplete;
      this.startPositioner();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.hide();
    this.stopPositioner();
  }
  focusOnTrigger() {
    const slot = this.trigger.querySelector("slot");
    const trigger = slot.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    const slot = this.panel.querySelector("slot");
    return slot.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleDocumentKeyDown(event2) {
    var _a2;
    if (event2.key === "Escape") {
      this.hide();
      this.focusOnTrigger();
      return;
    }
    if (event2.key === "Tab") {
      if (this.open && ((_a2 = document.activeElement) == null ? void 0 : _a2.tagName.toLowerCase()) === "sl-menu-item") {
        event2.preventDefault();
        this.hide();
        this.focusOnTrigger();
        return;
      }
      setTimeout(() => {
        var _a22, _b, _c;
        const activeElement = ((_a22 = this.containingElement) == null ? void 0 : _a22.getRootNode()) instanceof ShadowRoot ? (_c = (_b = document.activeElement) == null ? void 0 : _b.shadowRoot) == null ? void 0 : _c.activeElement : document.activeElement;
        if (!this.containingElement || (activeElement == null ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {
          this.hide();
        }
      });
    }
  }
  handleDocumentMouseDown(event2) {
    const path = event2.composedPath();
    if (this.containingElement && !path.includes(this.containingElement)) {
      this.hide();
    }
  }
  handleMenuItemActivate(event2) {
    const item = event2.target;
    scrollIntoView(item, this.panel);
  }
  handlePanelSelect(event2) {
    const target = event2.target;
    if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
      this.hide();
      this.focusOnTrigger();
    }
  }
  handlePopoverOptionsChange() {
    this.updatePositioner();
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
    }
  }
  handleTriggerKeyDown(event2) {
    const menu = this.getMenu();
    const menuItems = menu.defaultSlot.assignedElements({ flatten: true });
    const firstMenuItem = menuItems[0];
    const lastMenuItem = menuItems[menuItems.length - 1];
    if (event2.key === "Escape") {
      this.focusOnTrigger();
      this.hide();
      return;
    }
    if ([" ", "Enter"].includes(event2.key)) {
      event2.preventDefault();
      this.handleTriggerClick();
      return;
    }
    if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event2.key)) {
      event2.preventDefault();
      if (!this.open) {
        this.show();
      }
      requestAnimationFrame(() => {
        if (event2.key === "ArrowDown" || event2.key === "Home") {
          menu.setCurrentItem(firstMenuItem);
          firstMenuItem.focus();
        }
        if (event2.key === "ArrowUp" || event2.key === "End") {
          menu.setCurrentItem(lastMenuItem);
          lastMenuItem.focus();
        }
      });
    }
    const ignoredKeys = ["Tab", "Shift", "Meta", "Ctrl", "Alt"];
    if (this.open && !ignoredKeys.includes(event2.key)) {
      menu.typeToSelect(event2);
    }
  }
  handleTriggerKeyUp(event2) {
    if (event2.key === " ") {
      event2.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  updateAccessibleTrigger() {
    const slot = this.trigger.querySelector("slot");
    const assignedElements = slot.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary(el).start);
    if (accessibleTrigger) {
      accessibleTrigger.setAttribute("aria-haspopup", "true");
      accessibleTrigger.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  reposition() {
    this.updatePositioner();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      emit(this, "sl-show");
      this.panel.addEventListener("sl-activate", this.handleMenuItemActivate);
      this.panel.addEventListener("sl-select", this.handlePanelSelect);
      document.addEventListener("keydown", this.handleDocumentKeyDown);
      document.addEventListener("mousedown", this.handleDocumentMouseDown);
      await stopAnimations(this);
      this.startPositioner();
      this.panel.hidden = false;
      const { keyframes, options } = getAnimation(this, "dropdown.show");
      await animateTo(this.panel, keyframes, options);
      emit(this, "sl-after-show");
    } else {
      emit(this, "sl-hide");
      this.panel.removeEventListener("sl-activate", this.handleMenuItemActivate);
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
      document.removeEventListener("mousedown", this.handleDocumentMouseDown);
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "dropdown.hide");
      await animateTo(this.panel, keyframes, options);
      this.panel.hidden = true;
      this.stopPositioner();
      emit(this, "sl-after-hide");
    }
  }
  startPositioner() {
    this.stopPositioner();
    this.updatePositioner();
    this.positionerCleanup = autoUpdate(this.trigger, this.positioner, this.updatePositioner.bind(this));
  }
  updatePositioner() {
    if (!this.open || !this.trigger || !this.positioner) {
      return;
    }
    computePosition2(this.trigger, this.positioner, {
      placement: this.placement,
      middleware: [
        offset({ mainAxis: this.distance, crossAxis: this.skidding }),
        flip(),
        shift(),
        size({
          apply: ({ width, height }) => {
            Object.assign(this.panel.style, {
              maxWidth: `${width}px`,
              maxHeight: `${height}px`
            });
          },
          padding: 8
        })
      ],
      strategy: this.hoist ? "fixed" : "absolute"
    }).then(({ x: x2, y: y2, placement }) => {
      this.positioner.setAttribute("data-placement", placement);
      Object.assign(this.positioner.style, {
        position: this.hoist ? "fixed" : "absolute",
        left: `${x2}px`,
        top: `${y2}px`
      });
    });
  }
  stopPositioner() {
    if (this.positionerCleanup) {
      this.positionerCleanup();
      this.positionerCleanup = void 0;
      this.positioner.removeAttribute("data-placement");
    }
  }
  render() {
    return $`
      <div
        part="base"
        id="dropdown"
        class=${o6({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <span
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
        >
          <slot name="trigger" @slotchange=${this.handleTriggerSlotChange}></slot>
        </span>

        <!-- Position the panel with a wrapper since the popover makes use of translate. This let's us add animations
        on the panel without interfering with the position. -->
        <div class="dropdown__positioner">
          <div
            part="panel"
            class="dropdown__panel"
            aria-hidden=${this.open ? "false" : "true"}
            aria-labelledby="dropdown"
          >
            <slot></slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlDropdown.styles = dropdown_styles_default;
__decorateClass([
  i22(".dropdown__trigger")
], SlDropdown.prototype, "trigger", 2);
__decorateClass([
  i22(".dropdown__panel")
], SlDropdown.prototype, "panel", 2);
__decorateClass([
  i22(".dropdown__positioner")
], SlDropdown.prototype, "positioner", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlDropdown.prototype, "open", 2);
__decorateClass([
  e4({ reflect: true })
], SlDropdown.prototype, "placement", 2);
__decorateClass([
  e4({ type: Boolean })
], SlDropdown.prototype, "disabled", 2);
__decorateClass([
  e4({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass([
  e4({ attribute: false })
], SlDropdown.prototype, "containingElement", 2);
__decorateClass([
  e4({ type: Number })
], SlDropdown.prototype, "distance", 2);
__decorateClass([
  e4({ type: Number })
], SlDropdown.prototype, "skidding", 2);
__decorateClass([
  e4({ type: Boolean })
], SlDropdown.prototype, "hoist", 2);
__decorateClass([
  watch2("distance"),
  watch2("hoist"),
  watch2("placement"),
  watch2("skidding")
], SlDropdown.prototype, "handlePopoverOptionsChange", 1);
__decorateClass([
  watch2("open", { waitUntilFirstUpdate: true })
], SlDropdown.prototype, "handleOpenChange", 1);
SlDropdown = __decorateClass([
  n5("sl-dropdown")
], SlDropdown);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, transform: "scale(0.9)" },
    { opacity: 1, transform: "scale(1)" }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, transform: "scale(1)" },
    { opacity: 0, transform: "scale(0.9)" }
  ],
  options: { duration: 100, easing: "ease" }
});

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/dropdown.js
var __decorate8 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbDropDown = class MbDropDown2 extends SlDropdown {
  handleTriggerClick() {
    console.log("trigger click triggered");
    if (this.open) {
    } else {
      this.show();
    }
  }
  handleTriggerKeyDown(event2) {
    const menu = this.getMenu();
    const menuItems = menu ? [...menu.querySelectorAll("sl-menu-item")] : [];
    const firstMenuItem = menuItems[0];
    const lastMenuItem = menuItems[menuItems.length - 1];
    if (event2.key === "Escape") {
      this.focusOnTrigger();
      this.hide();
      return;
    }
    if (["Enter"].includes(event2.key)) {
      event2.preventDefault();
      this.handleTriggerClick();
      return;
    }
    if (["ArrowDown", "ArrowUp"].includes(event2.key)) {
      event2.preventDefault();
      if (!this.open) {
        this.show();
      }
      if (event2.key === "ArrowDown" && firstMenuItem) {
        menu === null || menu === void 0 ? void 0 : menu.setCurrentItem(firstMenuItem);
        firstMenuItem.focus();
        return;
      }
      if (event2.key === "ArrowUp" && lastMenuItem) {
        menu === null || menu === void 0 ? void 0 : menu.setCurrentItem(lastMenuItem);
        lastMenuItem.focus();
      }
    }
  }
};
__decorate8([
  property()
], MbDropDown.prototype, "searchElement", void 0);
MbDropDown = __decorate8([
  customElement("mb-dropdown")
], MbDropDown);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/abstractSearch.js
var __decorate9 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbSearchAbstract = class extends CodedTextElement {
  constructor() {
    super(...arguments);
    this._cancelledFilters = [];
    this.mock = [];
    this.debounceInterval = 150;
    this.hits = 10;
    this.placeholder = "Type to search";
    this.id = "search";
    this.textFallbackLabel = "Add custom";
    this.filtersLabel = "Filters";
    this.errorMessage = "An unexpected error occurred";
    this.disablefallback = false;
    this.disablesearch = false;
    this.required = false;
    this.hoist = false;
    this.fixfilters = false;
    this.filterType = "or";
    this._moreHits = 0;
    this._debouncing = false;
  }
  get _maxHits() {
    return this.hits + this._moreHits;
  }
  _searchTermChange() {
    clearTimeout(this._debounceTimeout);
    this._debouncing = true;
    this._debounceTimeout = window.setTimeout(() => {
      this._debouncing = false;
    }, this.debounceInterval);
  }
  _handleInput(e6) {
    const inputElement = e6.target;
    this.searchTerm = inputElement.value;
    this.dropdown.show();
    this._emitSearchEvent();
  }
  _emitSearchEvent() {
    const searchOptions = {
      maxHits: this._maxHits,
      searchString: this.searchTerm,
      terminology: this.terminology,
      constraints: this._selectedFilters
    };
    this._mbSearch.emit({ detail: searchOptions });
  }
  get _selectedFilters() {
    var _a2, _b;
    const filters = (_b = (_a2 = this._filters) === null || _a2 === void 0 ? void 0 : _a2.filter((filter) => !filter.disabled)) === null || _b === void 0 ? void 0 : _b.map((filter) => filter.value);
    return filters;
  }
  get _viewMore() {
    return html` <div class="more">
      <sl-button
        variant="text"
        @click=${() => {
      this._moreHits += 10;
    }}
        >More</sl-button
      >
      ${this._maxHits > this.hits ? html`<sl-button
            variant="text"
            @click=${() => {
      this._moreHits -= 10;
    }}
            >Less</sl-button
          >` : null}
    </div>`;
  }
  transformResult(result) {
    return result;
  }
  async getResults() {
    if (this.mock.length) {
      return {
        result: this.mock.map((r6) => html`<sl-menu-item .value=${{ code: r6, value: r6 }}
              ><p>${r6}</p></sl-menu-item
            >`)
      };
    }
    if (!this.searchTerm) {
      return {
        result: []
      };
    }
    try {
      const result = await this.handleSearch({
        searchString: this.searchTerm,
        terminology: this.terminology,
        constraints: this._selectedFilters,
        maxHits: this._maxHits
      });
      const results = result.map((r6) => html`
            <sl-menu-item .value=${r6}> ${r6.value || r6.text} </sl-menu-item>
          `);
      return {
        result: this._maxHits === results.length ? [...results, this._viewMore] : results
      };
    } catch (e6) {
      return {
        result: [],
        error: this.errorMessage
      };
    }
  }
  async _results() {
    if (!this.searchTerm) {
      return;
    }
    if (this._debouncing) {
      return this._loadingResults();
    }
    const { result, error } = await this.getResults();
    if (error) {
      return html`<sl-menu-item disabled>
        <sl-icon
          name="exclamation-triangle"
          slot="prefix"
          library="medblocks"
        ></sl-icon>
        ${error}
      </sl-menu-item>`;
    }
    if (this.searchTerm && result.length === 0) {
      return html`<sl-menu-label>No results</sl-menu-label>`;
    }
    return result;
  }
  _textFallback() {
    return html`<sl-divider></sl-divider>
      <sl-menu-item .value=${{ text: this.searchTerm }}
        ><span slot="suffix" style="font-size: small;"
          >${this.textFallbackLabel}</span
        >${this.searchTerm}</sl-menu-item
      >`;
  }
  _loadingResults() {
    const skeletons = 5;
    return html`${[...Array(skeletons)].map(() => html` <sl-menu-item disabled class="loading">
        <sl-skeleton effect="sheen"></sl-skeleton>
      </sl-menu-item>`)}`;
  }
  _handleSlSelect(e6) {
    const menuItem = e6.detail.item;
    this.searchTerm = "";
    if (menuItem.value) {
      return this._handleSelect(menuItem.value, menuItem);
    }
  }
  _handleMouseDown(ev) {
    const path = ev.composedPath();
    if (!path.includes(this) && this.dropdown) {
      this.dropdown.hide();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    const observer = new MutationObserver(() => {
      this._handleChildChange();
    });
    this._handleMouseDown = this._handleMouseDown.bind(this);
    document.addEventListener("mousedown", this._handleMouseDown);
    this.addEventListener("sl-select", this._handleSlSelect);
    observer.observe(this, {
      childList: true,
      subtree: true,
      attributes: true
    });
  }
  disconnectedCallback() {
    this.removeEventListener("sl-select", this._handleSlSelect);
    document.removeEventListener("mousedown", this._handleMouseDown);
    super.disconnectedCallback();
  }
  _handleChildChange() {
    this._filters = [
      ...this.querySelectorAll("mb-filter")
    ];
  }
  _handleClear() {
    this.data = void 0;
    this._moreHits = 0;
    this._mbInput.emit();
  }
  _handleFilterClick(tag, tags) {
    if (this.filterType === "and") {
      for (const t5 of tags) {
        t5.disabled = true;
      }
      tag.disabled = false;
    } else {
      tag.disabled = !tag.disabled;
    }
    this._emitSearchEvent();
  }
  reportValidity() {
    var _a2, _b;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-input");
    if (this.searchTerm) {
      input.setCustomValidity("Please select a value from dropdown");
      return input.reportValidity();
    }
    if (typeof this.data !== "string" && ((_b = this.data) === null || _b === void 0 ? void 0 : _b.length))
      return true;
    return input.reportValidity();
  }
  _showResults() {
    if (this._hasValue) {
      return false;
    }
    if (this.searchTerm) {
      return true;
    }
    if (this.show) {
      return true;
    }
    return false;
  }
  _searchBar() {
    var _a2, _b, _c;
    return html`
      <mb-dropdown
        .containingElement=${this}
        .hoist=${this.hoist}
        .open=${true}
        .focusKeys=${["Enter"]}
        .typeToSelect=${false}
        @sl-after-hide=${() => {
      this._cancelledFilters = [];
    }}
      >
        <sl-input
          id=${this.id}
          class=${classMap({ pointer: this._hasValue })}
          slot="trigger"
          ?required=${this.required}
          .size=${this.variant === "small" ? "small" : "medium"}
          .disabled=${this.disabled}
          .label=${this.label || ""}
          @sl-input=${this._handleInput}
          value=${ifDefined((_b = (_a2 = this._display) !== null && _a2 !== void 0 ? _a2 : this.searchTerm) !== null && _b !== void 0 ? _b : "")}
          ?readonly=${this._hasValue}
          ?clearable=${this._hasValue}
          @sl-clear=${this._handleClear}
          placeholder=${this.placeholder}
          autocomplete="off"
        >
          ${this._hasValue ? null : html`<sl-icon
                library="medblocks"
                name="search"
                slot="prefix"
              ></sl-icon>`}
        </sl-input>
        ${this._showResults() ? html`
              <sl-menu style="min-width:300px; width:fit-content;">
                ${this.disablesearch ? null : until(this._results())}
                <slot name="results"></slot>
                ${this.disablefallback ? null : this._textFallback()}
                ${((_c = this._filters) === null || _c === void 0 ? void 0 : _c.length) > 0 && !this.fixfilters ? html` <sl-divider></sl-divider>
                      <sl-menu-label>Filters</sl-menu-label>
                      <div class="tags">
                        ${this._filters.map((f3) => html`<sl-tag
                              ?removable=${this.filterType === "or" && !f3.disabled}
                              size=${this.variant === "small" ? "small" : "medium"}
                              variant=${f3.disabled ? "neutral" : "primary"}
                              @click=${() => this._handleFilterClick(f3, this._filters)}
                              >${f3.label}</sl-tag
                            >`)}
                      </div>` : null}
              </sl-menu>
            ` : null}
      </mb-dropdown>
      <slot @slotchange=${this._handleChildChange}></slot>
    `;
  }
  get _hasValue() {
    var _a2, _b;
    return !!(((_a2 = this === null || this === void 0 ? void 0 : this.data) === null || _a2 === void 0 ? void 0 : _a2.value) && ((_b = this === null || this === void 0 ? void 0 : this.data) === null || _b === void 0 ? void 0 : _b.code) || typeof this.data === "string" && this.data !== "");
  }
  get _display() {
    var _a2;
    if (typeof this.data === "string") {
      return this.data;
    }
    return this._hasValue ? (_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.value : void 0;
  }
  get _code() {
    var _a2;
    return this._hasValue ? (_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.code : void 0;
  }
};
MbSearchAbstract.styles = css`
    :host,
    mb-dropdown {
      display: block;
    }

    sl-input.pointer::part(base) {
      cursor: default;
    }

    .tags {
      padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
    }

    .more {
      display: flex;
      justify-content: space-between;
      padding: var(--sl-spacing-3x-small) var(--sl-spacing-small);
    }
    .tags sl-tag {
      padding: var(--sl-spacing-2x-small);
    }

    sl-tag::part(base) {
      cursor: pointer;
    }
  `;
__decorate9([
  property({ type: String })
], MbSearchAbstract.prototype, "searchTerm", void 0);
__decorate9([
  property({ type: Boolean })
], MbSearchAbstract.prototype, "show", void 0);
__decorate9([
  property({ type: Array })
], MbSearchAbstract.prototype, "_filters", void 0);
__decorate9([
  property({ type: Array })
], MbSearchAbstract.prototype, "_cancelledFilters", void 0);
__decorate9([
  property({ type: Array })
], MbSearchAbstract.prototype, "mock", void 0);
__decorate9([
  property({ type: Number })
], MbSearchAbstract.prototype, "debounceInterval", void 0);
__decorate9([
  property({ type: Number })
], MbSearchAbstract.prototype, "hits", void 0);
__decorate9([
  property({ type: String, reflect: true })
], MbSearchAbstract.prototype, "placeholder", void 0);
__decorate9([
  property({ type: String, reflect: true })
], MbSearchAbstract.prototype, "id", void 0);
__decorate9([
  property({ type: String })
], MbSearchAbstract.prototype, "textFallbackLabel", void 0);
__decorate9([
  property({ type: String })
], MbSearchAbstract.prototype, "filtersLabel", void 0);
__decorate9([
  property({ type: String })
], MbSearchAbstract.prototype, "errorMessage", void 0);
__decorate9([
  property({ type: Boolean })
], MbSearchAbstract.prototype, "disablefallback", void 0);
__decorate9([
  property({ type: Boolean, reflect: true })
], MbSearchAbstract.prototype, "disablesearch", void 0);
__decorate9([
  property({ type: Boolean, reflect: true })
], MbSearchAbstract.prototype, "required", void 0);
__decorate9([
  property({ type: Boolean, reflect: true })
], MbSearchAbstract.prototype, "hoist", void 0);
__decorate9([
  property({ type: Boolean, reflect: true })
], MbSearchAbstract.prototype, "fixfilters", void 0);
__decorate9([
  property({ type: Boolean, reflect: true })
], MbSearchAbstract.prototype, "disabled", void 0);
__decorate9([
  property({ type: String, attribute: "filter-type", reflect: true })
], MbSearchAbstract.prototype, "filterType", void 0);
__decorate9([
  state()
], MbSearchAbstract.prototype, "_moreHits", void 0);
__decorate9([
  state()
], MbSearchAbstract.prototype, "_debouncing", void 0);
__decorate9([
  state()
], MbSearchAbstract.prototype, "_debounceTimeout", void 0);
__decorate9([
  watch("searchTerm")
], MbSearchAbstract.prototype, "_searchTermChange", null);
__decorate9([
  event("mb-search")
], MbSearchAbstract.prototype, "_mbSearch", void 0);
__decorate9([
  query("mb-dropdown")
], MbSearchAbstract.prototype, "dropdown", void 0);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/search.js
var __decorate10 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbSearch = class MbSearch2 extends MbSearchAbstract {
  _handleSelect(data, menuItem) {
    if (data.text) {
      this.data = data.text;
    } else {
      this.data = {
        code: data.code,
        value: data.value,
        terminology: data.terminology
      };
    }
    this._mbInput.emit({ detail: { item: menuItem } });
  }
  render() {
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${this.getDisplay(this.data) || "-"}</p>
      </div>`;
    }
    return this._searchBar();
  }
};
MbSearch = __decorate10([
  customElement("mb-search")
], MbSearch);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LAAROFAU.js
var form_control_styles_default = r`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control_label {
    font-size: var(--sl-input-label-font-size-large);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
  }

  .form-control--has-help-text .form-control__help-text ::slotted(*) {
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.24E5KUVH.js
var select_styles_default = r`
  ${component_styles_default}
  ${form_control_styles_default}

  :host {
    display: block;
  }

  .select {
    display: block;
  }

  .select__control {
    display: inline-flex;
    align-items: center;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    transition: var(--sl-transition-fast) color, var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .select__menu {
    max-height: 50vh;
    overflow: auto;
  }

  /* Standard selects */
  .select--standard .select__control {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    color: var(--sl-input-color);
  }

  .select--standard:not(.select--disabled) .select__control:hover {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
    color: var(--sl-input-color-hover);
  }

  .select--standard.select--focused:not(.select--disabled) .select__control {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: var(--sl-focus-ring);
    outline: none;
    color: var(--sl-input-color-focus);
  }

  .select--standard.select--disabled .select__control {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  /* Filled selects */
  .select--filled .select__control {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__control {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--focused:not(.select--disabled) .select__control {
    outline: none;
    background-color: var(--sl-input-filled-background-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  .select--filled.select--disabled .select__control {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--disabled .select__tags,
  .select--disabled .select__clear {
    pointer-events: none;
  }

  .select__prefix {
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  .select__label {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
    user-select: none;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .select__label::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .select__clear {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    width: 1.25em;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__suffix {
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  .select__icon {
    flex: 0 0 auto;
    display: inline-flex;
    transition: var(--sl-transition-medium) transform ease;
  }

  .select--open .select__icon {
    transform: rotate(-180deg);
  }

  /* Placeholder */
  .select--placeholder-visible .select__label {
    color: var(--sl-input-placeholder-color);
  }

  .select--disabled.select--placeholder-visible .select__label {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Tags */
  .select__tags {
    display: inline-flex;
    align-items: center;
    flex-wrap: wrap;
    justify-content: left;
    margin-left: var(--sl-spacing-2x-small);
  }

  /* Hidden input (for form control validation to show) */
  .select__hidden-select {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    overflow: hidden;
    white-space: nowrap;
  }

  /*
   * Size modifiers
   */

  /* Small */
  .select--small .select__control {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
  }

  .select--small .select__prefix ::slotted(*) {
    margin-left: var(--sl-input-spacing-small);
  }

  .select--small .select__label {
    margin: 0 var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-right: var(--sl-input-spacing-small);
  }

  .select--small .select__suffix ::slotted(*) {
    margin-right: var(--sl-input-spacing-small);
  }

  .select--small .select__icon {
    margin-right: var(--sl-input-spacing-small);
  }

  .select--small .select__tags {
    padding-bottom: 2px;
  }

  .select--small .select__tags sl-tag {
    padding-top: 2px;
  }

  .select--small .select__tags sl-tag:not(:last-of-type) {
    margin-right: var(--sl-spacing-2x-small);
  }

  .select--small.select--has-tags .select__label {
    margin-left: 0;
  }

  /* Medium */
  .select--medium .select__control {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
  }

  .select--medium .select__prefix ::slotted(*) {
    margin-left: var(--sl-input-spacing-medium);
  }

  .select--medium .select__label {
    margin: 0 var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-right: var(--sl-input-spacing-medium);
  }

  .select--medium .select__suffix ::slotted(*) {
    margin-right: var(--sl-input-spacing-medium);
  }

  .select--medium .select__icon {
    margin-right: var(--sl-input-spacing-medium);
  }

  .select--medium .select__tags {
    padding-bottom: 3px;
  }

  .select--medium .select__tags sl-tag {
    padding-top: 3px;
  }

  .select--medium .select__tags sl-tag:not(:last-of-type) {
    margin-right: var(--sl-spacing-2x-small);
  }

  .select--medium.select--has-tags .select__label {
    margin-left: 0;
  }

  /* Large */
  .select--large .select__control {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
  }

  .select--large .select__prefix ::slotted(*) {
    margin-left: var(--sl-input-spacing-large);
  }

  .select--large .select__label {
    margin: 0 var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-right: var(--sl-input-spacing-large);
  }

  .select--large .select__suffix ::slotted(*) {
    margin-right: var(--sl-input-spacing-large);
  }

  .select--large .select__icon {
    margin-right: var(--sl-input-spacing-large);
  }

  .select--large .select__tags {
    padding-bottom: 4px;
  }
  .select--large .select__tags sl-tag {
    padding-top: 4px;
  }

  .select--large .select__tags sl-tag:not(:last-of-type) {
    margin-right: var(--sl-spacing-2x-small);
  }

  .select--large.select--has-tags .select__label {
    margin-left: 0;
  }

  /*
   * Pill modifier
   */
  .select--pill.select--small .select__control {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__control {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__control {
    border-radius: var(--sl-input-height-large);
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZHPXFQWE.js
var FormDataEventPolyfill = class extends Event {
  constructor(formData) {
    super("formdata");
    this.formData = formData;
  }
};
var FormDataPolyfill = class extends FormData {
  constructor(form) {
    super(form);
    this.form = form;
    form.dispatchEvent(new FormDataEventPolyfill(this));
  }
  append(name, value) {
    let input = this.form.elements[name];
    if (!input) {
      input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      this.form.appendChild(input);
    }
    if (this.has(name)) {
      const entries = this.getAll(name);
      const index = entries.indexOf(input.value);
      if (index !== -1) {
        entries.splice(index, 1);
      }
      entries.push(value);
      this.set(name, entries);
    } else {
      super.append(name, value);
    }
    input.value = value;
  }
};
function supportsFormDataEvent() {
  const form = document.createElement("form");
  let isSupported = false;
  document.body.append(form);
  form.addEventListener("submit", (event2) => {
    new FormData(event2.target);
    event2.preventDefault();
  });
  form.addEventListener("formdata", () => isSupported = true);
  form.dispatchEvent(new Event("submit", { cancelable: true }));
  form.remove();
  return isSupported;
}
function polyfillFormData() {
  if (!window.FormData || supportsFormDataEvent()) {
    return;
  }
  window.FormData = FormDataPolyfill;
  window.addEventListener("submit", (event2) => {
    if (!event2.defaultPrevented) {
      new FormData(event2.target);
    }
  });
}
if (document.readyState === "complete") {
  polyfillFormData();
} else {
  window.addEventListener("DOMContentLoaded", () => polyfillFormData());
}
var FormSubmitController = class {
  constructor(host, options) {
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: (input) => input.closest("form"),
      name: (input) => input.name,
      value: (input) => input.value,
      disabled: (input) => input.disabled,
      reportValidity: (input) => {
        return typeof input.reportValidity === "function" ? input.reportValidity() : true;
      }
    }, options);
    this.handleFormData = this.handleFormData.bind(this);
    this.handleFormSubmit = this.handleFormSubmit.bind(this);
  }
  hostConnected() {
    this.form = this.options.form(this.host);
    if (this.form) {
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
    }
  }
  hostDisconnected() {
    if (this.form) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form = void 0;
    }
  }
  handleFormData(event2) {
    const disabled = this.options.disabled(this.host);
    const name = this.options.name(this.host);
    const value = this.options.value(this.host);
    if (!disabled && typeof name === "string" && typeof value !== "undefined") {
      if (Array.isArray(value)) {
        value.forEach((val) => {
          event2.formData.append(name, val.toString());
        });
      } else {
        event2.formData.append(name, value.toString());
      }
    }
  }
  handleFormSubmit(event2) {
    const disabled = this.options.disabled(this.host);
    const reportValidity = this.options.reportValidity;
    if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
      event2.preventDefault();
      event2.stopImmediatePropagation();
    }
  }
  submit(submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = "submit";
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clip = "rect(0 0 0 0)";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.formAction = submitter.formAction;
        button.formMethod = submitter.formMethod;
        button.formNoValidate = submitter.formNoValidate;
        button.formTarget = submitter.formTarget;
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
};

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PJFWJ67S.js
var SlSelect = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.hasFocus = false;
    this.isOpen = false;
    this.displayLabel = "";
    this.displayTags = [];
    this.multiple = false;
    this.maxTagsVisible = 3;
    this.disabled = false;
    this.name = "";
    this.placeholder = "";
    this.size = "medium";
    this.hoist = false;
    this.value = "";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.required = false;
    this.clearable = false;
    this.invalid = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.handleMenuSlotChange = this.handleMenuSlotChange.bind(this);
    this.resizeObserver = new ResizeObserver(() => this.resizeMenu());
    this.updateComplete.then(() => {
      this.resizeObserver.observe(this);
      this.syncItemsFromValue();
    });
  }
  firstUpdated() {
    this.invalid = !this.input.checkValidity();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this);
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  getItemLabel(item) {
    const slot = item.shadowRoot.querySelector("slot:not([name])");
    return getTextContent(slot);
  }
  getItems() {
    return [...this.querySelectorAll("sl-menu-item")];
  }
  getValueAsArray() {
    if (this.multiple && this.value === "") {
      return [];
    }
    return Array.isArray(this.value) ? this.value : [this.value];
  }
  focus(options) {
    this.control.focus(options);
  }
  blur() {
    this.control.blur();
  }
  handleBlur() {
    if (!this.isOpen) {
      this.hasFocus = false;
      emit(this, "sl-blur");
    }
  }
  handleClearClick(event2) {
    event2.stopPropagation();
    this.value = this.multiple ? [] : "";
    emit(this, "sl-clear");
    this.syncItemsFromValue();
  }
  handleDisabledChange() {
    if (this.disabled && this.isOpen) {
      this.dropdown.hide();
    }
    this.input.disabled = this.disabled;
    this.invalid = !this.input.checkValidity();
  }
  handleFocus() {
    if (!this.hasFocus) {
      this.hasFocus = true;
      emit(this, "sl-focus");
    }
  }
  handleKeyDown(event2) {
    const target = event2.target;
    const items = this.getItems();
    const firstItem = items[0];
    const lastItem = items[items.length - 1];
    if (target.tagName.toLowerCase() === "sl-tag") {
      return;
    }
    if (event2.key === "Tab") {
      if (this.isOpen) {
        this.dropdown.hide();
      }
      return;
    }
    if (["ArrowDown", "ArrowUp"].includes(event2.key)) {
      event2.preventDefault();
      if (!this.isOpen) {
        this.dropdown.show();
      }
      if (event2.key === "ArrowDown") {
        this.menu.setCurrentItem(firstItem);
        firstItem.focus();
        return;
      }
      if (event2.key === "ArrowUp") {
        this.menu.setCurrentItem(lastItem);
        lastItem.focus();
        return;
      }
    }
    if (event2.ctrlKey || event2.metaKey) {
      return;
    }
    if (!this.isOpen && event2.key.length === 1) {
      event2.stopPropagation();
      event2.preventDefault();
      this.dropdown.show();
      this.menu.typeToSelect(event2);
    }
  }
  handleLabelClick() {
    this.focus();
  }
  handleMenuSelect(event2) {
    const item = event2.detail.item;
    if (this.multiple) {
      this.value = this.value.includes(item.value) ? this.value.filter((v2) => v2 !== item.value) : [...this.value, item.value];
    } else {
      this.value = item.value;
    }
    this.syncItemsFromValue();
  }
  handleMenuShow() {
    this.resizeMenu();
    this.isOpen = true;
  }
  handleMenuHide() {
    this.isOpen = false;
    this.control.focus();
  }
  handleMultipleChange() {
    var _a2;
    const value = this.getValueAsArray();
    this.value = this.multiple ? value : (_a2 = value[0]) != null ? _a2 : "";
    this.syncItemsFromValue();
  }
  async handleMenuSlotChange() {
    const items = this.getItems();
    const values = [];
    items.forEach((item) => {
      if (values.includes(item.value)) {
        console.error(`Duplicate value found in <sl-select> menu item: '${item.value}'`, item);
      }
      values.push(item.value);
    });
    await Promise.all(items.map((item) => item.render)).then(() => this.syncItemsFromValue());
  }
  handleTagInteraction(event2) {
    const path = event2.composedPath();
    const clearButton = path.find((el) => {
      if (el instanceof HTMLElement) {
        const element = el;
        return element.classList.contains("tag__remove");
      }
      return false;
    });
    if (clearButton) {
      event2.stopPropagation();
    }
  }
  async handleValueChange() {
    this.syncItemsFromValue();
    await this.updateComplete;
    this.invalid = !this.input.checkValidity();
    emit(this, "sl-change");
  }
  resizeMenu() {
    this.menu.style.width = `${this.control.clientWidth}px`;
    this.dropdown.reposition();
  }
  syncItemsFromValue() {
    const items = this.getItems();
    const value = this.getValueAsArray();
    items.map((item) => item.checked = value.includes(item.value));
    if (this.multiple) {
      const checkedItems = items.filter((item) => value.includes(item.value));
      this.displayLabel = checkedItems.length > 0 ? this.getItemLabel(checkedItems[0]) : "";
      this.displayTags = checkedItems.map((item) => {
        return $`
          <sl-tag
            part="tag"
            exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button
            "
            variant="neutral"
            size=${this.size}
            ?pill=${this.pill}
            removable
            @click=${this.handleTagInteraction}
            @keydown=${this.handleTagInteraction}
            @sl-remove=${(event2) => {
          event2.stopPropagation();
          if (!this.disabled) {
            item.checked = false;
            this.syncValueFromItems();
          }
        }}
          >
            ${this.getItemLabel(item)}
          </sl-tag>
        `;
      });
      if (this.maxTagsVisible > 0 && this.displayTags.length > this.maxTagsVisible) {
        const total = this.displayTags.length;
        this.displayLabel = "";
        this.displayTags = this.displayTags.slice(0, this.maxTagsVisible);
        this.displayTags.push($`
          <sl-tag
            part="tag"
            exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button
            "
            variant="neutral"
            size=${this.size}
          >
            +${total - this.maxTagsVisible}
          </sl-tag>
        `);
      }
    } else {
      const checkedItem = items.find((item) => item.value === value[0]);
      this.displayLabel = checkedItem ? this.getItemLabel(checkedItem) : "";
      this.displayTags = [];
    }
  }
  syncValueFromItems() {
    const items = this.getItems();
    const checkedItems = items.filter((item) => item.checked);
    const checkedValues = checkedItems.map((item) => item.value);
    if (this.multiple) {
      this.value = this.value.filter((val) => checkedValues.includes(val));
    } else {
      this.value = checkedValues.length > 0 ? checkedValues[0] : "";
    }
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasSelection = this.multiple ? this.value.length > 0 : this.value !== "";
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return $`
      <div
        part="form-control"
        class=${o6({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div class="form-control__input">
          <sl-dropdown
            part="base"
            .hoist=${this.hoist}
            .placement=${this.placement}
            .stayOpenOnSelect=${this.multiple}
            .containingElement=${this}
            ?disabled=${this.disabled}
            class=${o6({
      select: true,
      "select--open": this.isOpen,
      "select--empty": this.value.length === 0,
      "select--focused": this.hasFocus,
      "select--clearable": this.clearable,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--standard": !this.filled,
      "select--filled": this.filled,
      "select--has-tags": this.multiple && this.displayTags.length > 0,
      "select--placeholder-visible": this.displayLabel === "",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large",
      "select--pill": this.pill,
      "select--invalid": this.invalid
    })}
            @sl-show=${this.handleMenuShow}
            @sl-hide=${this.handleMenuHide}
          >
            <div
              part="control"
              slot="trigger"
              id="input"
              class="select__control"
              role="combobox"
              aria-describedby="help-text"
              aria-haspopup="true"
              aria-expanded=${this.isOpen ? "true" : "false"}
              aria-controls="menu"
              tabindex=${this.disabled ? "-1" : "0"}
              @blur=${this.handleBlur}
              @focus=${this.handleFocus}
              @keydown=${this.handleKeyDown}
            >
              <span part="prefix" class="select__prefix">
                <slot name="prefix"></slot>
              </span>

              <div part="display-label" class="select__label">
                ${this.displayTags.length > 0 ? $` <span part="tags" class="select__tags"> ${this.displayTags} </span> ` : this.displayLabel.length > 0 ? this.displayLabel : this.placeholder}
              </div>

              ${this.clearable && hasSelection ? $`
                    <button part="clear-button" class="select__clear" @click=${this.handleClearClick} tabindex="-1">
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <span part="suffix" class="select__suffix">
                <slot name="suffix"></slot>
              </span>

              <span part="icon" class="select__icon" aria-hidden="true">
                <sl-icon name="chevron-down" library="system"></sl-icon>
              </span>

              <!-- The hidden input tricks the browser's built-in validation so it works as expected. We use an input
              instead of a select because, otherwise, iOS will show a list of options during validation. The focus
              handler is used to move focus to the primary control when it's marked invalid.  -->
              <input
                class="select__hidden-select"
                aria-hidden="true"
                ?required=${this.required}
                .value=${hasSelection ? "1" : ""}
                tabindex="-1"
                @focus=${() => this.control.focus()}
              />
            </div>

            <sl-menu part="menu" id="menu" class="select__menu" @sl-select=${this.handleMenuSelect}>
              <slot @slotchange=${this.handleMenuSlotChange}></slot>
            </sl-menu>
          </sl-dropdown>
        </div>

        <div
          part="help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = select_styles_default;
__decorateClass([
  i22(".select")
], SlSelect.prototype, "dropdown", 2);
__decorateClass([
  i22(".select__control")
], SlSelect.prototype, "control", 2);
__decorateClass([
  i22(".select__hidden-select")
], SlSelect.prototype, "input", 2);
__decorateClass([
  i22(".select__menu")
], SlSelect.prototype, "menu", 2);
__decorateClass([
  t3()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass([
  t3()
], SlSelect.prototype, "isOpen", 2);
__decorateClass([
  t3()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass([
  t3()
], SlSelect.prototype, "displayTags", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlSelect.prototype, "multiple", 2);
__decorateClass([
  e4({ attribute: "max-tags-visible", type: Number })
], SlSelect.prototype, "maxTagsVisible", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlSelect.prototype, "disabled", 2);
__decorateClass([
  e4()
], SlSelect.prototype, "name", 2);
__decorateClass([
  e4()
], SlSelect.prototype, "placeholder", 2);
__decorateClass([
  e4()
], SlSelect.prototype, "size", 2);
__decorateClass([
  e4({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass([
  e4()
], SlSelect.prototype, "value", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlSelect.prototype, "filled", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlSelect.prototype, "pill", 2);
__decorateClass([
  e4()
], SlSelect.prototype, "label", 2);
__decorateClass([
  e4()
], SlSelect.prototype, "placement", 2);
__decorateClass([
  e4({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlSelect.prototype, "required", 2);
__decorateClass([
  e4({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlSelect.prototype, "invalid", 2);
__decorateClass([
  watch2("disabled", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch2("multiple")
], SlSelect.prototype, "handleMultipleChange", 1);
__decorateClass([
  watch2("value", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleValueChange", 1);
SlSelect = __decorateClass([
  n5("sl-select")
], SlSelect);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/select.js
var __decorate11 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbSelect = class MbSelect2 extends CodedTextElement {
  constructor() {
    super(...arguments);
    this.placeholder = "Please select";
    this.id = "select";
    this.multiple = false;
    this.required = false;
    this.hoist = false;
    this._options = [];
  }
  getLabel(code) {
    return this._options.filter((option) => option.value === code)[0].label;
  }
  getOrdinal(code) {
    var _a2;
    return ((_a2 = this._options.filter((option) => option.value === code)[0]) === null || _a2 === void 0 ? void 0 : _a2.ordinal) || void 0;
  }
  get _optionElements() {
    return this.querySelectorAll("mb-option");
  }
  handleInput(e6) {
    const select = e6.target;
    if (select.value && typeof select.value === "object") {
      const data = select.value.map((item) => {
        let codedtext = {
          code: item,
          value: this.getLabel(item),
          terminology: this.terminology
        };
        const ordinal = this.getOrdinal(item);
        if (ordinal) {
          codedtext = Object.assign(Object.assign({}, codedtext), { ordinal });
        }
        return codedtext;
      });
      if (JSON.stringify(this.data) !== JSON.stringify(data)) {
        this.data = data;
        this._mbInput.emit();
      }
    } else if (select.value && typeof select.value === "string") {
      let data = {
        code: select.value,
        value: this.getLabel(select.value),
        terminology: this.terminology
      };
      const ordinal = this.getOrdinal(select.value);
      if (ordinal) {
        data = Object.assign(Object.assign({}, data), { ordinal });
      }
      this.data = data;
      this._mbInput.emit();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    const observer = new MutationObserver(() => {
      this.handleChildChange();
    });
    observer.observe(this, { childList: true });
    this.handleChildChange();
  }
  handleChildChange() {
    this._options = [
      ...this.querySelectorAll("mb-option")
    ];
  }
  getValue(data) {
    if (data == null)
      return "";
    if (Array.isArray(data))
      return data.map((item) => item.code || "");
    return (data === null || data === void 0 ? void 0 : data.code) || "";
  }
  reportValidity() {
    var _a2;
    const select = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-select");
    return select.reportValidity();
  }
  getTextData(data) {
    if (data == null)
      return "";
    if (Array.isArray(data))
      return (data === null || data === void 0 ? void 0 : data.map((item) => item.value || "").join(", ")) || "";
    return (data === null || data === void 0 ? void 0 : data.value) || "";
  }
  render() {
    var _a2;
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${this.getTextData(this.data) || "-"}</p>
      </div>`;
    }
    return html`
      <sl-select
        id=${this.id}
        .size=${this.variant === "small" ? "small" : "medium"}
        .disabled=${this.disabled}
        .clearable=${!this.nonclearable}
        ?required=${this.required}
        ?multiple=${this.multiple}
        placeholder=${(_a2 = this.placeholder) !== null && _a2 !== void 0 ? _a2 : "Please select"}
        label=${ifDefined(this.label)}
        @sl-change=${this.handleInput}
        @sl-clear=${() => {
      this.data = void 0;
      this._mbInput.emit();
    }}
        .hoist=${this.hoist}
        .value=${this.getValue(this.data)}
      >
        ${this._options.map((option) => html`<sl-menu-item
              .value=${option.value}
              id=${`${this.id}-${option.value}`}
            >
              ${option.display || option.label}
            </sl-menu-item>`)}
      </sl-select>
      <slot @slotchange=${this.handleChildChange}></slot>
    `;
  }
};
__decorate11([
  property({ type: String })
], MbSelect.prototype, "terminology", void 0);
__decorate11([
  property({ type: Object })
], MbSelect.prototype, "data", void 0);
__decorate11([
  property({ type: String, reflect: true })
], MbSelect.prototype, "placeholder", void 0);
__decorate11([
  property({ type: String, reflect: true })
], MbSelect.prototype, "id", void 0);
__decorate11([
  property({ type: Boolean, reflect: true })
], MbSelect.prototype, "multiple", void 0);
__decorate11([
  property({ type: Boolean, reflect: true })
], MbSelect.prototype, "required", void 0);
__decorate11([
  property({ type: Boolean, reflect: true })
], MbSelect.prototype, "hoist", void 0);
__decorate11([
  property({ type: Boolean, reflect: true })
], MbSelect.prototype, "disabled", void 0);
__decorate11([
  property({ type: Boolean, reflect: true })
], MbSelect.prototype, "nonclearable", void 0);
__decorate11([
  state()
], MbSelect.prototype, "_options", void 0);
MbSelect = __decorate11([
  customElement("mb-select")
], MbSelect);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/filter.js
var __decorate12 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbFilter = class MbFilter2 extends LitElement {
  constructor() {
    super(...arguments);
    this.disabled = false;
  }
};
__decorate12([
  property({ type: String, reflect: true })
], MbFilter.prototype, "label", void 0);
__decorate12([
  property({ type: String, reflect: true })
], MbFilter.prototype, "value", void 0);
__decorate12([
  property({ type: Boolean, reflect: true })
], MbFilter.prototype, "disabled", void 0);
MbFilter = __decorate12([
  customElement("mb-filter")
], MbFilter);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/option.js
var __decorate13 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbOption = class MbOption2 extends LitElement {
};
__decorate13([
  property({ type: String, reflect: true })
], MbOption.prototype, "value", void 0);
__decorate13([
  property({ type: String, reflect: true })
], MbOption.prototype, "label", void 0);
__decorate13([
  property({ type: String, reflect: true })
], MbOption.prototype, "display", void 0);
__decorate13([
  property({ type: Number, reflect: true })
], MbOption.prototype, "ordinal", void 0);
__decorate13([
  property({ type: String, reflect: true })
], MbOption.prototype, "type", void 0);
MbOption = __decorate13([
  customElement("mb-option")
], MbOption);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WVVUWAAN.js
var input_styles_default = r`
  ${component_styles_default}
  ${form_control_styles_default}

  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition: var(--sl-transition-fast) color, var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    padding-left: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    padding-right: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    padding-left: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    padding-right: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    padding-left: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    padding-right: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.O2TDYW3A.js
var r4 = (o8) => o8.strings === void 0;
var f2 = {};
var s5 = (o8, i24 = f2) => o8._$AH = i24;
var l5 = e5(class extends i4 {
  constructor(r22) {
    if (super(r22), r22.type !== t4.PROPERTY && r22.type !== t4.ATTRIBUTE && r22.type !== t4.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!r4(r22))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(r22) {
    return r22;
  }
  update(i24, [t22]) {
    if (t22 === b || t22 === w)
      return t22;
    const o8 = i24.element, l23 = i24.name;
    if (i24.type === t4.PROPERTY) {
      if (t22 === o8[l23])
        return b;
    } else if (i24.type === t4.BOOLEAN_ATTRIBUTE) {
      if (!!t22 === o8.hasAttribute(l23))
        return b;
    } else if (i24.type === t4.ATTRIBUTE && o8.getAttribute(l23) === t22 + "")
      return b;
    return s5(i24), t22;
  }
});

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IEE4AKXF.js
var SlInput = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.hasFocus = false;
    this.isPasswordVisible = false;
    this.type = "text";
    this.size = "medium";
    this.value = "";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.togglePassword = false;
    this.disabled = false;
    this.readonly = false;
    this.required = false;
    this.invalid = false;
  }
  get valueAsDate() {
    var _a2, _b;
    return (_b = (_a2 = this.input) == null ? void 0 : _a2.valueAsDate) != null ? _b : null;
  }
  set valueAsDate(newValue) {
    this.updateComplete.then(() => {
      this.input.valueAsDate = newValue;
      this.value = this.input.value;
    });
  }
  get valueAsNumber() {
    var _a2, _b;
    return (_b = (_a2 = this.input) == null ? void 0 : _a2.valueAsNumber) != null ? _b : parseFloat(this.value);
  }
  set valueAsNumber(newValue) {
    this.updateComplete.then(() => {
      this.input.valueAsNumber = newValue;
      this.value = this.input.value;
    });
  }
  firstUpdated() {
    this.invalid = !this.input.checkValidity();
  }
  focus(options) {
    this.input.focus(options);
  }
  blur() {
    this.input.blur();
  }
  select() {
    this.input.select();
  }
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  setRangeText(replacement, start, end, selectMode = "preserve") {
    this.input.setRangeText(replacement, start, end, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
      emit(this, "sl-input");
      emit(this, "sl-change");
    }
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    emit(this, "sl-change");
  }
  handleClearClick(event2) {
    this.value = "";
    emit(this, "sl-clear");
    emit(this, "sl-input");
    emit(this, "sl-change");
    this.input.focus();
    event2.stopPropagation();
  }
  handleDisabledChange() {
    this.input.disabled = this.disabled;
    this.invalid = !this.input.checkValidity();
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    emit(this, "sl-input");
  }
  handleInvalid() {
    this.invalid = true;
  }
  handleKeyDown(event2) {
    const hasModifier = event2.metaKey || event2.ctrlKey || event2.shiftKey || event2.altKey;
    if (event2.key === "Enter" && !hasModifier) {
      this.formSubmitController.submit();
    }
  }
  handlePasswordToggle() {
    this.isPasswordVisible = !this.isPasswordVisible;
  }
  handleValueChange() {
    this.invalid = !this.input.checkValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return $`
      <div
        part="form-control"
        class=${o6({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label part="label" class="form-control__label" for="input" aria-hidden=${hasLabel ? "false" : "true"}>
          <slot name="label">${this.label}</slot>
        </label>

        <div class="form-control__input">
          <div
            part="base"
            class=${o6({
      input: true,
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": this.value.length === 0,
      "input--invalid": this.invalid
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.isPasswordVisible ? "text" : this.type}
              name=${l4(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${l4(this.placeholder)}
              minlength=${l4(this.minlength)}
              maxlength=${l4(this.maxlength)}
              min=${l4(this.min)}
              max=${l4(this.max)}
              step=${l4(this.step)}
              .value=${l5(this.value)}
              autocapitalize=${l4(this.autocapitalize)}
              autocomplete=${l4(this.autocomplete)}
              autocorrect=${l4(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${l4(this.spellcheck)}
              pattern=${l4(this.pattern)}
              inputmode=${l4(this.inputmode)}
              aria-describedby="help-text"
              aria-invalid=${this.invalid ? "true" : "false"}
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${this.clearable && this.value.length > 0 ? $`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.togglePassword ? $`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.isPasswordVisible ? $`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : $`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = input_styles_default;
__decorateClass([
  i22(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass([
  t3()
], SlInput.prototype, "hasFocus", 2);
__decorateClass([
  t3()
], SlInput.prototype, "isPasswordVisible", 2);
__decorateClass([
  e4({ reflect: true })
], SlInput.prototype, "type", 2);
__decorateClass([
  e4({ reflect: true })
], SlInput.prototype, "size", 2);
__decorateClass([
  e4()
], SlInput.prototype, "name", 2);
__decorateClass([
  e4()
], SlInput.prototype, "value", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlInput.prototype, "filled", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlInput.prototype, "pill", 2);
__decorateClass([
  e4()
], SlInput.prototype, "label", 2);
__decorateClass([
  e4({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass([
  e4({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass([
  e4({ attribute: "toggle-password", type: Boolean })
], SlInput.prototype, "togglePassword", 2);
__decorateClass([
  e4()
], SlInput.prototype, "placeholder", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlInput.prototype, "disabled", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlInput.prototype, "readonly", 2);
__decorateClass([
  e4({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass([
  e4({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass([
  e4()
], SlInput.prototype, "min", 2);
__decorateClass([
  e4()
], SlInput.prototype, "max", 2);
__decorateClass([
  e4({ type: Number })
], SlInput.prototype, "step", 2);
__decorateClass([
  e4()
], SlInput.prototype, "pattern", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlInput.prototype, "required", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlInput.prototype, "invalid", 2);
__decorateClass([
  e4()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass([
  e4()
], SlInput.prototype, "autocorrect", 2);
__decorateClass([
  e4()
], SlInput.prototype, "autocomplete", 2);
__decorateClass([
  e4({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass([
  e4({ type: Boolean })
], SlInput.prototype, "spellcheck", 2);
__decorateClass([
  e4()
], SlInput.prototype, "inputmode", 2);
__decorateClass([
  watch2("disabled", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch2("value", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleValueChange", 1);
SlInput = __decorateClass([
  n5("sl-input")
], SlInput);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.N2MV4HXO.js
var textarea_styles_default = r`
  ${component_styles_default}
  ${form_control_styles_default}

  :host {
    display: block;
  }

  .textarea {
    display: flex;
    align-items: center;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    transition: var(--sl-transition-fast) color, var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
    cursor: text;
  }

  /* Standard textareas */
  .textarea--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .textarea--standard:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }
  .textarea--standard:hover:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-hover);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: var(--sl-focus-ring);
    color: var(--sl-input-color-focus);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-focus);
  }

  .textarea--standard.textarea--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea--standard.textarea--disabled .textarea__control {
    color: var(--sl-input-color-disabled);
  }

  .textarea--standard.textarea--disabled .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled textareas */
  .textarea--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .textarea--filled:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .textarea--filled.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  .textarea--filled.textarea--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: 1.4;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .textarea__control::-webkit-search-decoration,
  .textarea__control::-webkit-search-cancel-button,
  .textarea__control::-webkit-search-results-button,
  .textarea__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
  }

  .textarea__control:focus {
    outline: none;
  }

  /*
   * Size modifiers
   */

  .textarea--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
  }

  .textarea--small .textarea__control {
    padding: 0.5em var(--sl-input-spacing-small);
  }

  .textarea--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .textarea--medium .textarea__control {
    padding: 0.5em var(--sl-input-spacing-medium);
  }

  .textarea--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
  }

  .textarea--large .textarea__control {
    padding: 0.5em var(--sl-input-spacing-large);
  }

  /*
   * Resize types
   */

  .textarea--resize-none .textarea__control {
    resize: none;
  }

  .textarea--resize-vertical .textarea__control {
    resize: vertical;
  }

  .textarea--resize-auto .textarea__control {
    height: auto;
    resize: none;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5D7IFRWW.js
var SlTextarea = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.hasFocus = false;
    this.size = "medium";
    this.value = "";
    this.filled = false;
    this.label = "";
    this.helpText = "";
    this.rows = 4;
    this.resize = "vertical";
    this.disabled = false;
    this.readonly = false;
    this.required = false;
    this.invalid = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.setTextareaHeight());
    this.updateComplete.then(() => {
      this.setTextareaHeight();
      this.resizeObserver.observe(this.input);
    });
  }
  firstUpdated() {
    this.invalid = !this.input.checkValidity();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this.input);
  }
  focus(options) {
    this.input.focus(options);
  }
  blur() {
    this.input.blur();
  }
  select() {
    this.input.select();
  }
  scrollPosition(position) {
    if (position) {
      if (typeof position.top === "number")
        this.input.scrollTop = position.top;
      if (typeof position.left === "number")
        this.input.scrollLeft = position.left;
      return;
    }
    return {
      top: this.input.scrollTop,
      left: this.input.scrollTop
    };
  }
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  setRangeText(replacement, start, end, selectMode = "preserve") {
    this.input.setRangeText(replacement, start, end, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
      emit(this, "sl-input");
    }
    if (this.value !== this.input.value) {
      this.value = this.input.value;
      this.setTextareaHeight();
      emit(this, "sl-input");
      emit(this, "sl-change");
    }
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.setTextareaHeight();
    emit(this, "sl-change");
  }
  handleDisabledChange() {
    this.input.disabled = this.disabled;
    this.invalid = !this.input.checkValidity();
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.setTextareaHeight();
    emit(this, "sl-input");
  }
  handleRowsChange() {
    this.setTextareaHeight();
  }
  handleValueChange() {
    this.invalid = !this.input.checkValidity();
  }
  setTextareaHeight() {
    if (this.resize === "auto") {
      this.input.style.height = "auto";
      this.input.style.height = `${this.input.scrollHeight}px`;
    } else {
      this.input.style.height = void 0;
    }
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return $`
      <div
        part="form-control"
        class=${o6({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label part="label" class="form-control__label" for="input" aria-hidden=${hasLabel ? "false" : "true"}>
          <slot name="label">${this.label}</slot>
        </label>

        <div class="form-control__input">
          <div
            part="base"
            class=${o6({
      textarea: true,
      "textarea--small": this.size === "small",
      "textarea--medium": this.size === "medium",
      "textarea--large": this.size === "large",
      "textarea--standard": !this.filled,
      "textarea--filled": this.filled,
      "textarea--disabled": this.disabled,
      "textarea--focused": this.hasFocus,
      "textarea--empty": this.value.length === 0,
      "textarea--invalid": this.invalid,
      "textarea--resize-none": this.resize === "none",
      "textarea--resize-vertical": this.resize === "vertical",
      "textarea--resize-auto": this.resize === "auto"
    })}
          >
            <textarea
              part="textarea"
              id="input"
              class="textarea__control"
              name=${l4(this.name)}
              .value=${l5(this.value)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${l4(this.placeholder)}
              rows=${l4(this.rows)}
              minlength=${l4(this.minlength)}
              maxlength=${l4(this.maxlength)}
              autocapitalize=${l4(this.autocapitalize)}
              autocorrect=${l4(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${l4(this.spellcheck)}
              inputmode=${l4(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            ></textarea>
          </div>
        </div>

        <div
          part="help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlTextarea.styles = textarea_styles_default;
__decorateClass([
  i22(".textarea__control")
], SlTextarea.prototype, "input", 2);
__decorateClass([
  t3()
], SlTextarea.prototype, "hasFocus", 2);
__decorateClass([
  e4({ reflect: true })
], SlTextarea.prototype, "size", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "name", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "value", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlTextarea.prototype, "filled", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "label", 2);
__decorateClass([
  e4({ attribute: "help-text" })
], SlTextarea.prototype, "helpText", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "placeholder", 2);
__decorateClass([
  e4({ type: Number })
], SlTextarea.prototype, "rows", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "resize", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlTextarea.prototype, "disabled", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlTextarea.prototype, "readonly", 2);
__decorateClass([
  e4({ type: Number })
], SlTextarea.prototype, "minlength", 2);
__decorateClass([
  e4({ type: Number })
], SlTextarea.prototype, "maxlength", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlTextarea.prototype, "required", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlTextarea.prototype, "invalid", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "autocapitalize", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "autocorrect", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "autocomplete", 2);
__decorateClass([
  e4({ type: Boolean })
], SlTextarea.prototype, "autofocus", 2);
__decorateClass([
  e4({ type: Boolean })
], SlTextarea.prototype, "spellcheck", 2);
__decorateClass([
  e4()
], SlTextarea.prototype, "inputmode", 2);
__decorateClass([
  watch2("disabled", { waitUntilFirstUpdate: true })
], SlTextarea.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch2("rows", { waitUntilFirstUpdate: true })
], SlTextarea.prototype, "handleRowsChange", 1);
__decorateClass([
  watch2("value", { waitUntilFirstUpdate: true })
], SlTextarea.prototype, "handleValueChange", 1);
SlTextarea = __decorateClass([
  n5("sl-textarea")
], SlTextarea);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/text/input.js
var __decorate14 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbInput = class MbInput2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.textarea = false;
    this.label = "";
    this.id = "input";
    this.required = false;
    this.placeholder = "";
    this.autocomplete = false;
    this.rows = "3";
    this.resize = "auto";
  }
  handleInput(e6) {
    const inputElement = e6.target;
    this.data = inputElement.value ? inputElement.value : void 0;
    this._mbInput.emit();
  }
  reportValidity() {
    var _a2, _b;
    let input = null;
    if (this.textarea) {
      input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-textarea");
    } else {
      input = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector("sl-input");
    }
    return input.reportValidity();
  }
  render() {
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${this.data || "-"}</p>
      </div>`;
    }
    return this.textarea ? html`
          <sl-textarea
            id=${this.id}
            .size=${this.variant === "small" ? "small" : "medium"}
            .disabled=${this.disabled}
            .maxlength=${this.maxlength}
            .minlength=${this.minlength}
            ?required=${this.required}
            label=${this.label}
            placeholder=${this.placeholder}
            @sl-input=${this.handleInput}
            value=${this.data || ""}
            rows=${this.rows}
            resize=${this.resize}
            autocomplete=${this.autocomplete ? "on" : "off"}
          ></sl-textarea>
          <p class="print-only">${this.data || "-"}</p>
        ` : html`
          <sl-input
            id=${this.id}
            .size=${this.variant === "small" ? "small" : "medium"}
            .disabled=${this.disabled}
            .min=${this.min}
            .max=${this.max}
            .maxlength=${this.maxlength}
            .minlength=${this.minlength}
            .type=${this.type}
            ?required=${this.required}
            label=${this.label}
            placeholder=${this.placeholder}
            @sl-input=${this.handleInput}
            value=${this.data || ""}
            autocomplete=${this.autocomplete ? "on" : "off"}
          ></sl-input>
          <p class="print-only">${this.data || "-"}</p>
        `;
  }
};
MbInput.styles = css`
    .print-only {
      display: none;
    }

    @media print {
      .print-only {
        display: inline-block;
        margin: 0px;
        padding: 2px;
      }

      sl-input {
        display: none;
      }
      sl-textarea {
        display: none;
      }
    }
  `;
__decorate14([
  property({ type: String })
], MbInput.prototype, "data", void 0);
__decorate14([
  property({ type: Boolean, reflect: true })
], MbInput.prototype, "textarea", void 0);
__decorate14([
  property({ type: String })
], MbInput.prototype, "label", void 0);
__decorate14([
  property({ type: String, reflect: true })
], MbInput.prototype, "id", void 0);
__decorate14([
  property({ type: Boolean, reflect: true })
], MbInput.prototype, "required", void 0);
__decorate14([
  property({ type: String, reflect: true })
], MbInput.prototype, "type", void 0);
__decorate14([
  property({ type: String, reflect: true })
], MbInput.prototype, "placeholder", void 0);
__decorate14([
  property({ type: Number, reflect: true })
], MbInput.prototype, "min", void 0);
__decorate14([
  property({ type: Number, reflect: true })
], MbInput.prototype, "max", void 0);
__decorate14([
  property({ type: Number, reflect: true })
], MbInput.prototype, "minlength", void 0);
__decorate14([
  property({ type: Number, reflect: true })
], MbInput.prototype, "maxlength", void 0);
__decorate14([
  property({ type: Boolean, reflect: true })
], MbInput.prototype, "disabled", void 0);
__decorate14([
  property({ type: Boolean, reflect: true })
], MbInput.prototype, "autocomplete", void 0);
__decorate14([
  property({ type: String })
], MbInput.prototype, "rows", void 0);
__decorate14([
  property({ type: String, reflect: true })
], MbInput.prototype, "resize", void 0);
__decorate14([
  event("mb-input")
], MbInput.prototype, "_mbInput", void 0);
MbInput = __decorate14([
  customElement("mb-input")
], MbInput);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PHWU4VVX.js
var button_styles_default = r`
  ${component_styles_default}

  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition: var(--sl-transition-fast) background-color, var(--sl-transition-fast) color,
      var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label ::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger${focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-success-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-neutral-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-warning-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger${focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-danger-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text${focusVisibleSelector}:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    font-size: var(--sl-button-font-size-small);
    height: var(--sl-input-height-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    font-size: var(--sl-button-font-size-medium);
    height: var(--sl-input-height-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    font-size: var(--sl-button-font-size-large);
    height: var(--sl-input-height-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    display: flex;
    align-items: center;
  }

  .button--caret .button__caret svg {
    width: 1em;
    height: 1em;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    transform: translateY(-50%) translateX(50%);
    pointer-events: none;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-left: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-left: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-right: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-right: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-right: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-left: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(.sl-button-group__button:not(.sl-button-group__button--focus, .sl-button-group__button--first, [variant='default']):not(:hover, :active, :focus))
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump focused buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  :host(.sl-button-group__button--focus) {
    z-index: 2;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VDRCOTCD.js
var r5 = (t22, ...e22) => ({ _$litStatic$: e22.reduce((e34, o23, r22) => e34 + ((t33) => {
  if (t33._$litStatic$ !== void 0)
    return t33._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t33}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(o23) + t22[r22 + 1], t22[0]) });
var i23 = /* @__PURE__ */ new Map();
var a3 = (t22) => (e22, ...o23) => {
  var r22;
  const a22 = o23.length;
  let l32, s32;
  const n23 = [], u2 = [];
  let c2, $2 = 0, v2 = false;
  for (; $2 < a22; ) {
    for (c2 = e22[$2]; $2 < a22 && (s32 = o23[$2], l32 = (r22 = s32) === null || r22 === void 0 ? void 0 : r22._$litStatic$) !== void 0; )
      c2 += l32 + e22[++$2], v2 = true;
    u2.push(s32), n23.push(c2), $2++;
  }
  if ($2 === a22 && n23.push(e22[a22]), v2) {
    const t33 = n23.join("$$lit$$");
    (e22 = i23.get(t33)) === void 0 && (n23.raw = n23, i23.set(t33, e22 = n23)), o23 = u2;
  }
  return t22(e22, ...o23);
};
var l22 = a3($);
var s22 = a3(y);
var SlButton = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this, {
      form: (input) => {
        if (input.hasAttribute("form")) {
          const doc = input.getRootNode();
          const formId = input.getAttribute("form");
          return doc.getElementById(formId);
        }
        return input.closest("form");
      }
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.hasFocus = false;
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
  }
  click() {
    this.button.click();
  }
  focus(options) {
    this.button.focus(options);
  }
  blur() {
    this.button.blur();
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleClick(event2) {
    if (this.disabled || this.loading) {
      event2.preventDefault();
      event2.stopPropagation();
      return;
    }
    if (this.type === "submit") {
      this.formSubmitController.submit(this);
    }
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? r5`a` : r5`button`;
    return l22`
      <${tag}
        part="base"
        class=${o6({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${l4(isLink ? void 0 : this.disabled)}
        type=${this.type}
        name=${l4(isLink ? void 0 : this.name)}
        value=${l4(isLink ? void 0 : this.value)}
        href=${l4(this.href)}
        target=${l4(this.target)}
        download=${l4(this.download)}
        rel=${l4(this.target ? "noreferrer noopener" : void 0)}
        role="button"
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <span part="prefix" class="button__prefix">
          <slot name="prefix"></slot>
        </span>
        <span part="label" class="button__label">
          <slot></slot>
        </span>
        <span part="suffix" class="button__suffix">
          <slot name="suffix"></slot>
        </span>
        ${this.caret ? l22`
                <span part="caret" class="button__caret">
                  <svg
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </span>
              ` : ""}
        ${this.loading ? l22`<sl-spinner></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = button_styles_default;
__decorateClass([
  i22(".button")
], SlButton.prototype, "button", 2);
__decorateClass([
  t3()
], SlButton.prototype, "hasFocus", 2);
__decorateClass([
  e4({ reflect: true })
], SlButton.prototype, "variant", 2);
__decorateClass([
  e4({ reflect: true })
], SlButton.prototype, "size", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlButton.prototype, "caret", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlButton.prototype, "disabled", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlButton.prototype, "loading", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlButton.prototype, "outline", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlButton.prototype, "pill", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlButton.prototype, "circle", 2);
__decorateClass([
  e4()
], SlButton.prototype, "type", 2);
__decorateClass([
  e4()
], SlButton.prototype, "name", 2);
__decorateClass([
  e4()
], SlButton.prototype, "value", 2);
__decorateClass([
  e4()
], SlButton.prototype, "href", 2);
__decorateClass([
  e4()
], SlButton.prototype, "target", 2);
__decorateClass([
  e4()
], SlButton.prototype, "download", 2);
__decorateClass([
  e4()
], SlButton.prototype, "form", 2);
__decorateClass([
  e4({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass([
  e4({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass([
  e4({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass([
  e4({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
SlButton = __decorateClass([
  n5("sl-button")
], SlButton);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/buttons.js
var __decorate15 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var CodedTextButtons = class CodedTextButtons2 extends CodedTextElement {
  constructor() {
    super(...arguments);
    this.required = false;
    this.disabled = false;
    this.id = "buttons";
    this._options = [];
  }
  get _optionElements() {
    return this.querySelectorAll("mb-option");
  }
  connectedCallback() {
    super.connectedCallback();
    const observer = new MutationObserver(() => {
      this._handleChildChange();
    });
    observer.observe(this, { childList: true });
    this._handleChildChange();
  }
  _handleChildChange() {
    this._options = [
      ...this.querySelectorAll("mb-option")
    ];
  }
  reportValidity() {
    var _a2;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("input");
    return input.reportValidity();
  }
  _handleInput(option) {
    var _a2;
    let data = {
      code: option.value,
      value: option.label,
      terminology: this.terminology
    };
    if (option.ordinal) {
      data = Object.assign(Object.assign({}, data), { ordinal: option.ordinal });
    }
    if (((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.code) === data.code) {
      this.data = void 0;
    } else {
      this.data = data;
    }
    if (this.data) {
      this.value = "valid";
    }
    if (option.type) {
      console.log(option.type);
    }
    this._mbInput.emit();
  }
  getVariant(option) {
    var _a2;
    if (((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.code) === option.value) {
      return "primary";
    }
    if (option.type)
      return option.type;
    return "default";
  }
  render() {
    var _a2, _b;
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.value) || "-"}</p>
      </div>`;
    }
    return html`
      <div style="position:relative;z-index:2" part="base">
        ${this.label ? html`<label
              part="label"
              class=${this.variant === "small" ? "label-s" : "label"}
              >${this.label}</label
            >` : null}
        <div class="buttons">
          ${this._options.map((option) => html` <sl-button
                id=${`${this.id}-${option.label}`}
                .size=${this.variant === "small" ? "small" : "medium"}
                ?disabled=${this.disabled}
                @click=${() => this._handleInput(option)}
                variant=${this.getVariant(option)}
                >${option.display || option.label}
              </sl-button>`)}
        </div>
        <input
          .value=${((_b = this.data) === null || _b === void 0 ? void 0 : _b.code) || ""}
          style="transform:scale(0.025);position:absolute;top:40px;opacity:0.1"
          name="input"
          ?required=${this.required}
        />
      </div>
    `;
  }
};
CodedTextButtons.styles = css`
    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: var(--sl-spacing-2x-small);
    }

    .label {
      font-size: var(--sl-input-label-font-size-medium);
      display: inline-block;
      color: var(--sl-input-label-color);
      margin-bottom: var(--sl-spacing-3x-small);
    }

    .label-s {
      font-size: var(--sl-input-label-font-size-small);
      display: inline-block;
      color: var(--sl-input-label-color);
      margin-bottom: var(--sl-spacing-3x-small);
    }
  `;
__decorate15([
  property({ type: Boolean, reflect: true })
], CodedTextButtons.prototype, "required", void 0);
__decorate15([
  property({ type: Boolean, reflect: true })
], CodedTextButtons.prototype, "disabled", void 0);
__decorate15([
  property({ type: String, reflect: true })
], CodedTextButtons.prototype, "id", void 0);
__decorate15([
  state()
], CodedTextButtons.prototype, "_options", void 0);
CodedTextButtons = __decorate15([
  customElement("mb-buttons")
], CodedTextButtons);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/buttons-multiple.js
var __decorate16 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var CodedTextButtons3 = class CodedTextButtons4 extends CodedTextElement {
  constructor() {
    super(...arguments);
    this.required = false;
    this.disabled = false;
    this.multiple = true;
    this.id = "buttons-multiple";
    this._options = [];
    this.value = {};
  }
  get _optionElements() {
    return this.querySelectorAll("mb-option");
  }
  connectedCallback() {
    super.connectedCallback();
    const observer = new MutationObserver(() => {
      this._handleChildChange();
    });
    observer.observe(this, { childList: true });
    this._handleChildChange();
  }
  _handleChildChange() {
    this._options = [
      ...this.querySelectorAll("mb-option")
    ];
  }
  reportValidity() {
    var _a2;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("input");
    return input.reportValidity();
  }
  _handleInput(option) {
    let data = {
      code: option.value,
      value: option.label,
      terminology: this.terminology
    };
    if (option.ordinal) {
      data = Object.assign(Object.assign({}, data), { ordinal: option.ordinal });
    }
    this.value = data;
    this.addValue();
    this._mbInput.emit();
  }
  valueExists(code) {
    var _a2;
    return (_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.some((el) => el.code === code);
  }
  addValue() {
    var _a2;
    if (this.data == null)
      this.data = [];
    if (this.valueExists(this.value.code)) {
      this.data = (_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.filter((d2) => d2.code !== this.value.code);
    } else {
      this.data = [...this.data, this.value];
    }
    this.value = {};
    this._mbInput.emit();
  }
  getVariant(option) {
    if (this.valueExists(option.value)) {
      return "primary";
    }
    if (option.type)
      return option.type;
    return "default";
  }
  render() {
    var _a2;
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>
          ${((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.map((item) => (item === null || item === void 0 ? void 0 : item.value) || "").join(", ")) || ""}
        </p>
      </div>`;
    }
    return html`
      <div style="position:relative;z-index:2" part="base">
        ${this.label ? html`<label
              part="label"
              class=${this.variant === "small" ? "label-s" : "label"}
              >${this.label}</label
            >` : null}
        <div class="buttons">
          ${this._options.map((option) => html` <sl-button
                id=${`${this.id}-${option.label}`}
                .size=${this.variant === "small" ? "small" : "medium"}
                ?disabled=${this.disabled}
                @click=${() => this._handleInput(option)}
                variant=${this.getVariant(option)}
                >${this.valueExists(option.value) ? html`<sl-icon
                      library="medblocks"
                      name="check2"
                      slot="prefix"
                    ></sl-icon>` : null}${option.display || option.label}
              </sl-button>`)}
        </div>
        <input
          style="transform:scale(0.025);position:absolute;top:40px;opacity:0.1"
          name="input"
          ?required=${this.required}
        />
      </div>
    `;
  }
};
CodedTextButtons3.styles = css`
    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: var(--sl-spacing-2x-small);
    }

    .label {
      font-size: var(--sl-input-label-font-size-medium);
      display: inline-block;
      color: var(--sl-input-label-color);
      margin-bottom: var(--sl-spacing-3x-small);
    }

    .label-s {
      font-size: var(--sl-input-label-font-size-small);
      display: inline-block;
      color: var(--sl-input-label-color);
      margin-bottom: var(--sl-spacing-3x-small);
    }
  `;
__decorate16([
  property({ type: Boolean, reflect: true })
], CodedTextButtons3.prototype, "required", void 0);
__decorate16([
  property({ type: Boolean, reflect: true })
], CodedTextButtons3.prototype, "disabled", void 0);
__decorate16([
  property({ type: Boolean, reflect: true })
], CodedTextButtons3.prototype, "multiple", void 0);
__decorate16([
  property({ type: String, reflect: true })
], CodedTextButtons3.prototype, "id", void 0);
__decorate16([
  state()
], CodedTextButtons3.prototype, "_options", void 0);
__decorate16([
  state()
], CodedTextButtons3.prototype, "value", void 0);
CodedTextButtons3 = __decorate16([
  customElement("mb-buttons-multiple")
], CodedTextButtons3);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/quantity/QuantityElement.js
var __decorate17 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var QuantityElement = class extends EhrElement {
};
__decorate17([
  property({ type: Object })
], QuantityElement.prototype, "data", void 0);
__decorate17([
  event("mb-input")
], QuantityElement.prototype, "_mbInput", void 0);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/quantity/quantity.js
var __decorate18 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbQuantity = class MbQuantity2 extends QuantityElement {
  constructor() {
    super(...arguments);
    this.required = false;
    this.min = 0;
    this.hideunit = false;
    this.autocomplete = false;
    this.hoist = false;
    this.placeholder = "";
    this.id = "quantity";
    this.hideicon = false;
    this.enablesingleunit = false;
    this.units = [];
  }
  handleChildChange() {
    var _a2, _b, _c;
    this.units = [...this.querySelectorAll("mb-unit")];
    if (this.units.length === 0)
      return;
    let unitToUse = this.default;
    if ((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.unit) {
      unitToUse = this.data.unit;
    }
    const selectedUnit = unitToUse && this.units.find((unit) => unit.unit === unitToUse) || this.units[0];
    if (selectedUnit) {
      this.min = (_b = selectedUnit.min) !== null && _b !== void 0 ? _b : null;
      this.max = (_c = selectedUnit.max) !== null && _c !== void 0 ? _c : null;
      if (this.inputElement) {
        this.inputElement.min = String(this.min || "");
        this.inputElement.max = String(this.max || "");
      }
    }
  }
  reportValidity() {
    var _a2;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-input");
    return input.reportValidity();
  }
  connectedCallback() {
    super.connectedCallback();
    const observer = new MutationObserver(() => {
      this.handleChildChange();
    });
    observer.observe(this, { attributes: true, childList: true });
  }
  _disabled() {
    return this.disabled || (this.enablesingleunit ? false : this.units.length === 1);
  }
  handleInput() {
    const magnitude = this.inputElement.value ? Number.parseFloat(this.inputElement.value) : void 0;
    const unit = this.selectElement.value || this.default;
    if (magnitude == null) {
      this.data = void 0;
    } else {
      this.data = {
        unit,
        magnitude
      };
    }
    const selectedUnit = this.units.find((un) => un.unit === unit);
    if (selectedUnit) {
      this.min = selectedUnit.min ? selectedUnit.min : null;
      this.max = selectedUnit.max ? selectedUnit.max : null;
      if (this.inputElement) {
        this.inputElement.min = String(this.min || "");
        this.inputElement.max = String(this.max || "");
      }
    }
    this._mbInput.emit();
  }
  get displayUnit() {
    var _a2, _b;
    if (this.selectElement && this.selectElement.value) {
      return this.selectElement.value;
    }
    if ((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.unit) {
      return (_b = this.data) === null || _b === void 0 ? void 0 : _b.unit;
    }
    if (this.default) {
      return this.default;
    }
    return "";
  }
  render() {
    var _a2, _b, _c, _d, _e, _f;
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <div style="display:flex;gap:0 8px">
          <p>${((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.magnitude) || "-"}</p>
          <p>${this.hideunit ? "" : ((_b = this.data) === null || _b === void 0 ? void 0 : _b.unit) || "-"}</p>
        </div>
      </div>`;
    }
    return html`
      <sl-input
        id=${`${this.id}-magnitude`}
        class=${this.hideunit ? "" : "margin-xs"}
        .size=${this.variant === "small" ? "small" : "medium"}
        .disabled=${this.disabled}
        .step=${(_c = this.step) !== null && _c !== void 0 ? _c : "any"}
        .required=${this.required}
        .max=${this.max}
        .min=${this.min}
        label=${ifDefined(this.label)}
        type="number"
        @sl-input=${this.handleInput}
        .value=${((_e = (_d = this.data) === null || _d === void 0 ? void 0 : _d.magnitude) === null || _e === void 0 ? void 0 : _e.toString()) || ""}
        placeholder=${this.placeholder}
        autocomplete=${this.autocomplete ? "on" : "off"}
      ></sl-input>
      <sl-select
        id=${`${this.id}-unit`}
        exportparts="menu"
        .disabled=${this._disabled()}
        class="${this._disabled() || this.hideicon ? "no-icon" : ""}"
        style="${this.hideunit ? "display: none" : ""}"
        placeholder="Select units"
        .hoist=${this.hoist}
        .value=${this.displayUnit}
        .size=${this.variant === "small" ? "small" : "medium"}
        @sl-change=${this.handleInput}
      >
        ${this.units.map((unit) => html`<sl-menu-item
              value=${unit.unit}
              id=${`${this.id}-unit-${unit.unit}`}
              max=${unit.max}
              min=${unit.min}
              >${unit.label}</sl-menu-item
            >`)}
      </sl-select>
      <slot style="display: none" @slotchange=${this.handleChildChange}></slot>
      <p class="print-only">${((_f = this.data) === null || _f === void 0 ? void 0 : _f.magnitude) || "-"}</p>
    `;
  }
};
MbQuantity.styles = css`
    .no-icon::part(icon) {
      display: none;
    }

    :host {
      display: flex;
      flex: 1;
      align-items: flex-end;
    }

    sl-input {
      width: 0;
      flex: 3 1 auto;
      min-width: 75px;
    }

    .margin-xs {
      margin-right: var(--sl-spacing-x-small);
    }

    sl-select {
      flex: 1 1 auto;
      width: fit-content;
      min-width: 100px;
    }
    .print-only {
      display: none;
    }

    @media print {
      .print-only {
        display: inline-block;
        margin: 0px;
        padding: 2px;
      }

      sl-input {
        display: none;
      }
      sl-select {
        display: none;
      }
    }
  `;
__decorate18([
  property({ type: String, reflect: true })
], MbQuantity.prototype, "default", void 0);
__decorate18([
  property({ type: Boolean, reflect: true })
], MbQuantity.prototype, "required", void 0);
__decorate18([
  property({ type: Number, reflect: true })
], MbQuantity.prototype, "max", void 0);
__decorate18([
  property({ type: Number, reflect: true })
], MbQuantity.prototype, "min", void 0);
__decorate18([
  property({ type: Boolean, reflect: true })
], MbQuantity.prototype, "hideunit", void 0);
__decorate18([
  property({ type: Boolean, reflect: true })
], MbQuantity.prototype, "autocomplete", void 0);
__decorate18([
  property({ type: Boolean, reflect: true })
], MbQuantity.prototype, "hoist", void 0);
__decorate18([
  property({ type: Boolean, reflect: true })
], MbQuantity.prototype, "disabled", void 0);
__decorate18([
  property({ type: Number, reflect: true })
], MbQuantity.prototype, "step", void 0);
__decorate18([
  property({ type: String, reflect: true })
], MbQuantity.prototype, "placeholder", void 0);
__decorate18([
  property({ type: String, reflect: true })
], MbQuantity.prototype, "id", void 0);
__decorate18([
  property({ type: Boolean })
], MbQuantity.prototype, "hideicon", void 0);
__decorate18([
  property({ type: Boolean, reflect: true })
], MbQuantity.prototype, "enablesingleunit", void 0);
__decorate18([
  state()
], MbQuantity.prototype, "units", void 0);
__decorate18([
  query("sl-input")
], MbQuantity.prototype, "inputElement", void 0);
__decorate18([
  query("sl-select")
], MbQuantity.prototype, "selectElement", void 0);
MbQuantity = __decorate18([
  customElement("mb-quantity")
], MbQuantity);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/quantity/unit.js
var __decorate19 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbUnit = class MbUnit2 extends LitElement {
};
__decorate19([
  property({ type: String, reflect: true })
], MbUnit.prototype, "unit", void 0);
__decorate19([
  property({ type: String, reflect: true })
], MbUnit.prototype, "label", void 0);
__decorate19([
  property({ type: Number, reflect: true })
], MbUnit.prototype, "max", void 0);
__decorate19([
  property({ type: Number, reflect: true })
], MbUnit.prototype, "min", void 0);
MbUnit = __decorate19([
  customElement("mb-unit")
], MbUnit);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/submit/submit.js
var __decorate20 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbSubmit = class MbSubmit2 extends LitElement {
  handleClick() {
    this.submit.emit();
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.handleClick);
  }
  disconnectedCallback() {
    this.removeEventListener("click", this.handleClick);
  }
  render() {
    return html` <slot></slot> `;
  }
};
__decorate20([
  event("mb-trigger-submit")
], MbSubmit.prototype, "submit", void 0);
MbSubmit = __decorate20([
  customElement("mb-submit")
], MbSubmit);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/datetime/date.js
var __decorate21 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbDateTime = class MbDateTime2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.label = "";
    this.max = "";
    this.min = "";
    this.time = false;
    this.dvdatetime = false;
    this.required = false;
    this.id = "date";
  }
  handleInput(e6) {
    const inputElement = e6.target;
    if (this.time)
      this.data = inputElement.value ? new Date(inputElement.value).toISOString() : void 0;
    else if (this.dvdatetime)
      this.data = inputElement.value ? `${inputElement.value}T00:00:00Z` : void 0;
    else
      this.data = inputElement.value ? inputElement.value : void 0;
    this._mbInput.emit();
  }
  reportValidity() {
    var _a2;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-input");
    return input.reportValidity();
  }
  getValue(data, isTime) {
    if (isTime && data) {
      const date = data.split("T")[0];
      const timeString = new Date(data).toTimeString();
      const time = timeString.slice(0, 5);
      return `${date}T${time}`;
    }
    if (!isTime && data) {
      return new Date(data).toISOString().split("T")[0];
    }
    return "";
  }
  getTextData(data) {
    const [date, time] = data.split("T");
    if (this.dvdatetime) {
      return date;
    }
    if (time) {
      const [hours, minutes] = time.split(":");
      return `${date} ${hours}:${minutes}`;
    }
    return date;
  }
  render() {
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <div style="display:flex;">
          <p>${this.data ? this.getTextData(this.data) : "-"}</p>
        </div>
      </div>`;
    }
    return html`
      <sl-input
        id=${this.id}
        part="sl-input"
        class=${this.data ? "" : "placeholder"}
        .size=${this.variant === "small" ? "small" : "medium"}
        .disabled=${this.disabled}
        ?required=${this.required}
        .max=${this.max}
        .min=${this.min}
        type="${this.time ? "datetime-local" : "date"}"
        label=${this.label}
        @sl-input=${this.handleInput}
        value=${this.getValue(this.data, this.time) || ""}
      >
      </sl-input>
    `;
  }
};
MbDateTime.styles = css`
    sl-input::part(base) {
      width: unset;
    }
    .placeholder::part(input) {
      color: var(--sl-input-placeholder-color);
    }
  `;
__decorate21([
  property({ type: String })
], MbDateTime.prototype, "data", void 0);
__decorate21([
  property({ type: String, reflect: true })
], MbDateTime.prototype, "label", void 0);
__decorate21([
  property({ type: String, reflect: true })
], MbDateTime.prototype, "max", void 0);
__decorate21([
  property({ type: String, reflect: true })
], MbDateTime.prototype, "min", void 0);
__decorate21([
  property({ type: Boolean, reflect: true })
], MbDateTime.prototype, "time", void 0);
__decorate21([
  property({ type: Boolean, reflect: true })
], MbDateTime.prototype, "dvdatetime", void 0);
__decorate21([
  property({ type: Boolean, reflect: true })
], MbDateTime.prototype, "required", void 0);
__decorate21([
  property({ type: Boolean, reflect: true })
], MbDateTime.prototype, "disabled", void 0);
__decorate21([
  property({ type: String, reflect: true })
], MbDateTime.prototype, "id", void 0);
__decorate21([
  event("mb-input")
], MbDateTime.prototype, "_mbInput", void 0);
MbDateTime = __decorate21([
  customElement("mb-date")
], MbDateTime);

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BXPHLFH5.js
var checkbox_styles_default = r`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .checkbox {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--sl-toggle-size);
    height: var(--sl-toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color, var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__control .checkbox__icon {
    display: inline-flex;
    width: var(--sl-toggle-size);
    height: var(--sl-toggle-size);
  }

  .checkbox__control .checkbox__icon svg {
    width: 100%;
    height: 100%;
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled)
    .checkbox__input${focusVisibleSelector}
    ~ .checkbox__control {
    border-color: var(--sl-input-border-color-focus);
    background-color: var(--sl-input-background-color-focus);
    box-shadow: var(--sl-focus-ring);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input${focusVisibleSelector} ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled)
    .checkbox__input${focusVisibleSelector}
    ~ .checkbox__control {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    line-height: var(--sl-toggle-size);
    margin-left: 0.5em;
    user-select: none;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.0.0-beta.71/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.4RYHHWIR.js
var SlCheckbox = class extends s4 {
  constructor() {
    super(...arguments);
    this.formSubmitController = new FormSubmitController(this, {
      value: (control) => control.checked ? control.value : void 0
    });
    this.hasFocus = false;
    this.disabled = false;
    this.required = false;
    this.checked = false;
    this.indeterminate = false;
    this.invalid = false;
  }
  firstUpdated() {
    this.invalid = !this.input.checkValidity();
  }
  click() {
    this.input.click();
  }
  focus(options) {
    this.input.focus(options);
  }
  blur() {
    this.input.blur();
  }
  reportValidity() {
    return this.input.reportValidity();
  }
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.invalid = !this.input.checkValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    emit(this, "sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    emit(this, "sl-blur");
  }
  handleDisabledChange() {
    this.input.disabled = this.disabled;
    this.invalid = !this.input.checkValidity();
  }
  handleFocus() {
    this.hasFocus = true;
    emit(this, "sl-focus");
  }
  handleStateChange() {
    this.invalid = !this.input.checkValidity();
  }
  render() {
    return $`
      <label
        part="base"
        class=${o6({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate
    })}
      >
        <input
          class="checkbox__input"
          type="checkbox"
          name=${l4(this.name)}
          value=${l4(this.value)}
          .indeterminate=${l5(this.indeterminate)}
          .checked=${l5(this.checked)}
          .disabled=${this.disabled}
          .required=${this.required}
          aria-checked=${this.checked ? "true" : "false"}
          @click=${this.handleClick}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
        />

        <span part="control" class="checkbox__control">
          ${this.checked ? $`
                <span part="checked-icon" class="checkbox__icon">
                  <svg viewBox="0 0 16 16">
                    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
                      <g stroke="currentColor" stroke-width="2">
                        <g transform="translate(3.428571, 3.428571)">
                          <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
                          <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
                        </g>
                      </g>
                    </g>
                  </svg>
                </span>
              ` : ""}
          ${!this.checked && this.indeterminate ? $`
                <span part="indeterminate-icon" class="checkbox__icon">
                  <svg viewBox="0 0 16 16">
                    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
                      <g stroke="currentColor" stroke-width="2">
                        <g transform="translate(2.285714, 6.857143)">
                          <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
                        </g>
                      </g>
                    </g>
                  </svg>
                </span>
              ` : ""}
        </span>

        <span part="label" class="checkbox__label">
          <slot></slot>
        </span>
      </label>
    `;
  }
};
SlCheckbox.styles = checkbox_styles_default;
__decorateClass([
  i22('input[type="checkbox"]')
], SlCheckbox.prototype, "input", 2);
__decorateClass([
  t3()
], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass([
  e4()
], SlCheckbox.prototype, "name", 2);
__decorateClass([
  e4()
], SlCheckbox.prototype, "value", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "disabled", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "required", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "checked", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass([
  e4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "invalid", 2);
__decorateClass([
  watch2("disabled", { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch2("checked", { waitUntilFirstUpdate: true }),
  watch2("indeterminate", { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleStateChange", 1);
SlCheckbox = __decorateClass([
  n5("sl-checkbox")
], SlCheckbox);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/boolean/checkbox.js
var __decorate22 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbCheckBox = class MbCheckBox2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.data = void 0;
    this.disabled = false;
    this.required = false;
    this.id = "checkbox";
  }
  _handleChange(e6) {
    const checkbox = e6.target;
    this.data = !!checkbox.checked;
    this._mbInput.emit();
  }
  reportValidity() {
    var _a2;
    const checked = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-checkbox");
    return checked.reportValidity();
  }
  render() {
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${this.data ? "Yes" : "No"}</p>
      </div>`;
    }
    return html`<sl-checkbox
      id=${this.id}
      ?required=${this.required}
      ?disabled=${this.disabled}
      ?checked=${this.data}
      ?indeterminate=${this.data == null}
      @sl-change=${this._handleChange}
      >${this.label}</sl-checkbox
    >`;
  }
};
__decorate22([
  property({ type: Boolean })
], MbCheckBox.prototype, "data", void 0);
__decorate22([
  property({ type: Boolean, reflect: true })
], MbCheckBox.prototype, "disabled", void 0);
__decorate22([
  property({ type: Boolean, reflect: true })
], MbCheckBox.prototype, "required", void 0);
__decorate22([
  property({ type: String, reflect: true })
], MbCheckBox.prototype, "id", void 0);
MbCheckBox = __decorate22([
  customElement("mb-checkbox")
], MbCheckBox);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/proportion/MbProportion.js
var __decorate23 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbProportion = class extends EhrElement {
  constructor() {
    super(...arguments);
    this.data = void 0;
    this.required = false;
    this.autocomplete = false;
    this.hoist = false;
    this.placeholder = "";
    this.id = "proportion";
    this.hideunit = false;
  }
  _handleChange(e6) {
    const inputElement = e6.target;
    if (inputElement.value === "") {
      this.data = void 0;
    } else {
      this.data = {
        numerator: Number.parseFloat(inputElement.value),
        denominator: this.type === "unitary" ? 1 : 100,
        type: this.type === "unitary" ? 1 : 2
      };
    }
    this._mbInput.emit();
  }
  reportValidity() {
    var _a2;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-input");
    return input.reportValidity();
  }
  getStep() {
    if (this.step) {
      return this.step;
    }
    if (this.type === "unitary") {
      return "0.01";
    }
    return "";
  }
  getText() {
    var _a2, _b, _c;
    if ((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.numerator) {
      if (this.type === "percent") {
        return `${(_b = this.data) === null || _b === void 0 ? void 0 : _b.numerator} %`;
      }
      return (_c = this.data) === null || _c === void 0 ? void 0 : _c.numerator;
    }
    return "-";
  }
  render() {
    var _a2, _b;
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${this.getText()}</p>
      </div>`;
    }
    return html`<sl-input
        id=${`${this.id}-magnitude`}
        .required=${this.required}
        .min=${this.min}
        .max=${this.max}
        .size=${this.variant === "small" ? "small" : "medium"}
        .disabled=${this.disabled}
        type="number"
        .step=${this.getStep()}
        label=${ifDefined(this.label)}
        @sl-input=${this._handleChange}
        class=${this.hideunit ? "" : "margin-xs"}
        .value=${((_b = (_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.numerator) === null || _b === void 0 ? void 0 : _b.toString()) || ""}
        placeholder=${this.placeholder}
        autocomplete=${this.autocomplete ? "on" : "off"}
      >
      </sl-input>
      <sl-select
        id=${`${this.id}-unit`}
        style="${this.hideunit ? "display: none" : ""}"
        placeholder="Select units"
        class="no-icon"
        .hoist=${this.hoist}
        value="unit"
        .size=${this.variant === "small" ? "small" : "medium"}
        disabled
      >
        <sl-menu-item value="unit"
          >${this.type === "unitary" ? "/ 1" : "%"}</sl-menu-item
        >
      </sl-select> `;
  }
};
MbProportion.styles = css`
    .no-icon::part(icon) {
      display: none;
    }

    sl-input {
      width: 0;
      flex: 3 1 auto;
      min-width: 75px;
    }

    .margin-xs {
      margin-right: var(--sl-spacing-x-small);
    }

    sl-select {
      flex: 1 1 auto;
      width: 0;
      min-width: 100px;
    }

    :host {
      display: flex;
      flex: 1;
      align-items: flex-end;
    }
  `;
__decorate23([
  property({ type: Object })
], MbProportion.prototype, "data", void 0);
__decorate23([
  property({ type: Boolean, reflect: true })
], MbProportion.prototype, "required", void 0);
__decorate23([
  property({ type: Boolean, reflect: true })
], MbProportion.prototype, "autocomplete", void 0);
__decorate23([
  property({ type: Boolean, reflect: true })
], MbProportion.prototype, "hoist", void 0);
__decorate23([
  property({ type: String, reflect: true })
], MbProportion.prototype, "step", void 0);
__decorate23([
  property({ type: Boolean, reflect: true })
], MbProportion.prototype, "disabled", void 0);
__decorate23([
  property({ type: String, reflect: true })
], MbProportion.prototype, "placeholder", void 0);
__decorate23([
  property({ type: String, reflect: true })
], MbProportion.prototype, "id", void 0);
__decorate23([
  property({ type: Boolean })
], MbProportion.prototype, "hideunit", void 0);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/proportion/percent.js
var __decorate24 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbPercent = class MbPercent2 extends MbProportion {
  constructor() {
    super(...arguments);
    this.type = "percent";
    this.min = "0";
    this.max = "100";
  }
};
__decorate24([
  property({ type: String, reflect: true })
], MbPercent.prototype, "type", void 0);
__decorate24([
  property({ type: String, reflect: true })
], MbPercent.prototype, "min", void 0);
__decorate24([
  property({ type: String, reflect: true })
], MbPercent.prototype, "max", void 0);
MbPercent = __decorate24([
  customElement("mb-percent")
], MbPercent);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/context/checkboxAny.js
var __decorate25 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbCheckBox3 = class MbCheckBox4 extends EhrElement {
  constructor() {
    super(...arguments);
    this.data = void 0;
    this.bind = void 0;
    this.disabled = false;
  }
  _handleChange(e6) {
    const checkbox = e6.target;
    this.data = checkbox.checked ? this.bind : void 0;
    this._mbInput.emit();
  }
  render() {
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${this.data || "-"}</p>
      </div>`;
    }
    return html`<sl-checkbox
      .size=${this.variant === "small" ? "small" : "medium"}
      ?disabled=${this.disabled}
      ?checked=${!!this.data}
      @sl-change=${this._handleChange}
      >${this.label}</sl-checkbox
    >`;
  }
};
__decorate25([
  property()
], MbCheckBox3.prototype, "data", void 0);
__decorate25([
  property()
], MbCheckBox3.prototype, "bind", void 0);
__decorate25([
  property({ type: Boolean, reflect: true })
], MbCheckBox3.prototype, "disabled", void 0);
MbCheckBox3 = __decorate25([
  customElement("mb-checkbox-any")
], MbCheckBox3);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/text/text-select.js
var __decorate26 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbTextSelect = class MbTextSelect2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.multiple = false;
    this.required = false;
    this.hoist = false;
    this.id = "text_select";
    this._options = [];
  }
  get _optionElements() {
    return this.querySelectorAll("mb-option");
  }
  handleInput(e6) {
    const select = e6.target;
    if (select.value) {
      this.data = select.value;
      this._mbInput.emit();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    const observer = new MutationObserver(() => {
      this.handleChildChange();
    });
    observer.observe(this, { childList: true });
    this.handleChildChange();
  }
  handleChildChange() {
    this._options = [
      ...this.querySelectorAll("mb-option")
    ];
  }
  reportValidity() {
    var _a2;
    const select = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-select");
    return select.reportValidity();
  }
  render() {
    var _a2;
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${this.data || "-"}</p>
      </div> `;
    }
    return html`
      <sl-select
        id=${this.id}
        exportparts="menu"
        .size=${this.variant === "small" ? "small" : "medium"}
        .clearable=${!this.nonclearable}
        .disabled=${this.disabled}
        ?required=${this.required}
        ?multiple=${this.multiple}
        placeholder=${(_a2 = this.placeholder) !== null && _a2 !== void 0 ? _a2 : "Please select"}
        label=${ifDefined(this.label)}
        @sl-change=${this.handleInput}
        @sl-clear=${() => {
      this.data = void 0;
      this._mbInput.emit();
    }}
        .hoist=${this.hoist}
        .value=${this.data || ""}
      >
        ${this._options.map((option) => html`<sl-menu-item
              .value=${option.value}
              id=${`${this.id}-${option.label}`}
              >${option.display || option.label}
            </sl-menu-item>`)}
      </sl-select>
      <slot @slotchange=${this.handleChildChange}></slot>
    `;
  }
};
__decorate26([
  property({ type: Object })
], MbTextSelect.prototype, "data", void 0);
__decorate26([
  property({ type: String })
], MbTextSelect.prototype, "terminology", void 0);
__decorate26([
  property({ type: Boolean, reflect: true })
], MbTextSelect.prototype, "disabled", void 0);
__decorate26([
  property({ type: Boolean, reflect: true })
], MbTextSelect.prototype, "multiple", void 0);
__decorate26([
  property({ type: Boolean, reflect: true })
], MbTextSelect.prototype, "required", void 0);
__decorate26([
  property({ type: Boolean, reflect: true })
], MbTextSelect.prototype, "hoist", void 0);
__decorate26([
  property({ type: Boolean, reflect: true })
], MbTextSelect.prototype, "nonclearable", void 0);
__decorate26([
  property({ type: String, reflect: true })
], MbTextSelect.prototype, "placeholder", void 0);
__decorate26([
  property({ type: String, reflect: true })
], MbTextSelect.prototype, "id", void 0);
__decorate26([
  state()
], MbTextSelect.prototype, "_options", void 0);
MbTextSelect = __decorate26([
  customElement("mb-text-select")
], MbTextSelect);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/text/input-multiple.js
var __decorate27 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbInputMultiple = class MbInputMultiple2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.data = [];
    this.multiple = true;
    this.hidehelp = false;
    this.placeholder = "";
    this.id = "input_multiple";
    this.required = false;
    this.autocomplete = false;
    this.value = "";
  }
  handleClear(tagIndex) {
    if (!this.disabled) {
      this.data = this.data.filter((_2, i5) => i5 !== tagIndex);
      this._mbInput.emit();
    }
  }
  handleInput(e6) {
    const target = e6.target;
    this.value = target.value;
  }
  addValue() {
    if (this.value !== "") {
      this.data = [...this.data, this.value];
      this.value = "";
      this._mbInput.emit();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("keypress", (event2) => {
      if (event2.key === "Enter") {
        this.addValue();
      }
    });
  }
  disconnectedCallback() {
    this.removeEventListener("keypress", (event2) => {
      if (event2.key === "Enter") {
        this.addValue();
      }
    });
    super.disconnectedCallback();
  }
  reportValidity() {
    var _a2;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-input");
    if (this.data.length > 0) {
      return true;
    }
    return input.reportValidity();
  }
  render() {
    var _a2, _b;
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.join(", ")) || "-"}</p>
      </div>`;
    }
    return html`
      <div class="input-container">
        <sl-input
          id=${this.id}
          .size=${this.variant === "small" ? "small" : "medium"}
          .disabled=${this.disabled}
          ?required=${this.required}
          help-text=${this.hidehelp ? "" : `Press enter to add ${this.placeholder}`}
          @sl-input=${this.handleInput}
          label=${this.label || ""}
          .value=${this.value}
          @sl-blur=${() => this.addValue()}
          autocomplete=${this.autocomplete ? "on" : "off"}
        >
          ${this.value && html`<sl-icon @click=${this.addValue} library="medblocks" name="arrow-right-circle" slot="suffix"></sl-icon>
                </sl-icon>`}
        </sl-input>
      </div>
      <div class="tag-container">
        ${(_b = this.data) === null || _b === void 0 ? void 0 : _b.map((s6, i5) => html`<sl-tag
              id=${`${this.id}_tag${i5}`}
              variant="neutral"
              size=${this.variant === "small" ? "small" : "medium"}
              @sl-remove=${() => this.handleClear(i5)}
              removable
              ><span>${s6}</span></sl-tag
            >`)}
      </div>
      <p class="print-only">
        <span>${this.data.join(", ") || "-"}</span>
      </p>
    `;
  }
};
MbInputMultiple.styles = css`
    :host {
      display: block;
      width: 100%;
    }
    .input-container {
      width: 100%;
    }
    .tag-container {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
    }
    sl-tag {
      margin: var(--sl-spacing-x-small) var(--sl-spacing-x-small) 0 0;
      max-width: 100%;
      --sl-tag-content-spacing: var(--sl-spacing-2x-small)
        var(--sl-spacing-2x-small);
    }
    sl-tag::part(base) {
      max-width: 100%;
      overflow-wrap: break-word;
      word-break: break-word;
      white-space: normal;
      height: auto;
      min-height: var(--sl-input-height-small);
      line-height: 1.5;
    }
    sl-tag::part(content) {
      overflow: hidden;
      text-overflow: ellipsis;
    }
    sl-icon {
      font-size: var(--sl-font-size-large);
      cursor: pointer;
    }

    .print-only {
      display: none;
    }

    @media print {
      sl-tag {
        display: none;
      }

      sl-input {
        display: none;
      }
      .print-only {
        display: inline-block;
        margin: 0px;
        padding: 2px;
      }
    }
  `;
__decorate27([
  property({ type: Array })
], MbInputMultiple.prototype, "data", void 0);
__decorate27([
  property({ type: Boolean })
], MbInputMultiple.prototype, "multiple", void 0);
__decorate27([
  property({ type: Boolean, reflect: true })
], MbInputMultiple.prototype, "hidehelp", void 0);
__decorate27([
  property({ type: String, reflect: true })
], MbInputMultiple.prototype, "placeholder", void 0);
__decorate27([
  property({ type: String, reflect: true })
], MbInputMultiple.prototype, "id", void 0);
__decorate27([
  property({ type: Boolean, reflect: true })
], MbInputMultiple.prototype, "required", void 0);
__decorate27([
  property({ type: Boolean, reflect: true })
], MbInputMultiple.prototype, "autocomplete", void 0);
__decorate27([
  property({ type: Boolean, reflect: true })
], MbInputMultiple.prototype, "disabled", void 0);
__decorate27([
  state()
], MbInputMultiple.prototype, "value", void 0);
MbInputMultiple = __decorate27([
  customElement("mb-input-multiple")
], MbInputMultiple);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/duration/duration.js
var __decorate28 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbDuration = class MbDuration2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.year = false;
    this.month = false;
    this.week = false;
    this.day = false;
    this.hour = false;
    this.minute = false;
    this.second = false;
    this.required = false;
    this.autocomplete = false;
    this.hidelabel = false;
    this.min = "1";
    this.placeholder = "";
    this.id = "duration";
    this._state = {};
  }
  parsePeriod(period) {
    if (period) {
      const [periodPart, t5] = period.split("T");
      const p2 = periodPart.replace("P", "");
      this._state.year = this.getPart(p2, "Y");
      this._state.month = this.getPart(p2, "M");
      this._state.week = this.getPart(p2, "W");
      this._state.day = this.getPart(p2, "D");
      if (t5) {
        this._state.hour = this.getPart(t5, "H");
        this._state.minute = this.getPart(t5, "M");
        this._state.second = this.getPart(t5, "S");
      }
    }
  }
  getPart(periodPart, part) {
    const myRegexp = new RegExp(`(\\d+)${part}`, "g");
    const match = myRegexp.exec(periodPart);
    return match ? match[1] : void 0;
  }
  serializePeriod() {
    const hour = this._state.hour ? `${this._state.hour}H` : "";
    const minute = this._state.minute ? `${this._state.minute}M` : "";
    const second = this._state.second ? `${this._state.second}S` : "";
    const t5 = [hour, minute, second].join("");
    const year = this._state.year ? `${this._state.year}Y` : "";
    const month = this._state.month ? `${this._state.month}M` : "";
    const week = this._state.week ? `${this._state.week}W` : "";
    const day = this._state.day ? `${this._state.day}D` : "";
    const p2 = [year, month, week, day].join("");
    const timePart = t5 ? `T${t5}` : "";
    const periodPart = p2 ? `P${p2}` : "";
    if (!periodPart && !timePart)
      return void 0;
    if (!periodPart && timePart)
      return `P${timePart}`;
    return `${periodPart}${timePart}`;
  }
  get data() {
    return this.serializePeriod();
  }
  set data(period) {
    const oldVal = this.data;
    this.parsePeriod(period);
    this.requestUpdate("data", oldVal);
  }
  handleInput(value, e6) {
    const oldVal = this.data;
    const target = e6.target;
    this._state = Object.assign(Object.assign({}, this._state), { [value]: target.value });
    this.requestUpdate("data", oldVal);
    this._mbInput.emit();
  }
  formatDuration(value) {
    return `${value.charAt(0).toUpperCase() + value.slice(1)}s`;
  }
  reportValidity() {
    var _a2;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-input");
    return input.reportValidity();
  }
  getInputs() {
    const allDurations = {
      year: this.year,
      month: this.month,
      week: this.week,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
    const durationKeys = Object.keys(allDurations);
    const toRender = durationKeys.every((a4) => allDurations[a4] === false) ? durationKeys : durationKeys.filter((a4) => allDurations[a4]);
    return toRender.map((a4) => html`<sl-input
        .disabled=${this.disabled}
        .size=${this.variant === "small" ? "small" : "medium"}
        id=${`${this.id}-${this.formatDuration(a4)}`}
        type="number"
        .min=${this.min}
        ?required=${this.required}
        placeholder=${this.placeholder}
        help-text=${this.hidelabel ? "" : this.formatDuration(a4)}
        .value=${this._state[a4] || ""}
        @sl-input=${(e6) => this.handleInput(a4, e6)}
        autocomplete=${this.autocomplete ? "on" : "off"}
      ></sl-input>`);
  }
  render() {
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <div style="display:flex">
          <p>${this._state.day ? this._state.day : "-"}</p>
        </div>
      </div>`;
    }
    return html`
      ${this.label ? html`<label
            part="label"
            class=${this.variant === "small" ? "label-s" : "label"}
            >${this.label}</label
          >` : null}
      <div class="duration">${this.getInputs()}</div>
      <p class="print-only">${this._state.day || "-"}</p>
    `;
  }
};
MbDuration.styles = css`
    .duration {
      display: flex;
      gap: 10px;
    }
    .label {
      font-size: var(--sl-input-label-font-size-medium);
      display: inline-block;
      color: var(--sl-input-label-color);
      margin-bottom: var(--sl-spacing-xxx-small);
    }
    .label-s {
      font-size: var(--sl-input-label-font-size-small);
      display: inline-block;
      color: var(--sl-input-label-color);
      margin-bottom: var(--sl-spacing-xxx-small);
    }
    sl-input {
      width: 0;
      flex: 1 1 auto;
    }

    .print-only {
      display: none;
    }

    @media print {
      .print-only {
        display: inline-block;
        margin: 0px;
        padding: 2px;
      }
      .label {
        display: none;
      }
      .label-s {
        display: none;
      }
      .duration {
        display: none;
      }
    }
  `;
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "year", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "month", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "week", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "day", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "hour", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "minute", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "second", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "required", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "autocomplete", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "disabled", void 0);
__decorate28([
  property({ type: Boolean, reflect: true })
], MbDuration.prototype, "hidelabel", void 0);
__decorate28([
  property({ type: String, reflect: true })
], MbDuration.prototype, "min", void 0);
__decorate28([
  property({ type: String, reflect: true })
], MbDuration.prototype, "placeholder", void 0);
__decorate28([
  property({ type: String, reflect: true })
], MbDuration.prototype, "id", void 0);
__decorate28([
  state()
], MbDuration.prototype, "_state", void 0);
MbDuration = __decorate28([
  customElement("mb-duration")
], MbDuration);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/proportion/proportion.js
var __decorate29 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbPercent3 = class MbPercent4 extends MbProportion {
  constructor() {
    super(...arguments);
    this.type = "unitary";
    this.min = "0";
    this.max = "1";
  }
};
__decorate29([
  property({ type: String, reflect: true })
], MbPercent3.prototype, "type", void 0);
__decorate29([
  property({ type: String, reflect: true })
], MbPercent3.prototype, "min", void 0);
__decorate29([
  property({ type: String, reflect: true })
], MbPercent3.prototype, "max", void 0);
MbPercent3 = __decorate29([
  customElement("mb-proportion")
], MbPercent3);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/count/count.js
var __decorate30 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbCount = class MbCount2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.label = "";
    this.placeholder = "";
    this.id = "count";
    this.required = false;
    this.autocomplete = false;
    this.min = 0;
  }
  handleInput(e6) {
    const inputElement = e6.target;
    this.data = Number.parseFloat(inputElement.value);
    this._mbInput.emit();
  }
  reportValidity() {
    var _a2;
    const input = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("sl-input");
    return input.reportValidity();
  }
  render() {
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>${this.data >= Number(this.min || 0) ? this.data : "-"}</p>
      </div>`;
    }
    return html`
      <sl-input
        id=${this.id}
        .disabled=${this.disabled}
        type="number"
        .size=${this.variant === "small" ? "small" : "medium"}
        .min=${this.min}
        .max=${this.max}
        ?required=${this.required}
        label=${this.label}
        @sl-input=${this.handleInput}
        value=${this.data >= Number(this.min || 0) ? this.data : ""}
        placeholder=${this.placeholder}
        autocomplete=${this.autocomplete ? "on" : "off"}
      ></sl-input>
    `;
  }
};
__decorate30([
  property({ type: Number })
], MbCount.prototype, "data", void 0);
__decorate30([
  property({ type: String })
], MbCount.prototype, "label", void 0);
__decorate30([
  property({ type: String, reflect: true })
], MbCount.prototype, "placeholder", void 0);
__decorate30([
  property({ type: String, reflect: true })
], MbCount.prototype, "id", void 0);
__decorate30([
  property({ type: Boolean, reflect: true })
], MbCount.prototype, "required", void 0);
__decorate30([
  property({ type: Boolean, reflect: true })
], MbCount.prototype, "autocomplete", void 0);
__decorate30([
  property({ type: Boolean, reflect: true })
], MbCount.prototype, "disabled", void 0);
__decorate30([
  property({ type: Number, reflect: true })
], MbCount.prototype, "max", void 0);
__decorate30([
  property({ type: Number, reflect: true })
], MbCount.prototype, "min", void 0);
__decorate30([
  event("mb-input")
], MbCount.prototype, "_mbInput", void 0);
MbCount = __decorate30([
  customElement("mb-count")
], MbCount);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/multimedia/mediaFunction.js
function createUUID() {
  let dt = (/* @__PURE__ */ new Date()).getTime();
  const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r6 = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 === "x" ? r6 : r6 & 3 | 8).toString(16);
  });
  return uuid;
}
var supabaseStoragePlugin = {
  upload: async ({ axios, file }) => {
    const form = new FormData();
    form.append("data", file);
    const response = await axios.post(`/${createUUID()}`, form, {
      headers: {
        "Content-Type": "multipart/form-data"
      }
    });
    const key = response.data.Key.split("/")[1];
    return key;
  },
  download: async ({ axios, key }) => {
    const response = await axios({
      url: `/${key}`,
      method: "GET",
      responseType: "blob"
    });
    const file = new File([response.data], "patientData");
    return URL.createObjectURL(file);
  }
};

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/multimedia/multimedia.js
var __decorate31 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbMultimedia = class MbMultimedia2 extends EhrElement {
  constructor() {
    super(...arguments);
    this.data = void 0;
    this.label = "";
    this.parentAxiosKey = "storage-api";
    this.required = false;
    this.loading = false;
    this.base64 = false;
    this.plugin = {
      storageAPI: supabaseStoragePlugin
    };
  }
  get _parentAxios() {
    const dependencyEvent = this._mbDependency.emit({
      detail: { key: this.parentAxiosKey }
    });
    return dependencyEvent.detail.value;
  }
  async _handleChange(e6) {
    var _a2, _b;
    const element = e6.target;
    const file = (_a2 = element.files) === null || _a2 === void 0 ? void 0 : _a2[0];
    if (((_b = e6.target) === null || _b === void 0 ? void 0 : _b.value) === "") {
      this.data = void 0;
    } else if (file) {
      if (this.base64) {
        const reader = new FileReader();
        let base64Data = "";
        reader.onload = (event2) => {
          var _a3;
          base64Data = (_a3 = event2.target) === null || _a3 === void 0 ? void 0 : _a3.result;
          this.data = {
            data: base64Data,
            mediatype: file === null || file === void 0 ? void 0 : file.type,
            alternatetext: file === null || file === void 0 ? void 0 : file.name,
            size: file === null || file === void 0 ? void 0 : file.size
          };
        };
        reader.readAsDataURL(file);
      } else {
        const axios = this.axios ? this.axios : this._parentAxios;
        this.loading = true;
        const output = await this.plugin.storageAPI.upload({ axios, file });
        this.data = {
          _root: `s3:///${output}`,
          mediatype: file === null || file === void 0 ? void 0 : file.type,
          alternatetext: file === null || file === void 0 ? void 0 : file.name,
          size: file === null || file === void 0 ? void 0 : file.size
        };
        this.handleInput();
        this.loading = false;
      }
    }
    this._mbInput.emit();
  }
  async handleInput() {
    var _a2, _b, _c;
    this.loading = true;
    if (this.base64) {
      this.src = (_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.data;
    } else {
      try {
        const axios = this.axios ? this.axios : this._parentAxios;
        const downloadedFile = await this.plugin.storageAPI.download({
          axios,
          key: (_c = (_b = this.data) === null || _b === void 0 ? void 0 : _b._root) === null || _c === void 0 ? void 0 : _c.split("///")[1]
        });
        this.src = downloadedFile;
      } catch (e6) {
        this.src = "";
      }
    }
    this.loading = false;
  }
  getSrc() {
    this.handleInput();
  }
  render() {
    var _a2;
    return html`
      <p>
        <input
          type="file"
          accept="image/*"
          name="image"
          id="file"
          label=${this.label}
          @change=${this._handleChange}
        />
      </p>
      ${((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.alternatetext) || ""}
      ${this.loading ? html` <p>
            <img
              alt=""
              width="200"
              src="https://upload.wikimedia.org/wikipedia/commons/b/b1/Loading_icon.gif"
            />
          </p>` : html` <p><img alt="" width="200" src=${this.src || ""} /></p> `}
    `;
  }
};
__decorate31([
  property({ type: Object })
], MbMultimedia.prototype, "data", void 0);
__decorate31([
  property({ type: String })
], MbMultimedia.prototype, "src", void 0);
__decorate31([
  property({ type: String })
], MbMultimedia.prototype, "label", void 0);
__decorate31([
  property({ type: String })
], MbMultimedia.prototype, "parentAxiosKey", void 0);
__decorate31([
  property({ type: Boolean, reflect: true })
], MbMultimedia.prototype, "required", void 0);
__decorate31([
  property({ type: Boolean, reflect: true })
], MbMultimedia.prototype, "loading", void 0);
__decorate31([
  property({ type: Boolean, reflect: true })
], MbMultimedia.prototype, "base64", void 0);
__decorate31([
  property({ type: Object })
], MbMultimedia.prototype, "axios", void 0);
__decorate31([
  property({ type: Object })
], MbMultimedia.prototype, "plugin", void 0);
__decorate31([
  watch("data")
], MbMultimedia.prototype, "getSrc", null);
MbMultimedia = __decorate31([
  customElement("mb-multimedia")
], MbMultimedia);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/codedtext/search-multiple.js
var __decorate32 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbSearchMultiple = class MbSearchMultiple2 extends MbSearchAbstract {
  constructor() {
    super(...arguments);
    this.multiple = true;
    this.value = {};
  }
  _handleSelect(data) {
    if (data.text) {
      this.value = data.text;
    } else {
      this.value = {
        code: data.code,
        value: data.value,
        terminology: data.terminology
      };
    }
    if (this.data == null) {
      this.data = [];
    }
    this.data = [...this.data, this.value];
    this.value = {};
    this.searchTerm = "";
    this._mbInput.emit();
  }
  get _hasValue() {
    var _a2, _b;
    return !!(((_a2 = this === null || this === void 0 ? void 0 : this.value) === null || _a2 === void 0 ? void 0 : _a2.value) && ((_b = this === null || this === void 0 ? void 0 : this.value) === null || _b === void 0 ? void 0 : _b.code));
  }
  get _display() {
    var _a2;
    return this._hasValue ? (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.value : void 0;
  }
  get _code() {
    var _a2;
    return this._hasValue ? (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.code : void 0;
  }
  handleClear(tagIndex) {
    if (!this.disabled) {
      this.data = this.data.filter((_2, i5) => i5 !== tagIndex);
      this._mbInput.emit();
    }
  }
  render() {
    var _a2, _b;
    if (this.variant === "text") {
      return html`<div>
        ${this._label()}
        <p>
          ${Array.isArray(this === null || this === void 0 ? void 0 : this.data) ? (_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.map((item) => this.getDisplay(item)).join(", ") : ""}
        </p>
      </div>`;
    }
    return html`
      ${this._searchBar()}
      <div>
        ${(_b = this.data) === null || _b === void 0 ? void 0 : _b.map((s6, i5) => html`<sl-tag
              variant=${typeof s6 === "string" ? "neutral" : "primary"}
              size=${this.variant === "small" ? "small" : "medium"}
              @sl-remove=${() => this.handleClear(i5)}
              removable
              ><span>${typeof s6 === "string" ? s6 : s6.value}</span></sl-tag
            >`)}
      </div>
      <slot @slotchange=${this._handleChildChange}></slot>
    `;
  }
};
MbSearchMultiple.styles = css`
    :host,
    mb-dropdown {
      display: block;
    }
    sl-input.pointer::part(base) {
      cursor: default;
    }
    .tags {
      padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
    }
    .more {
      display: flex;
      justify-content: space-between;
      padding: var(--sl-spacing-3x-small) var(--sl-spacing-small);
    }
    .tags sl-tag {
      padding: var(--sl-spacing-2x-small);
    }
    .tag-container {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
      margin-top: var(--sl-spacing-x-small);
    }
    sl-tag {
      margin: var(--sl-spacing-x-small) var(--sl-spacing-x-small) 0 0;
      max-width: 100%;
      --sl-tag-content-spacing: var(--sl-spacing-2x-small)
        var(--sl-spacing-2x-small);
    }
    sl-tag::part(base) {
      max-width: 100%;
      overflow-wrap: break-word;
      word-break: break-word;
      white-space: normal;
      height: auto;
      min-height: var(--sl-input-height-small);
      line-height: 1.5;
      cursor: pointer;
    }
    sl-tag::part(content) {
      overflow: hidden;
      text-overflow: ellipsis;
    }
  `;
__decorate32([
  property({ type: Boolean })
], MbSearchMultiple.prototype, "multiple", void 0);
__decorate32([
  state()
], MbSearchMultiple.prototype, "value", void 0);
MbSearchMultiple = __decorate32([
  customElement("mb-search-multiple")
], MbSearchMultiple);

// node_modules/.pnpm/lit-html@1.4.1/node_modules/lit-html/directives/unsafe-html.js
var previousValues2 = /* @__PURE__ */ new WeakMap();
var unsafeHTML = directive((value) => (part) => {
  if (!(part instanceof NodePart)) {
    throw new Error("unsafeHTML can only be used in text bindings");
  }
  const previousValue = previousValues2.get(part);
  if (previousValue !== void 0 && isPrimitive(value) && value === previousValue.value && part.value === previousValue.fragment) {
    return;
  }
  const template = document.createElement("template");
  template.innerHTML = value;
  const fragment = document.importNode(template.content, true);
  part.setValue(fragment);
  previousValues2.set(part, { value, fragment });
});

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/repeat/repeatableSimple.js
var __decorate33 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbRepeatable = class MbRepeatable2 extends Repeatable {
  constructor() {
    super(...arguments);
    this.css = "";
  }
  handleAdd() {
    this.count++;
  }
  _getSlotElements() {
    var _a2;
    const slot = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("slot");
    return slot === null || slot === void 0 ? void 0 : slot.assignedElements({ flatten: true });
  }
  reloadSlot() {
    const nodes = this.assignedNodes.filter((node) => node.nodeType === node.ELEMENT_NODE);
    if (nodes.length > 1) {
      console.warn(`mb-repeatable [path=${this.path}] only support one nested element. Got ${nodes.length} elements. Only taking the first.`);
    }
    [this.slotNode] = nodes;
  }
  replacePath(htmlPath, i5) {
    const replaced = htmlPath.replace(this.regex, `$1:${i5}`);
    return replaced;
  }
  connectedCallback() {
    super.connectedCallback();
    this.count = 1;
    this.observer = new MutationObserver((mutationList, _2) => {
      mutationList.forEach((record) => {
        if (record.removedNodes.length > 0) {
          record.removedNodes.forEach((node) => {
            if (node.isMbElement) {
              this._mbDisconnect.emit({ detail: node.path });
            } else if (node.nodeType === node.ELEMENT_NODE) {
              const allNodes = node.querySelectorAll("*");
              allNodes.forEach((nod) => {
                if (nod.isMbElement) {
                  this._mbDisconnect.emit({ detail: nod.path });
                }
              });
            }
          });
        }
      });
    });
    this.observer.observe(this.renderRoot, {
      childList: true,
      subtree: true,
      attributes: false
    });
  }
  render() {
    return html`
      <slot @slotchange=${this.reloadSlot}></slot>
      ${[...Array(this.count - 1)].map((_2, i5) => {
      var _a2;
      return html`${unsafeHTML(this.replacePath((_a2 = this.slotNode) === null || _a2 === void 0 ? void 0 : _a2.outerHTML, i5 + 1))}`;
    })}

      <slot name="add">
        <sl-button
          @click=${() => {
      this.count++;
    }}
          >Add</sl-button
        >
      </slot>
      <slot name="delete">
        <sl-button
          @click=${() => this.count > 1 && this.count--}
          ?disabled=${this.count <= 1}
          >Delete</sl-button
        >
      </slot>
      <link rel="stylesheet" href=${this.css} />
    `;
  }
};
__decorate33([
  queryAssignedNodes(void 0, true)
], MbRepeatable.prototype, "assignedNodes", void 0);
__decorate33([
  state()
], MbRepeatable.prototype, "slotNode", void 0);
__decorate33([
  state()
], MbRepeatable.prototype, "observer", void 0);
__decorate33([
  event("mb-disconnect")
], MbRepeatable.prototype, "_mbDisconnect", void 0);
__decorate33([
  property({ type: String, reflect: true })
], MbRepeatable.prototype, "css", void 0);
MbRepeatable = __decorate33([
  customElement("mb-repeatable-simple")
], MbRepeatable);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/repeat/repeatableHeadless.js
var __decorate34 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbRepeatableHeadless = class MbRepeatableHeadless2 extends Repeatable {
};
MbRepeatableHeadless.styles = css`
    :host {
      display: none;
    }
  `;
MbRepeatableHeadless = __decorate34([
  customElement("mb-repeatable-headless")
], MbRepeatableHeadless);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/suggestionWrapper.js
var __decorate35 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var SuggestWrapper = class SuggestWrapper2 extends LitElement {
  constructor() {
    super(...arguments);
    this.suggestions = [];
    this.global = false;
    this.label = "";
  }
  _handleSuggestion(suggestion) {
    this._suggestionEvent.emit({
      detail: {
        suggestion,
        path: this.path,
        global: this.global
      }
    });
  }
  render() {
    return html`
      <slot></slot>
      <div class="suggestions">
        ${this.suggestions.length > 0 ? html`<span class="label">${this.label}</span>` : null}
        <div class="suggest-buttons">
          ${this.suggestions.map((suggestion) => html`
              <sl-button
                id=${suggestion.label}
                @click=${() => this._handleSuggestion(suggestion)}
                size="small"
                pill
                removable
                >${suggestion.label}</sl-button
              >
            `)}
        </div>
      </div>
    `;
  }
};
SuggestWrapper.styles = css`
    .suggestions {
      display: block;
      flex-wrap: wrap;
      gap: var(--sl-spacing-2x-small);
      margin-top: var(--sl-spacing-2x-small);
    }

    .label {
      font-weight: var(--sl-font-weight-light);
      font-size: var(--sl-input-help-text-font-size-medium);
      color: var(--sl-input-help-text-color);
    }

    .suggest-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: var(--sl-spacing-2x-small);
      margin-top: var(--sl-spacing-2x-small);
    }

    sl-tag {
      cursor: pointer;
    }
  `;
__decorate35([
  event("mb-suggestion")
], SuggestWrapper.prototype, "_suggestionEvent", void 0);
__decorate35([
  property({ type: String, reflect: true })
], SuggestWrapper.prototype, "path", void 0);
__decorate35([
  property({ type: Array })
], SuggestWrapper.prototype, "suggestions", void 0);
__decorate35([
  property({ type: Boolean, reflect: true })
], SuggestWrapper.prototype, "global", void 0);
__decorate35([
  property({ type: String, reflect: true })
], SuggestWrapper.prototype, "label", void 0);
SuggestWrapper = __decorate35([
  customElement("mb-suggest")
], SuggestWrapper);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/src/medblocks/hide.js
var __decorate36 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r6 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
  else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d2 = decorators[i5]) r6 = (c2 < 3 ? d2(r6) : c2 > 3 ? d2(target, key, r6) : d2(target, key)) || r6;
  return c2 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var MbHide = class MbHide2 extends LitElement {
  constructor() {
    super(...arguments);
    this.show = false;
  }
  render() {
    return html`
      <style>
        :host {
          display: ${this.show ? "block" : "none"};
        }
      </style>
      <slot></slot>
    `;
  }
};
__decorate36([
  property({ type: Boolean, reflect: true })
], MbHide.prototype, "show", void 0);
__decorate36([
  property({ type: String, reflect: true })
], MbHide.prototype, "path", void 0);
MbHide = __decorate36([
  customElement("mb-hide")
], MbHide);

// node_modules/.pnpm/medblocks-ui@0.0.217/node_modules/medblocks-ui/dist/medblocks.js
registerIcons();
/*! Bundled license information:

lit-html/lib/dom.js:
lit-html/lib/template.js:
lit-html/lib/modify-template.js:
lit-html/lib/directive.js:
lit-html/lib/template-instance.js:
lit-html/lib/template-result.js:
lit-html/lib/parts.js:
lit-html/lib/template-factory.js:
lit-html/lib/render.js:
lit-html/lib/default-template-processor.js:
lit-html/lit-html.js:
lit-html/lib/shady-render.js:
lit-element/lib/updating-element.js:
lit-element/lib/decorators.js:
lit-element/lit-element.js:
lit-html/directives/until.js:
lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/part.js:
lit-html/directives/class-map.js:
lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-element/lib/css-tag.js:
  (**
  @license
  Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  *)

@shoelace-style/shoelace/dist/chunks/chunk.PEQICPKO.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@shoelace-style/shoelace/dist/chunks/chunk.72DLNKYZ.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@shoelace-style/shoelace/dist/chunks/chunk.2JQPDYNA.js:
@shoelace-style/shoelace/dist/chunks/chunk.X2HKYC6R.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@shoelace-style/shoelace/dist/chunks/chunk.7BXY5XRG.js:
@shoelace-style/shoelace/dist/chunks/chunk.R37SUKY2.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@shoelace-style/shoelace/dist/chunks/chunk.O2TDYW3A.js:
@shoelace-style/shoelace/dist/chunks/chunk.VDRCOTCD.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=medblocks-ui.js.map
